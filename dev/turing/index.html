<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage with Turing.jl · FlexiChains.jl</title><meta name="title" content="Usage with Turing.jl · FlexiChains.jl"/><meta property="og:title" content="Usage with Turing.jl · FlexiChains.jl"/><meta property="twitter:title" content="Usage with Turing.jl · FlexiChains.jl"/><meta name="description" content="Documentation for FlexiChains.jl."/><meta property="og:description" content="Documentation for FlexiChains.jl."/><meta property="twitter:description" content="Documentation for FlexiChains.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexiChains.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Usage with Turing.jl</a><ul class="internal"><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Accessing-data"><span>Accessing data</span></a></li><li><a class="tocitem" href="#Splitting-VarNames-up"><span>Splitting VarNames up</span></a></li><li><a class="tocitem" href="#Summary-statistics"><span>Summary statistics</span></a></li><li><a class="tocitem" href="#Saving-and-resuming-MCMC-sampling-progress"><span>Saving and resuming MCMC sampling progress</span></a></li><li><a class="tocitem" href="#Posterior-predictions-and-friends"><span>Posterior predictions and friends</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../indexing/">Indexing in FlexiChains.jl</a></li><li><a class="tocitem" href="../details/">FlexiChains in more detail</a></li><li><a class="tocitem" href="../whynew/">Why a new package?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage with Turing.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage with Turing.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl/blob/main/docs/src/turing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-with-Turing.jl"><a class="docs-heading-anchor" href="#Usage-with-Turing.jl">Usage with Turing.jl</a><a id="Usage-with-Turing.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-with-Turing.jl" title="Permalink"></a></h1><p>This page describes how to use FlexiChains from the perspective of a Turing.jl user.</p><p>In particular, it does not explain &#39;under the hood&#39; how FlexiChains works. Rather, it focuses on the usage of FlexiChains within a typical Bayesian inference workflow. For more detailed information about the inner workings of FlexiChains, please see <a href="../details/">the &#39;more detail&#39; page</a>.</p><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>To obtain a <code>FlexiChain</code> from Turing.jl, you will need to specify a <code>chain_type</code> of <code>FlexiChains.VNChain</code> when performing MCMC sampling.</p><p>Let&#39;s use a non-trivial model so that we can illustrate some features of FlexiChains.</p><pre><code class="language-julia hljs">using Turing, FlexiChains

y = [28, 8, -3, 7, -1, 1, 18, 12]
sigma = [15, 10, 16, 11, 9, 11, 10, 18]
@model function eight_schools(y, sigma)
    mu ~ Normal(0, 5)
    tau ~ truncated(Cauchy(0, 5); lower=0)
    theta ~ MvNormal(fill(mu, length(y)), tau^2 * I)
    for i in eachindex(y)
        y[i] ~ Normal(theta[i], sigma[i])
    end
    return (mu=mu, tau=tau)
end
model = eight_schools(y, sigma)
chain = sample(model, NUTS(), 5; chain_type=VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain | 5 iterations (<span class="sgr38_5" style="color:#ff875f">3:7</span>) | 1 chain (<span class="sgr38_5" style="color:#0087d7">1:1</span>)</span>
<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>mu, tau, theta
<span class="sgr1">Extra keys       </span>:acceptance_rate, :loglikelihood, :nom_step_size, :max_hamiltonian_energy_error, :lp, :is_accept, :step_size, :tree_depth, :numerical_error, :log_density, :hamiltonian_energy_error, :hamiltonian_energy, :logprior, :n_steps
</code></pre><div class="admonition is-info" id="Note-c58b79a61802d46a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c58b79a61802d46a" title="Permalink"></a></header><div class="admonition-body"><p>We only run 5 MCMC iterations here to keep the output in the following sections small.</p></div></div><h2 id="Accessing-data"><a class="docs-heading-anchor" href="#Accessing-data">Accessing data</a><a id="Accessing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-data" title="Permalink"></a></h2><p>First, notice in the printout above that a <code>FlexiChain</code> stores &#39;parameters&#39; and &#39;other keys&#39; separately. Parameters correspond to random variables of the model you sampled from, whereas other keys are extra data associated with the samples drawn (for example, the log-joint probability of each sample). Each of these are accessed in a slightly different way.</p><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><p>To access parameters, the <em>most correct</em> way is to use <code>VarName</code>s to index into the chain. <code>VarName</code> is a data structure <a href="https://turinglang.org/AbstractPPL.jl/stable/api/#AbstractPPL.VarName">defined in AbstractPPL.jl</a>, and is what Turing.jl uses to represent the name of a random variable (appearing on the left-hand side of a tilde-statement).</p><p><code>VarName</code>s are most easily constructed by applying the <code>@varname</code> macro to the name of the variable that you want to access. For example, this directly gives us the value of <code>mu</code> in each iteration as a plain old vector of floats.</p><pre><code class="language-julia hljs">chain[@varname(mu)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">5</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├──────────────────────────┴────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">3:7</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└───────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>  <span class="sgr38_5" style="color:#0087d7">1</span>
 <span class="sgr38_5" style="color:#ff875f">3</span>    4.53071
 <span class="sgr38_5" style="color:#ff875f">4</span>    3.77985
 <span class="sgr38_5" style="color:#ff875f">5</span>    3.77985
 <span class="sgr38_5" style="color:#ff875f">6</span>    3.77985
 <span class="sgr38_5" style="color:#ff875f">7</span>    3.77985</code></pre><div class="admonition is-info" id="DimMatrix-a3cf30e7f02daab7"><header class="admonition-header">DimMatrix<a class="admonition-anchor" href="#DimMatrix-a3cf30e7f02daab7" title="Permalink"></a></header><div class="admonition-body"><p>Indexing into a <code>FlexiChain</code> returns a <a href="https://rafaqz.github.io/DimensionalData.jl/stable/dimarrays#DimArrays"><code>DimensionalData.DimMatrix</code></a>. This behaves exactly like a regular <code>Matrix</code>, but additionally carries extra information about its dimensions.</p><p>This allows you to keep track of what each dimension means, and also allows for more advanced indexing operations, which are described in <a href="../indexing/">the &#39;indexing&#39; page</a>.</p></div></div><p>For vector-valued parameters like <code>theta</code>, this works in exactly the same way, except that you get a <code>DimMatrix</code> of vectors.</p><pre><code class="language-julia hljs">chain[@varname(theta)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">5</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Vector{Float64}, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├──────────────────────────────────┴────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">3:7</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└───────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>  …  <span class="sgr38_5" style="color:#0087d7">1</span>
 <span class="sgr38_5" style="color:#ff875f">3</span>        [2.79498, 2.43223, 1.64215, 5.34525, 5.31124, 3.41784, 2.70496, 4.7134]
 <span class="sgr38_5" style="color:#ff875f">4</span>        [2.21629, 2.72744, 1.52781, 4.72131, 5.55143, 3.26861, 3.39598, 4.6027]
 <span class="sgr38_5" style="color:#ff875f">5</span>        [2.21629, 2.72744, 1.52781, 4.72131, 5.55143, 3.26861, 3.39598, 4.6027]
 <span class="sgr38_5" style="color:#ff875f">6</span>        [2.21629, 2.72744, 1.52781, 4.72131, 5.55143, 3.26861, 3.39598, 4.6027]
 <span class="sgr38_5" style="color:#ff875f">7</span>    …   [2.21629, 2.72744, 1.52781, 4.72131, 5.55143, 3.26861, 3.39598, 4.6027]</code></pre><p>Note that the samples are stored <em>not</em> as a 3D array, but rather a matrix of vectors. <strong>This is probably the biggest difference between FlexiChains and MCMCChains.</strong> MCMCChains by default will break vector-valued parameters into multiple scalar-valued parameters called <code>theta[1]</code>, <code>theta[2]</code>, etc., whereas FlexiChains keeps them together as they were defined in the model.</p><p>If you want to obtain only the first element of <code>theta</code>, you can index into it with the corresponding <code>VarName</code>:</p><pre><code class="language-julia hljs">chain[@varname(theta[1])]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">5</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├──────────────────────────┴────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">3:7</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└───────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>  <span class="sgr38_5" style="color:#0087d7">1</span>
 <span class="sgr38_5" style="color:#ff875f">3</span>    2.79498
 <span class="sgr38_5" style="color:#ff875f">4</span>    2.21629
 <span class="sgr38_5" style="color:#ff875f">5</span>    2.21629
 <span class="sgr38_5" style="color:#ff875f">6</span>    2.21629
 <span class="sgr38_5" style="color:#ff875f">7</span>    2.21629</code></pre><p>In this way, you can &#39;break down&#39;, or access nested fields of, larger parameters. That is, if your model has <code>x ~ dist</code>, FlexiChains will let you access some field or index of <code>x</code>.</p><div class="admonition is-info" id="Heterogeneous-data-9fbc1897755b61ce"><header class="admonition-header">Heterogeneous data<a class="admonition-anchor" href="#Heterogeneous-data-9fbc1897755b61ce" title="Permalink"></a></header><div class="admonition-body"><p>If some samples of <code>x</code> have one element and others have two elements, attempting to access <code>x[2]</code> will return an array with <code>missing</code> values for the samples where <code>x</code> only has one element.</p></div></div><div class="admonition is-info" id="Sub-variables-a6d34d5e26044e45"><header class="admonition-header">Sub-variables<a class="admonition-anchor" href="#Sub-variables-a6d34d5e26044e45" title="Permalink"></a></header><div class="admonition-body"><p>You can access <em>sub-variables</em> of a model parameter, but not the other way around. If your model looks like</p><pre><code class="language-julia hljs">@model function f()
    x[1] ~ dist
    return x[2] ~ dist
end</code></pre><p>or alternatively</p><pre><code class="language-julia hljs">@model function f()
    x = Vector{Float64}(undef, 2)
    return x .~ dist
end</code></pre><p>you cannot &#39;reconstruct&#39; <code>x</code> from its component elements, because <code>x</code> does not exist as a single parameter in the model. (Or at least, you can&#39;t do it with FlexiChains. You can still call <code>chain[@varname(x[1])]</code> and <code>chain[@varname(x[2])]</code> and then perform <code>hcat</code> or similar to put them together yourself.)</p></div></div><p>You can also use keyword arguments when indexing to specify which chains or iterations you are interested in. Note that when using square brackets to index, keyword arguments must be separated by commas, not semicolons!</p><pre><code class="language-julia hljs">chain[@varname(mu), iter=2:4, chain=1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">3-element </span>DimArray{Float64, 1}<span class="sgr90"> ┐</span>
<span class="sgr90">├────────────────────────────────┴──────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">4:6</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└───────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">4</span>  3.77985
 <span class="sgr38_5" style="color:#ff875f">5</span>  3.77985
 <span class="sgr38_5" style="color:#ff875f">6</span>  3.77985</code></pre><p>The indexing behaviour of FlexiChains is described fully on <a href="../indexing/">the next page</a>.</p><h3 id="Other-keys"><a class="docs-heading-anchor" href="#Other-keys">Other keys</a><a id="Other-keys-1"></a><a class="docs-heading-anchor-permalink" href="#Other-keys" title="Permalink"></a></h3><p>In general Turing.jl tries to package up some extra metadata into the chain that may be helpful. For example, the log-joint probability of each sample is stored with the key <code>:lp</code>. To access non-parameter information like this in an unambiguous fashion, you should use the <code>Extra</code> wrapper.</p><pre><code class="language-julia hljs">using FlexiChains: Extra

chain[Extra(:lp)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">5</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├──────────────────────────┴────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">3:7</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└───────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>    <span class="sgr38_5" style="color:#0087d7">1</span>
 <span class="sgr38_5" style="color:#ff875f">3</span>    -51.2429
 <span class="sgr38_5" style="color:#ff875f">4</span>    -49.2218
 <span class="sgr38_5" style="color:#ff875f">5</span>    -49.2218
 <span class="sgr38_5" style="color:#ff875f">6</span>    -49.2218
 <span class="sgr38_5" style="color:#ff875f">7</span>    -49.2218</code></pre><p>If there is no ambiguity in the symbol <code>:lp</code>, then you can use a shortcut which is described in the next section.</p><h3 id="Indexing-by-Symbol:-a-shortcut"><a class="docs-heading-anchor" href="#Indexing-by-Symbol:-a-shortcut">Indexing by <code>Symbol</code>: a shortcut</a><a id="Indexing-by-Symbol:-a-shortcut-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-by-Symbol:-a-shortcut" title="Permalink"></a></h3><p>If you are used to MCMCChains.jl, you may find this more cumbersome than before. So, FlexiChains provides some shortcuts for accessing data. You can index into a <code>FlexiChain</code> with a single <code>Symbol</code>, and <em>as long as it is unambiguous</em>, it will return the corresponding data.</p><pre><code class="language-julia hljs">chain[:mu] # parameter</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">5</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├──────────────────────────┴────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">3:7</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└───────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>  <span class="sgr38_5" style="color:#0087d7">1</span>
 <span class="sgr38_5" style="color:#ff875f">3</span>    4.53071
 <span class="sgr38_5" style="color:#ff875f">4</span>    3.77985
 <span class="sgr38_5" style="color:#ff875f">5</span>    3.77985
 <span class="sgr38_5" style="color:#ff875f">6</span>    3.77985
 <span class="sgr38_5" style="color:#ff875f">7</span>    3.77985</code></pre><div class="admonition is-info" id="What-does-unambiguous-mean?-e1bb5f27dc692bac"><header class="admonition-header">What does unambiguous mean?<a class="admonition-anchor" href="#What-does-unambiguous-mean?-e1bb5f27dc692bac" title="Permalink"></a></header><div class="admonition-body"><p>In this case, because the only parameter <code>p</code> for which <code>Symbol(p) == :mu</code> is <code>@varname(mu)</code>, we can safely identify <code>@varname(mu)</code> as the parameter that we want.</p></div></div><div class="admonition is-info" id="No-sub-varnames-c069dc46d0969a97"><header class="admonition-header">No sub-varnames<a class="admonition-anchor" href="#No-sub-varnames-c069dc46d0969a97" title="Permalink"></a></header><div class="admonition-body"><p>You cannot use <code>chain[Symbol(&quot;theta[1]&quot;)]</code> as a replacement for <code>chain[@varname(theta[1])]</code>.</p></div></div><p>Likewise, we can omit wrapping <code>:lp</code> in <code>Extra(...)</code>:</p><pre><code class="language-julia hljs">chain[:lp] # other key</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">5</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├──────────────────────────┴────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">3:7</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└───────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>    <span class="sgr38_5" style="color:#0087d7">1</span>
 <span class="sgr38_5" style="color:#ff875f">3</span>    -51.2429
 <span class="sgr38_5" style="color:#ff875f">4</span>    -49.2218
 <span class="sgr38_5" style="color:#ff875f">5</span>    -49.2218
 <span class="sgr38_5" style="color:#ff875f">6</span>    -49.2218
 <span class="sgr38_5" style="color:#ff875f">7</span>    -49.2218</code></pre><p>If there is any ambiguity present (for example if there is also a parameter named <code>@varname(lp)</code>), FlexiChains will throw an error.</p><h2 id="Splitting-VarNames-up"><a class="docs-heading-anchor" href="#Splitting-VarNames-up">Splitting VarNames up</a><a id="Splitting-VarNames-up-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-VarNames-up" title="Permalink"></a></h2><p>The way that FlexiChains keeps vector-valued parameters together can make it more difficult to perform subsequent analyses, such as summarising or plotting. Therefore, to &#39;break up&#39; parameters into their constituent sub-<code>VarName</code>s, you can use <code>FlexiChains.split_varnames</code>:</p><pre><code class="language-julia hljs">split_varnames(chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain | 5 iterations (<span class="sgr38_5" style="color:#ff875f">3:7</span>) | 1 chain (<span class="sgr38_5" style="color:#0087d7">1:1</span>)</span>
<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>theta[1], mu, theta[8], tau, theta[2], theta[5], theta[4], theta[3], theta[7], theta[6]
<span class="sgr1">Extra keys       </span>:acceptance_rate, :loglikelihood, :nom_step_size, :max_hamiltonian_energy_error, :lp, :is_accept, :step_size, :tree_depth, :numerical_error, :log_density, :hamiltonian_energy_error, :hamiltonian_energy, :logprior, :n_steps
</code></pre><p>Do note that this is a lossy conversion. There is no way to un-split the chain! Furthermore, while functions like <code>predict</code> will still work with a split chain, there will be substantial performance regressions. It is therefore strongly recommended that you only split a chain up only when necessary, and never earlier than that.</p><h2 id="Summary-statistics"><a class="docs-heading-anchor" href="#Summary-statistics">Summary statistics</a><a id="Summary-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-statistics" title="Permalink"></a></h2><h3 id="Overall-summaries"><a class="docs-heading-anchor" href="#Overall-summaries">Overall summaries</a><a id="Overall-summaries-1"></a><a class="docs-heading-anchor-permalink" href="#Overall-summaries" title="Permalink"></a></h3><p>For a very quick summary of the chain, you can use <code>FlexiChains.summarize</code>:</p><pre><code class="language-julia hljs">using FlexiChains: FlexiChains

FlexiChains.summarize(chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiSummary | 6 statistics (<span class="sgr38_5" style="color:#ff875f">mean, std, mcse, ess_bulk, ess_tail, rhat</span>)</span>

<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>mu, tau, theta
<span class="sgr1">Extra keys       </span>:acceptance_rate, :loglikelihood, :nom_step_size, :max_hamiltonian_energy_error, :lp, :is_accept, :step_size, :tree_depth, :numerical_error, :log_density, :hamiltonian_energy_error, :hamiltonian_energy, :logprior, :n_steps
</code></pre><div class="admonition is-info" id="Name-conflict-2a8e9e2550e789ae"><header class="admonition-header">Name conflict<a class="admonition-anchor" href="#Name-conflict-2a8e9e2550e789ae" title="Permalink"></a></header><div class="admonition-body"><p>Right now, both MCMCChains and FlexiChains export their own versions of <code>summarize</code>. You may therefore have to prefix the function with the package name. This will hopefully be fixed in the near future, by declaring a single <code>summarize</code> function in AbstractMCMC and having both packages extend that.</p></div></div><h3 id="Individual-summaries"><a class="docs-heading-anchor" href="#Individual-summaries">Individual summaries</a><a id="Individual-summaries-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-summaries" title="Permalink"></a></h3><p>You can obtain, for example, the mean of each key in the chain using <code>Statistics.mean</code>. This returns a <code>FlexiSummary</code> object:</p><pre><code class="language-julia hljs">using Statistics: mean

mn = mean(chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiSummary</span>

<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>mu, tau, theta
<span class="sgr1">Extra keys       </span>:acceptance_rate, :loglikelihood, :nom_step_size, :max_hamiltonian_energy_error, :lp, :is_accept, :step_size, :tree_depth, :numerical_error, :log_density, :hamiltonian_energy_error, :hamiltonian_energy, :logprior, :n_steps
</code></pre><p>You can index into a <code>FlexiSummary</code> in exactly the same ways as a <code>FlexiChain</code>.</p><pre><code class="language-julia hljs">mn[@varname(mu)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.930025741473125</code></pre><p>Out of the box, FlexiChains provides:</p><ul><li><code>Statistics.mean</code></li><li><code>Statistics.median</code></li><li><code>Statistics.std</code></li><li><code>Statistics.var</code></li><li><code>Statistics.quantile</code></li><li><code>Base.minimum</code></li><li><code>Base.maximum</code></li><li><code>Base.sum</code></li><li><code>Base.prod</code></li><li><code>MCMCDiagnosticTools.ess</code></li><li><code>MCMCDiagnosticTools.rhat</code></li><li><code>MCMCDiagnosticTools.mcse</code></li></ul><p>These functions can all be applied to a <code>FlexiChain</code> with their usual signatures (for example, <code>quantile</code> will require a second argument). Keyword arguments of the original functions are also supported, for example <code>ess(chain; kind=:tail)</code> returns the tail ESS.</p><div class="admonition is-info" id="Other-summary-functions-b92385dda18d2f28"><header class="admonition-header">Other summary functions<a class="admonition-anchor" href="#Other-summary-functions-b92385dda18d2f28" title="Permalink"></a></header><div class="admonition-body"><p>If you want to apply a summary function that isn&#39;t listed above, you can manually use <a href="../details/#FlexiChains.collapse"><code>FlexiChains.collapse</code></a>. If it is something that is worth appearing in FlexiChains proper, please do open an issue!</p></div></div><h3 id="Collapsed-dimensions"><a class="docs-heading-anchor" href="#Collapsed-dimensions">Collapsed dimensions</a><a id="Collapsed-dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Collapsed-dimensions" title="Permalink"></a></h3><p>By default, applying summary functions will collapse the data in both the iteration and chain dimensions (the latter is only relevant if multiple chains are present).</p><p>To only collapse over one dimension you can use</p><pre><code class="language-julia hljs">mean(chain; dims=:iter)[@varname(mu)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">1-element </span>DimArray{Float64, 1}<span class="sgr90"> ┐</span>
<span class="sgr90">├────────────────────────────────┴───────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└────────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">1</span>  3.93003</code></pre><p>or <code>dims=:chain</code> (although that is probably less useful).</p><h2 id="Saving-and-resuming-MCMC-sampling-progress"><a class="docs-heading-anchor" href="#Saving-and-resuming-MCMC-sampling-progress">Saving and resuming MCMC sampling progress</a><a id="Saving-and-resuming-MCMC-sampling-progress-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-resuming-MCMC-sampling-progress" title="Permalink"></a></h2><p>If you want to sample a fewer number of iterations first and then resume it later, you can use the following:</p><pre><code class="language-julia hljs">chn1 = sample(model, NUTS(), 10; chain_type=VNChain, save_state=true)
chn2 = sample(model, NUTS(), 10; chain_type=VNChain, resume_from=chn1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain | 10 iterations (<span class="sgr38_5" style="color:#ff875f">1:10</span>) | 1 chain (<span class="sgr38_5" style="color:#0087d7">1:1</span>)</span>
<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>mu, tau, theta
<span class="sgr1">Extra keys       </span>:acceptance_rate, :loglikelihood, :nom_step_size, :max_hamiltonian_energy_error, :lp, :is_accept, :step_size, :tree_depth, :numerical_error, :log_density, :hamiltonian_energy_error, :hamiltonian_energy, :logprior, :n_steps
</code></pre><p>The chains can be combined using <code>vcat</code>:</p><pre><code class="language-julia hljs">chn = vcat(chn1, chn2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain | 20 iterations (<span class="sgr38_5" style="color:#ff875f">[6 … 10]</span>) | 1 chain (<span class="sgr38_5" style="color:#0087d7">1:1</span>)</span>
<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>mu, tau, theta
<span class="sgr1">Extra keys       </span>:acceptance_rate, :loglikelihood, :nom_step_size, :max_hamiltonian_energy_error, :lp, :is_accept, :step_size, :tree_depth, :numerical_error, :log_density, :hamiltonian_energy_error, :hamiltonian_energy, :logprior, :n_steps
</code></pre><div class="admonition is-info" id="Multiple-chain-sampling-5ffe3f0d6f8a9c0a"><header class="admonition-header">Multiple-chain sampling<a class="admonition-anchor" href="#Multiple-chain-sampling-5ffe3f0d6f8a9c0a" title="Permalink"></a></header><div class="admonition-body"><p>In general, the <code>resume_from</code> argument only works automatically if both the original and resumed sampling use the same number of chains. That is, <code>chn1</code> and <code>chn2</code> must either both be invoked as <code>sample(model, spl, N)</code>, or both invoked as <code>sample(model, spl, MCMCThreads(), N, C)</code> with the same <code>C</code>.</p><p>If you need more flexibility than this, then the <code>initial_state</code> keyword argument is recommended instead. When performing <strong>single-chain sampling</strong> with <code>sample(model, spl, N; initial_state=state)</code>, <code>initial_state</code> should be either <code>nothing</code> (to start a new chain) or the state to resume from. For <strong>multiple-chain sampling</strong> with <code>sample(model, spl, MCMCThreads(), N, C)</code>, <code>initial_state</code> should be a vector of length <code>C</code>, where <code>initial_state[i]</code> is the state to resume the <code>i</code>-th chain from (or <code>nothing</code> to start a new chain).</p><p>To obtain the saved final state of a chain, you can use <a href="../details/#FlexiChains.last_sampler_state"><code>FlexiChains.last_sampler_state</code></a>. This always returns a vector of states with length equal to the number of chains. Note that this applies also if you only sampled a single chain, in which case the returned value is a vector of length 1: you will therefore have to use <code>only()</code> to extract the state itself.</p><p>The above applies equally to <code>MCMCSerial()</code> and <code>MCMCDistributed()</code>.</p></div></div><h2 id="Posterior-predictions-and-friends"><a class="docs-heading-anchor" href="#Posterior-predictions-and-friends">Posterior predictions and friends</a><a id="Posterior-predictions-and-friends-1"></a><a class="docs-heading-anchor-permalink" href="#Posterior-predictions-and-friends" title="Permalink"></a></h2><p>The functions <code>predict</code>, <code>returned</code>, <code>logjoint</code>, <code>loglikelihood</code>, and <code>logprior</code> all work &#39;as expected&#39; using FlexiChains with exactly the same signatures that you are used to. Please consult <a href="https://turinglang.org/Turing.jl/stable/api/#Predictions">the Turing.jl documentation</a> for more details.</p><pre><code class="language-julia hljs">returned(model, chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">5</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{@NamedTuple{mu::Float64, tau::Float64}, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├─────────────────────────────────────────────────────────┴ dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">3:7</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└────────────────────────────────────────────────────────────────┘</span>
 <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>  <span class="sgr38_5" style="color:#0087d7">1</span>
 <span class="sgr38_5" style="color:#ff875f">3</span>     (mu = 4.53071, tau = 2.02099)
 <span class="sgr38_5" style="color:#ff875f">4</span>     (mu = 3.77985, tau = 1.07691)
 <span class="sgr38_5" style="color:#ff875f">5</span>     (mu = 3.77985, tau = 1.07691)
 <span class="sgr38_5" style="color:#ff875f">6</span>     (mu = 3.77985, tau = 1.07691)
 <span class="sgr38_5" style="color:#ff875f">7</span>     (mu = 3.77985, tau = 1.07691)</code></pre><p>The <code>pointwise_logdensity</code> family of functions is not yet implemented.</p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Right now FlexiChains does not (yet) provide any functionality for plotting, although these are planned for the future.</p><p>In the meantime, you can convert a <code>FlexiChain</code> to an <code>MCMCChains.Chains</code> object using the <code>MCMCChains.Chains</code> constructor.</p><pre><code class="language-julia hljs">using MCMCChains
mcmc = MCMCChains.Chains(chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (5×24×1 Array{Float64, 3}):

Iterations        = [3, 4, 5, 6, 7]
Number of chains  = 1
Samples per chain = 5
parameters        = tau, theta[1], theta[2], theta[3], theta[4], theta[5], theta[6], theta[7], theta[8], mu
internals         = acceptance_rate, loglikelihood, nom_step_size, max_hamiltonian_energy_error, lp, is_accept, step_size, tree_depth, numerical_error, log_density, hamiltonian_energy_error, hamiltonian_energy, logprior, n_steps

Use `describe(chains)` for summary statistics and quantiles.
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../indexing/">Indexing in FlexiChains.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 5 October 2025 18:39">Sunday 5 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
