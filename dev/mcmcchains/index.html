<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Migrating from MCMCChains.jl · FlexiChains.jl</title><meta name="title" content="Migrating from MCMCChains.jl · FlexiChains.jl"/><meta property="og:title" content="Migrating from MCMCChains.jl · FlexiChains.jl"/><meta property="twitter:title" content="Migrating from MCMCChains.jl · FlexiChains.jl"/><meta name="description" content="Documentation for FlexiChains.jl."/><meta property="og:description" content="Documentation for FlexiChains.jl."/><meta property="twitter:description" content="Documentation for FlexiChains.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexiChains.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../data_structure/">Core data structure</a></li><li class="is-active"><a class="tocitem" href>Migrating from MCMCChains.jl</a><ul class="internal"><li><a class="tocitem" href="#The-fundamental-difference"><span>The fundamental difference</span></a></li><li><a class="tocitem" href="#Indexing-keys"><span>Indexing keys</span></a></li><li><a class="tocitem" href="#Accessing-vector-valued-parameters"><span>Accessing vector-valued parameters</span></a></li><li><a class="tocitem" href="#Accessing-parameters-with-even-more-special-types"><span>Accessing parameters with even more special types</span></a></li><li><a class="tocitem" href="#Accessing-individual-elements"><span>Accessing individual elements</span></a></li><li><a class="tocitem" href="#Accessing-&#39;generated-quantities&#39;-(using-:)"><span>Accessing &#39;generated quantities&#39; (using <code>:=</code>)</span></a></li><li><a class="tocitem" href="#Convergence-checks"><span>Convergence checks</span></a></li><li><a class="tocitem" href="#No-need-to-avoid-reserved-names"><span>No need to avoid reserved names</span></a></li><li><a class="tocitem" href="#For-DynamicPPL-developers"><span>For DynamicPPL developers</span></a></li><li><a class="tocitem" href="#Design-goals"><span>Design goals</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Migrating from MCMCChains.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Migrating from MCMCChains.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl/blob/main/docs/src/mcmcchains.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Migrating-from-MCMCChains.jl"><a class="docs-heading-anchor" href="#Migrating-from-MCMCChains.jl">Migrating from MCMCChains.jl</a><a id="Migrating-from-MCMCChains.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Migrating-from-MCMCChains.jl" title="Permalink"></a></h1><p>FlexiChains.jl has been designed from the ground up to address existing limitations of <a href="https://github.com/TuringLang/MCMCChains.jl">MCMCChains.jl</a>.</p><p>This page describes some key differences from MCMCChains.jl and how you can migrate your code to use FlexiChains.jl.</p><h2 id="The-fundamental-difference"><a class="docs-heading-anchor" href="#The-fundamental-difference">The fundamental difference</a><a id="The-fundamental-difference-1"></a><a class="docs-heading-anchor-permalink" href="#The-fundamental-difference" title="Permalink"></a></h2><p>Under the hood, MCMCChains.jl uses <a href="https://github.com/JuliaArrays/AxisArrays.jl/"><code>AxisArrays.AxisArray</code></a> as its data structure. Specifically, this allows it to store data in a compact 3-dimensional matrix, and index into the matrix using <code>Symbol</code>s.</p><p>The downside of this is that it enforces a key type of <code>Symbol</code> and a value type of <code>Tval&lt;:Real</code>. This means that, for example, if you have a model with vector-valued parameters (like <code>x</code> above), the vectors will be split up into their individual elements before being stored in the chain.</p><p>This is <em>the</em> core of how MCMCChains and FlexiChains differ, and all of the behaviour shown below stems from this.</p><p>To illustrate this, let&#39;s sample from a Turing model and store the results in both <code>MCMCChains.Chains</code> and <code>FlexiChains.FlexiChain</code>.</p><pre><code class="language-julia hljs">using Turing
using MCMCChains: MCMCChains
using FlexiChains: FlexiChains
using Random: Xoshiro
using PDMats: PDMats
using DynamicPPL: VarName

Turing.setprogress!(false)

@model function f(x)
    sigma ~ truncated(Normal(0, 1); lower = 0)
    chol ~ LKJCholesky(3, 1.0)
    corr := PDMats.PDMat(chol)
    mu ~ MvNormal(zeros(3), sigma^2 * I)
    x ~ MvNormal(mu, corr)
end

model = f(randn(Xoshiro(468), 3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DynamicPPL.Model{typeof(Main.f), (:x,), (), (), Tuple{Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}(Main.f, (x = [0.07200886749732076, -0.0740437565595174, 0.6327762377562545],), NamedTuple(), DynamicPPL.DefaultContext())</code></pre><p>The default chain type for Turing&#39;s <code>sample</code> is still <code>MCMCChains.Chains</code>; we just specify it here for clarity.</p><pre><code class="language-julia hljs">mcmc = sample(Xoshiro(468), model, NUTS(), 100; chain_type=MCMCChains.Chains)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (100×31×1 Array{Float64, 3}):

Iterations        = 51:1:150
Number of chains  = 1
Samples per chain = 100
Wall duration     = 9.93 seconds
Compute duration  = 9.93 seconds
parameters        = sigma, chol.L[1, 1], chol.L[2, 1], chol.L[3, 1], chol.L[2, 2], chol.L[3, 2], chol.L[3, 3], corr[1, 1], corr[2, 1], corr[3, 1], corr[1, 2], corr[2, 2], corr[3, 2], corr[1, 3], corr[2, 3], corr[3, 3], mu[1], mu[2], mu[3]
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Use `describe(chains)` for summary statistics and quantiles.
</code></pre><p>When using FlexiChains, you have to specify the key type of the chain. In this case, it is <code>VarName</code>.</p><pre><code class="language-julia hljs">flexi = sample(Xoshiro(468), model, NUTS(), 100; chain_type=FlexiChains.FlexiChain{VarName})</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain (100 iterations, 1 chain)</span>

<span class="sgr1">Parameter type   </span>AbstractPPL.VarName
<span class="sgr1">Parameters       </span>sigma, mu, chol, corr
<span class="sgr1">Other keys       </span>{:stats} is_accept, n_steps, step_size, max_hamiltonian_energy_error, acceptance_rate, tree_depth, lp, hamiltonian_energy_error, log_density, hamiltonian_energy, numerical_error, nom_step_size</code></pre><p>Here, we expect the following parameters to be present in the chain:</p><ul><li><code>sigma</code> is a scalar;</li><li><code>chol</code> is a Cholesky factor which contains a 3×3 lower triangular matrix;</li><li><code>corr</code> is a 3×3 correlation matrix, which is a positive-definite matrix;</li><li><code>mu</code> is a length-3 vector.</li></ul><p>Let&#39;s test first that both chains contain the same values for <code>sigma</code>. (Some fiddling is required because <code>mcmc[:sigma]</code> returns an AxisArray with a 100×1 matrix, while <code>flexi[:sigma]</code> returns a 100-element vector.)</p><pre><code class="language-julia hljs">vec(mcmc[:sigma].data) == flexi[@varname(sigma)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="Indexing-keys"><a class="docs-heading-anchor" href="#Indexing-keys">Indexing keys</a><a id="Indexing-keys-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-keys" title="Permalink"></a></h2><p>There is already one difference here: when indexing into MCMCChains you need to use a <code>Symbol</code> or <code>String</code>, whereas with FlexiChains you can use the original <code>VarName</code>.</p><p>If you think this is too verbose, fret not! FlexiChains also lets you use <code>Symbol</code>s (mainly for compatibility with MCMCChains):</p><pre><code class="language-julia hljs">flexi[:sigma] == flexi[@varname(sigma)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The rest of this page uses <code>VarName</code>s, but you can mentally replace them with <code>Symbol</code>s if you prefer.</p><h2 id="Accessing-vector-valued-parameters"><a class="docs-heading-anchor" href="#Accessing-vector-valued-parameters">Accessing vector-valued parameters</a><a id="Accessing-vector-valued-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-vector-valued-parameters" title="Permalink"></a></h2><p>Suppose you want to access the value of <code>mu</code> in the first iteration.</p><p>With FlexiChains, you can do this directly as:</p><pre><code class="language-julia hljs">flexi[:mu][1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -1.1392367041860152
  0.679248062218424
  1.2879578366876188</code></pre><p>With MCMCChains, because <code>mu</code> has been split up into its constituent elements, you need to do:</p><pre><code class="language-julia hljs">[mu[1] for mu in (mcmc[&quot;mu[1]&quot;], mcmc[&quot;mu[2]&quot;], mcmc[&quot;mu[3]&quot;])]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -1.1392367041860152
  0.679248062218424
  1.2879578366876188</code></pre><h2 id="Accessing-parameters-with-even-more-special-types"><a class="docs-heading-anchor" href="#Accessing-parameters-with-even-more-special-types">Accessing parameters with even more special types</a><a id="Accessing-parameters-with-even-more-special-types-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-parameters-with-even-more-special-types" title="Permalink"></a></h2><p>Now suppose you want to extract the sampled values of <code>chol</code> and <code>corr</code>, and check that</p><pre><code class="language-julia hljs"># This code block isn&#39;t executed because we haven&#39;t defined `chols` and `corrs`
for (chol, corr) in zip(chols, corrs)
    chol == cholesky(corr) || error(&quot;oops&quot;)
end</code></pre><p>The question is of course how one can obtain the vectors <code>chols</code> and <code>corrs</code> from the chain. With FlexiChains, you can do this directly as:</p><pre><code class="language-julia hljs">chols = flexi[:chol]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{LinearAlgebra.Cholesky{Float64, Matrix{Float64}}}:
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.5860776940515555 0.8102548590012967 0.0; -0.7469291438341532 0.15050609179837007 0.6476455592550292], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.3411068156431396 0.940024542403972 0.0; 0.8997625348100323 -0.025494180556458846 0.43563451161493155], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.22865876757583625 0.9735066348056902 0.0; 0.9368341455672167 0.08891778988639876 0.33828303288971096], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.11731432618794155 0.9930948337752388 0.0; 0.7367856690251833 0.41998670491231144 0.5298660638463386], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.8661421856230287 0.4997976733480889 0.0; -0.0814708235981316 0.8028539026462284 0.5905828611701853], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.7915956870019575 0.6110452260838791 0.0; -0.4617210562494003 0.25915086768888 0.8483245216260334], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.19479555326274142 0.9808438675085155 0.0; -0.8214941287230245 0.019381296090810702 0.5698874992798484], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.46584775707534687 0.8848648864249663 0.0; 0.4452851887734646 0.5379867978242288 0.7157452801282116], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.6641297252066818 0.7476173540634924 0.0; -0.7896252357074331 0.41992770789720474 0.4473842948452487], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.3833012690898083 0.9236233740622539 0.0; -0.1266508556582105 0.575960429247364 0.8076070484475945], &#39;L&#39;, 0)
 ⋮
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.08639648242107803 0.9962608332285597 0.0; 0.32932883220750675 0.3275843875970103 0.8855681731405728], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.12649132715943237 0.9919677132615988 0.0; 0.07881987098628546 0.37638731690609867 0.9231034696121196], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.5978186784879044 0.8016313539595215 0.0; -0.22803376785971033 -0.8806945703064399 0.4151839044910807], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.5584581929395054 0.8295326676742407 0.0; 0.1472576835839161 0.8811646623981682 0.44929279135795336], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.6584010867072703 0.7526672631533045 0.0; 0.18877279037426642 0.9428844201329261 0.2744700418714382], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.1736134858902289 0.9848138694784123 0.0; 0.050340253152015846 0.9515628266439226 0.3033052024974496], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.27249428366919026 0.9621574015552834 0.0; -0.02055846044871073 0.957759444187605 0.2868347900332677], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.008094811071691249 0.9999672364801327 0.0; 0.07438605716267996 0.9395788946362122 0.3341529818121992], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.12676552591919812 0.9919327101363424 0.0; 0.3118962305971891 -0.858358205435006 0.4073597089817071], &#39;L&#39;, 0)</code></pre><p>and likewise for <code>:corr</code>.</p><p>On the other hand, with MCMCChains, reconstructing the <code>chol</code>s becomes a non-trivial task:</p><pre><code class="language-julia hljs">using LinearAlgebra

chols = map(1:length(mcmc)) do i
    c = Cholesky(LowerTriangular(zeros(3, 3)))
    for j in 1:3
        for k in 1:j
            c.L[j, k] = mcmc[&quot;chol.L[$j, $k]&quot;][i]
        end
    end
    c
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{LinearAlgebra.Cholesky{Float64, Matrix{Float64}}}:
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.5860776940515555 0.8102548590012967 0.0; -0.7469291438341532 0.15050609179837007 0.6476455592550292], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.3411068156431396 0.940024542403972 0.0; 0.8997625348100323 -0.025494180556458846 0.43563451161493155], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.22865876757583625 0.9735066348056902 0.0; 0.9368341455672167 0.08891778988639876 0.33828303288971096], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.11731432618794155 0.9930948337752388 0.0; 0.7367856690251833 0.41998670491231144 0.5298660638463386], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.8661421856230287 0.4997976733480889 0.0; -0.0814708235981316 0.8028539026462284 0.5905828611701853], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.7915956870019575 0.6110452260838791 0.0; -0.4617210562494003 0.25915086768888 0.8483245216260334], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.19479555326274142 0.9808438675085155 0.0; -0.8214941287230245 0.019381296090810702 0.5698874992798484], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.46584775707534687 0.8848648864249663 0.0; 0.4452851887734646 0.5379867978242288 0.7157452801282116], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.6641297252066818 0.7476173540634924 0.0; -0.7896252357074331 0.41992770789720474 0.4473842948452487], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.3833012690898083 0.9236233740622539 0.0; -0.1266508556582105 0.575960429247364 0.8076070484475945], &#39;L&#39;, 0)
 ⋮
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.08639648242107803 0.9962608332285597 0.0; 0.32932883220750675 0.3275843875970103 0.8855681731405728], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.12649132715943237 0.9919677132615988 0.0; 0.07881987098628546 0.37638731690609867 0.9231034696121196], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.5978186784879044 0.8016313539595215 0.0; -0.22803376785971033 -0.8806945703064399 0.4151839044910807], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.5584581929395054 0.8295326676742407 0.0; 0.1472576835839161 0.8811646623981682 0.44929279135795336], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.6584010867072703 0.7526672631533045 0.0; 0.18877279037426642 0.9428844201329261 0.2744700418714382], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.1736134858902289 0.9848138694784123 0.0; 0.050340253152015846 0.9515628266439226 0.3033052024974496], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.27249428366919026 0.9621574015552834 0.0; -0.02055846044871073 0.957759444187605 0.2868347900332677], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.008094811071691249 0.9999672364801327 0.0; 0.07438605716267996 0.9395788946362122 0.3341529818121992], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.12676552591919812 0.9919327101363424 0.0; 0.3118962305971891 -0.858358205435006 0.4073597089817071], &#39;L&#39;, 0)</code></pre><p>and similarly for the <code>corr</code>s (which we won&#39;t demonstrate here).</p><p>In general the point is that in any situation where you want to work with the actual types of the parameters, rather than their individual elements, FlexiChains makes this much easier.</p><h2 id="Accessing-individual-elements"><a class="docs-heading-anchor" href="#Accessing-individual-elements">Accessing individual elements</a><a id="Accessing-individual-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-individual-elements" title="Permalink"></a></h2><p>Sometimes maybe you really want to access just <code>mu[2]</code> without any reference to <code>mu[1]</code> or <code>mu[3]</code>.</p><p>Because FlexiChains stores the entire vector <code>mu</code>, you will then need to index into it:</p><pre><code class="language-julia hljs">[mu_sample[2] for mu_sample in flexi[:mu]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{Float64}:
  0.679248062218424
  0.9471307645777602
  0.7709348804476637
  0.024144352905626942
  0.8070225657169596
  0.8147664232388916
  0.7726906681760006
  0.2247067429263416
  0.891747605022233
 -0.5507704884008409
  ⋮
 -0.025966165532193705
 -0.23548932469427847
 -0.0684792770976693
 -0.06840517210318812
 -0.1883771420800377
  0.05483611664378653
 -0.03331237071103403
 -0.005765575484848871
  0.5177285480208339</code></pre><p>In MCMCChains you can of course do</p><pre><code class="language-julia hljs">mcmc[&quot;mu[2]&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional AxisArray{Float64,2,...} with axes:
    :iter, 51:1:150
    :chain, 1:1
And data, a 100×1 Matrix{Float64}:
  0.679248062218424
  0.9471307645777602
  0.7709348804476637
  0.024144352905626942
  0.8070225657169596
  0.8147664232388916
  0.7726906681760006
  0.2247067429263416
  0.891747605022233
 -0.5507704884008409
  ⋮
 -0.025966165532193705
 -0.23548932469427847
 -0.0684792770976693
 -0.06840517210318812
 -0.1883771420800377
  0.05483611664378653
 -0.03331237071103403
 -0.005765575484848871
  0.5177285480208339</code></pre><p>Note, though, that MCMCChains requires you to pass a <em>string</em> <code>&quot;2&quot;</code> to get the second variable. Of course, if you have an integer <code>2</code> this is quite easily done with interpolation, but I would argue from a readability perspective it&#39;s much clearer to index with an integer <code>2</code> rather than a string.</p><h2 id="Accessing-&#39;generated-quantities&#39;-(using-:)"><a class="docs-heading-anchor" href="#Accessing-&#39;generated-quantities&#39;-(using-:)">Accessing &#39;generated quantities&#39; (using <code>:=</code>)</a><a id="Accessing-&#39;generated-quantities&#39;-(using-:)-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-&#39;generated-quantities&#39;-(using-:)" title="Permalink"></a></h2><p>TODO</p><h2 id="Convergence-checks"><a class="docs-heading-anchor" href="#Convergence-checks">Convergence checks</a><a id="Convergence-checks-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-checks" title="Permalink"></a></h2><p>&#39;Ah,&#39; you say, &#39;but when I plot my chains I want to see the individual elements of <code>mu</code> as separate lines!&#39;</p><h2 id="No-need-to-avoid-reserved-names"><a class="docs-heading-anchor" href="#No-need-to-avoid-reserved-names">No need to avoid reserved names</a><a id="No-need-to-avoid-reserved-names-1"></a><a class="docs-heading-anchor-permalink" href="#No-need-to-avoid-reserved-names" title="Permalink"></a></h2><p>When sampling from a Turing model with MCMCChains as the output format, some metadata (non-parameter keys) such as <code>lp</code> are added to the chain. If your model contains a variable called <code>lp</code>, sampling will still work but <a href="https://github.com/TuringLang/MCMCChains.jl/issues/469">odd things will happen</a>. For example, it will look as if your chain does not actually have any variables:</p><pre><code class="language-julia hljs">@model function lp_model()
    lp ~ Normal()
end

chain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=MCMCChains.Chains)
describe(chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Info: Found initial step size
└   ϵ = 3.2
Chains MCMC chain (100×13×1 Array{Float64, 3}):

Iterations        = 51:1:150
Number of chains  = 1
Samples per chain = 100
Wall duration     = 2.23 seconds
Compute duration  = 2.23 seconds
parameters        =
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters   mean   std      mcse   ess_bulk   ess_tail      rhat   ess_per_sec
      Symbol    Any   Any   Float64    Float64    Float64   Float64       Float64


Quantiles
  parameters   2.5%   25.0%   50.0%   75.0%   97.5%
      Symbol    Any     Any     Any     Any     Any</code></pre><p>When you index <code>chain[:lp]</code>, how do you know whether it refers to the <code>lp</code> variable in your model or the <code>lp</code> metadata key?</p><pre><code class="language-julia hljs">any(chain[:lp] .&gt; 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Well, since there are some positive values, it has to be the parameter, because the metadata <code>lp = logpdf(Normal(), value_of_lp_parameter)</code> is always negative. But you didn&#39;t know that when you tried to index into it, you had to reverse engineer it.</p><p>HMC samplers further include extra metadata such as <code>hamiltonian_energy</code>, and in general <strong>any sampler</strong> can include any kind of extra metadata it wants. As a user, you have no way of knowing what these names are, and you have to avoid using them in your model, which is quite unfair.</p><p>FlexiChains circumvents this entirely since it stores these separately as <code>Parameter(@varname(lp))</code> and <code>OtherKey(:stats, :lp)</code>.</p><pre><code class="language-julia hljs">chain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=FlexiChains.FlexiChain{VarName})</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain (100 iterations, 1 chain)</span>

<span class="sgr1">Parameter type   </span>AbstractPPL.VarName
<span class="sgr1">Parameters       </span>lp
<span class="sgr1">Other keys       </span>{:stats} is_accept, n_steps, step_size, max_hamiltonian_energy_error, lp, acceptance_rate, tree_depth, hamiltonian_energy_error, log_density, hamiltonian_energy, numerical_error, nom_step_size</code></pre><p>You will of course run into ambiguities if you simply attempt to index the chain with <code>[:lp]</code>, because both the <code>Parameter(@varname(lp))</code> and the <code>OtherKey(:stats, :lp)</code> exist.</p><pre><code class="language-julia hljs">chain[:lp]
# This code block isn&#39;t run because it would throw the following error:
# ArgumentError: multiple keys correspond to symbol :lp.</code></pre><p>but you can still access the value using the original value of the <code>Parameter</code>:</p><pre><code class="language-julia hljs">chain[@varname(lp)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{Float64}:
 -0.3632048365611648
  0.3235758433568307
 -0.40542415499511864
  0.38587063882302897
  0.8273717806336723
  0.8273717806336723
 -0.11130248031195134
 -0.15083597686256311
 -0.10748027429364553
 -0.6540088811985476
  ⋮
 -0.16204392826799885
 -0.6236478963439832
  0.7384144864536033
 -0.163175739347587
 -0.163175739347587
 -0.7563880621931498
 -1.0076379768444197
 -1.0076379768444197
 -0.3139843357632176</code></pre><p>TODO pretty-printing / summary stats</p><h2 id="For-DynamicPPL-developers"><a class="docs-heading-anchor" href="#For-DynamicPPL-developers">For DynamicPPL developers</a><a id="For-DynamicPPL-developers-1"></a><a class="docs-heading-anchor-permalink" href="#For-DynamicPPL-developers" title="Permalink"></a></h2><p>Blah</p><h2 id="Design-goals"><a class="docs-heading-anchor" href="#Design-goals">Design goals</a><a id="Design-goals-1"></a><a class="docs-heading-anchor-permalink" href="#Design-goals" title="Permalink"></a></h2><p>My main design goals for FlexiChains.jl were twofold:</p><ol><li><p>To provide a rich data structure that can more faithfully represent the outputs from sampling with Turing.jl.</p><p>The restriction of MCMCChains.jl to <code>Symbol</code> keys and <code>Real</code> values means that round-trip conversion is a lossy operation. Consider, e.g., the <code>predict(::Model, ::MCMCChains.Chains)</code> function, which is used to sample from the posterior predictive distribution. This requires one to extract the values from the chain and insert them back into the model (or technically the <code>VarInfo</code>).</p><p>However, in general one cannot reconstruct a vector <code>x</code> from its constituent elements <code>x[1]</code>, <code>x[2]</code>, ... as we do not know the appropriate length of the vector! The current implementation of this function in DynamicPPL.jl thus has to, essentially, insert all the elements it can find and hope for the best.</p><p>Essentially, MCMCChains&#39; data structure forces packages like Turing.jl and DynamicPPL.jl to include workarounds to deal with the limitations of the chains package.</p></li><li><p>To create a robust and readable codebase.</p><p>Much Julia code is written with the intention of efficiency or versatility, often sacrificing clarity in the process. This is usually acceptable when creating simple scripts. However, I believe that library code should be held to a (much) higher standard.</p><p>In particular, I consider the overuse of multiple dispatch to be a major source of confusion in Julia code. Types cannot be fully inferred at compile time (and even when they can, it requires packages such as JET.jl, which do not (yet) have convenient language server integrations). This means that when reading code, one cannot easily determine which method is being called.</p><p>A prime example is the <code>Chains</code> constructor in MCMCChains.jl. <code>methods(Chains)</code> returns 11 methods, and each time you see a call to <code>Chains(...)</code> you need to figure out which of these 11 it is. In writing FlexiChains I have made a conscious choice to create only two inner constructors for <code>FlexiChain</code>.</p></li></ol><p>In particular, notice that <em>performance</em> is not one of my considerations. In my opinion, performance is only a minor concern for FlexiChains.jl, because the main bottleneck in Bayesian inference is the sampling, not how fast one can construct or index into a chain. I have not performed any benchmarks but I would expect that most operations on <code>MCMCChains.Chains</code> will be faster than on <code>FlexiChains.FlexiChain</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structure/">« Core data structure</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 30 July 2025 14:13">Wednesday 30 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
