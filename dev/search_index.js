var documenterSearchIndex = {"docs":
[{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"FlexiChains.jl provides an information-rich data structure for Markov chains. It is intended as a drop-in (but better) replacement for MCMCChains.jl.","category":"page"},{"location":"#Basic-usage","page":"Overview","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To obtain a FlexiChain from Turing.jl, you will need to pass the chain_type keyword argument to sample.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Turing\nusing FlexiChains: VNChain\n\n@model f() = x ~ Normal()\nchain = sample(f(), NUTS(), 1000; chain_type=VNChain)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Right now FlexiChains only provides a data structure. It does not yet provide any functionality for calculating statistics or plotting.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If you want that, you can convert a FlexiChain to an MCMCChains.Chains object using the MCMCChains.Chains constructor.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using MCMCChains\nmcmc = MCMCChains.Chains(chain)","category":"page"},{"location":"#What-is-exported?","page":"Overview","title":"What is exported?","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"FlexiChains.jl only exports three things, all for convenience when using this with Turing.jl.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"VNChains, an alias for FlexiChain{VarName}\nThe VarName type and @varname macro","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For semantic versioning purposes, a number of other types and functions are marked as public. However, they are not exported: you will have to explicitly import them.","category":"page"},{"location":"#The-FlexiChain-type","page":"Overview","title":"The FlexiChain type","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Fundamentally, a FlexiChain{T} is a mapping of keys to values.","category":"page"},{"location":"#FlexiChains.FlexiChain","page":"Overview","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey,NIter,NChains,Sections}\n\nNote that the ordering of keys within a FlexiChain is an implementation detail and is not guaranteed.\n\nTODO: Document further.\n\nFields\n\n_data::Dict{<:FlexiChainKey{TKey}, <:FlexiChains.SizedMatrix{NIter, NChains}} where {TKey, NIter, NChains}: Internal data. Do not access this directly unless you know what you are doing! You should use the interface methods defined instead.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Overview","title":"Overview","text":"The values must be matrices or vectors that all have the same size. The element type is unconstrained.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The keys must be one of two types:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Parameter(::T): a parameter of the Markov chain itself\nOtherKey(::Symbol, ::Any): a key that is not a parameter, such as metadata. The Symbol argument identifies a section which the key belongs to, thus allowing for multiple keys to be grouped together in meaningful ways.","category":"page"},{"location":"#FlexiChains.Parameter","page":"Overview","title":"FlexiChains.Parameter","text":"Parameter(name)\n\nA named parameter in a FlexiChain. The name can be of any type, but all parameters in a FlexiChain must have the same type for their names.\n\nSpecifically, if you have a FlexiChain{TKey}, then all parameters must be of type Parameter{TKey}.\n\n\n\n\n\n","category":"type"},{"location":"#FlexiChains.OtherKey","page":"Overview","title":"FlexiChains.OtherKey","text":"OtherKey(section_name::Symbol, key_name::Any)\n\nA key in a FlexiChain that is not a parameter. FlexiChain allows for such informations to be grouped into sections, which are identified by Symbols. The name of the key itself can be of any type and is not constrained by the type of the FlexiChain.\n\n\n\n\n\n","category":"type"},{"location":"#FlexiChains.FlexiChainKey","page":"Overview","title":"FlexiChains.FlexiChainKey","text":"FlexiChainKey{T}\n\nEither a Parameter{T}, or an OtherKey.\n\nAll keys in a FlexiChain{T} must be a FlexiChainKey{T}.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Overview","title":"Overview","text":"Bearing this in mind, there are two ways to construct a FlexiChain. One is to pass an array of dictionaries (i.e., one dictionary per iteration); the other is to pass a dictionary of arrays (i.e., the values for each key are already grouped together).","category":"page"},{"location":"#FlexiChains.FlexiChain-Union{Tuple{Any}, Tuple{TKey}} where TKey","page":"Overview","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey}(\n    array_of_dicts::AbstractArray{<:AbstractDict,N}\n) where {TKey,N}\n\nConstruct a FlexiChain from a vector or matrix of dictionaries. Each dictionary corresponds to one iteration.\n\nEach dictionary must be a mapping from a FlexiChainKey{TKey} (i.e., either a Parameter{TKey} or an OtherKey) to its value at that iteration.\n\nIf array_of_dicts is a vector (i.e., N = 1), then niter is the length of the vector and nchains is 1. If array_of_dicts is a matrix (i.e., N = 2), then (niter, nchains) = size(dicts).\n\nOther values of N will error.\n\nExample usage\n\nd = fill(\n    Dict(Parameter(:x) => rand(), OtherKey(:section, \"y\") => rand()), 200, 3\n)\nchn = FlexiChain{Symbol}(d)\n\n\n\n\n\nFlexiChain{TKey}(\n    dict_of_arrays::AbstractDict{<:Any,<:AbstractArray{<:Any,N}}\n) where {TKey,N}\n\nConstruct a FlexiChain from a dictionary of arrays.\n\nEach key in the dictionary must subtype FlexiChainKey{TKey} (i.e., it is either a Parameter{TKey} or an OtherKey). The values of the dictionary must all be of the same size.\n\nIf the values are vectors (i.e., N = 1), then niters will be the length of the vector, and nchains will be 1. If the values are matrices (i.e., N = 2), then (niter, nchains) = size(array).\n\nOther values of N will error.\n\nExample usage\n\nd = Dict(\n    Parameter(:x) => rand(200, 3),\n    OtherKey(:section, \"y\") => rand(200, 3),\n)\nchn = FlexiChain{Symbol}(d)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Overview","title":"Overview","text":"Note that, although the dictionaries themselves may have loose types, the key type of the FlexiChain must be specified (and the keys of the dictionaries will be checked against this).","category":"page"},{"location":"#Accessing-values","page":"Overview","title":"Accessing values","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Indexing into a FlexiChain can be done in several ways.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The most correct way is to directly use Parameters or OtherKeys:","category":"page"},{"location":"#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChain{TKey}, FlexiChainKey{TKey}}} where TKey","page":"Overview","title":"Base.getindex","text":"Base.getindex(chain::FlexiChain{TKey}, key::FlexiChainKey{TKey}) where {TKey}\n\nUnambiguously access the data corresponding to the given key in the chain.\n\nYou will need to use this method if you have multiple keys that convert to the same Symbol, such as a Parameter(:x) and an OtherKey(:some_section, :x).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Overview","title":"Overview","text":"This can be slightly verbose, so the following two methods are provided as a 'quick' way of accessing parameters and other keys respectively:","category":"page"},{"location":"#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChain{TKey}, TKey}} where TKey","page":"Overview","title":"Base.getindex","text":"Base.getindex(chain::FlexiChain{TKey}, parameter_name::TKey) where {TKey}\n\nConvenience method for retrieving parameters. Equal to chain[Parameter(parameter_name)].\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChain{TKey}, Symbol, Any}} where TKey","page":"Overview","title":"Base.getindex","text":"Base.getindex(chain::FlexiChain{TKey}, section_name::Symbol, key_name::Any) where {TKey}\n\nConvenience method for retrieving non-parameter keys. Equal to chain[OtherKey(section_name, key_name)].\n\n\n\n\n\n","category":"method"},{"location":"","page":"Overview","title":"Overview","text":"Finally, to preserve some semblance of backwards compatibility with MCMCChains.jl, FlexiChains can also be indexed by Symbols. It does so by looking for a unique Parameter or OtherKey which can be converted to that Symbol.","category":"page"},{"location":"#Base.getindex-Tuple{FlexiChain, Symbol}","page":"Overview","title":"Base.getindex","text":"Base.getindex(chain::FlexiChain{TKey}, sym_key::Symbol) where {TKey}\n\nThe most convenient method to index into a FlexiChain is using Symbol.\n\nHowever, recall that the keys in a FlexiChain{TKey} are not stored as Symbols but rather as either Parameter{TKey} or OtherKey. Thus, to access the data corresponding to a Symbol, we first convert all key names (both parameters and other keys) to Symbols, and then check if there is a unique match.\n\nIf there is, then we can return that data. If there are no valid matches, then we throw a KeyError.\n\nIf there are multiple matches: for example, if you have a Parameter(:x) and also an OtherKey(:some_section, :x), then this method will also throw a KeyError. You will then have to index into it using the actual key.\n\n\n\n\n\n","category":"method"},{"location":"mcmcchains/#Migrating-from-MCMCChains.jl","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"FlexiChains.jl has been designed from the ground up to address existing limitations of MCMCChains.jl.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"This page describes some key differences from MCMCChains.jl and how you can migrate your code to use FlexiChains.jl.","category":"page"},{"location":"mcmcchains/#The-fundamental-difference","page":"Migrating from MCMCChains.jl","title":"The fundamental difference","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Under the hood, MCMCChains.jl uses AxisArrays.AxisArray as its data structure. Specifically, this allows it to store data in a compact 3-dimensional matrix, and index into the matrix using Symbols.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"The downside of this is that it enforces a key type of Symbol and a value type of Tval<:Real. This means that, for example, if you have a model with vector-valued parameters (like x above), the vectors will be split up into their individual elements before being stored in the chain.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"This is the core of how MCMCChains and FlexiChains differ, and all of the behaviour shown below stems from this.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"To illustrate this, let's sample from a Turing model and store the results in both MCMCChains.Chains and FlexiChains.VNChain.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"using Turing\nusing MCMCChains: Chains\nusing FlexiChains: VNChain, VarName, @varname\nusing Random: Xoshiro\nusing PDMats: PDMats\n\nTuring.setprogress!(false)\n\n@model function f(x)\n    sigma ~ truncated(Normal(0, 1); lower = 0)\n    chol ~ LKJCholesky(3, 1.0)\n    corr := PDMats.PDMat(chol)\n    mu ~ MvNormal(zeros(3), sigma^2 * I)\n    x ~ MvNormal(mu, corr)\nend\n\nmodel = f(randn(Xoshiro(468), 3))","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"The default chain type for Turing's sample is still MCMCChains.Chains; we just specify it here for clarity.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"mcmc = sample(Xoshiro(468), model, NUTS(), 100; chain_type=Chains)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Because FlexiChains does not enforce a key type, you are technically required to specify the key type of the chain as a type parameter. You could, for example, write FlexiChains.FlexiChain{DynamicPPL.VarName}. But since this is really the main use case of FlexiChains, we provide a convenient alias for this, FlexiChains.VNChain.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"flexi = sample(Xoshiro(468), model, NUTS(), 100; chain_type=VNChain)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Here, we expect the following parameters to be present in the chain:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"sigma is a scalar;\nchol is a Cholesky factor which contains a 3×3 lower triangular matrix;\ncorr is a 3×3 correlation matrix, which is a positive-definite matrix;\nmu is a length-3 vector.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Let's test first that both chains contain the same values for sigma. (Some fiddling is required because mcmc[:sigma] returns an AxisArray with a 100×1 matrix, while flexi[:sigma] returns a 100-element vector.)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"vec(mcmc[:sigma].data) == flexi[@varname(sigma)]","category":"page"},{"location":"mcmcchains/#Indexing-keys","page":"Migrating from MCMCChains.jl","title":"Indexing keys","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"There is already one difference here: when indexing into MCMCChains you need to use a Symbol or String, whereas with FlexiChains you can use the original VarName.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"If you think this is too verbose, fret not! FlexiChains also lets you use Symbols (mainly for compatibility with MCMCChains):","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"flexi[:sigma] == flexi[@varname(sigma)]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"The rest of this page uses VarNames, but you can mentally replace them with Symbols if you prefer.","category":"page"},{"location":"mcmcchains/#Accessing-vector-valued-parameters","page":"Migrating from MCMCChains.jl","title":"Accessing vector-valued parameters","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Suppose you want to access the value of mu in the first iteration.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"With FlexiChains, you can do this directly as:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"flexi[:mu][1]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"With MCMCChains, because mu has been split up into its constituent elements, you need to do:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"[mu[1] for mu in (mcmc[\"mu[1]\"], mcmc[\"mu[2]\"], mcmc[\"mu[3]\"])]","category":"page"},{"location":"mcmcchains/#Accessing-parameters-with-even-more-special-types","page":"Migrating from MCMCChains.jl","title":"Accessing parameters with even more special types","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Now suppose you want to extract the sampled values of chol and corr, and check that","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"# This code block isn't executed because we haven't defined `chols` and `corrs`\nfor (chol, corr) in zip(chols, corrs)\n    chol == cholesky(corr) || error(\"oops\")\nend","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"The question is of course how one can obtain the vectors chols and corrs from the chain. With FlexiChains, you can do this directly as:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"chols = flexi[:chol]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"and likewise for :corr.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"On the other hand, with MCMCChains, reconstructing the chols becomes a non-trivial task:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"using LinearAlgebra\n\nchols = map(1:length(mcmc)) do i\n    c = Cholesky(LowerTriangular(zeros(3, 3)))\n    for j in 1:3\n        for k in 1:j\n            c.L[j, k] = mcmc[\"chol.L[$j, $k]\"][i]\n        end\n    end\n    c\nend","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"and similarly for the corrs (which we won't demonstrate here).","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"In general the point is that in any situation where you want to work with the actual types of the parameters, rather than their individual elements, FlexiChains makes this much easier.","category":"page"},{"location":"mcmcchains/#Accessing-individual-elements","page":"Migrating from MCMCChains.jl","title":"Accessing individual elements","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Sometimes maybe you really want to access just mu[2] without any reference to mu[1] or mu[3].","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Because FlexiChains stores the entire vector mu, you will then need to index into it:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"[mu_sample[2] for mu_sample in flexi[:mu]]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"In MCMCChains you can of course do","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"mcmc[\"mu[2]\"]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Note, though, that MCMCChains requires you to pass a string \"2\" to get the second variable. Of course, if you have an integer 2 this is quite easily done with interpolation, but I would argue from a readability perspective it's much clearer to index with an integer 2 rather than a string.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"<!–","category":"page"},{"location":"mcmcchains/#Other-types-of-data","page":"Migrating from MCMCChains.jl","title":"Other types of data","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Let's say we define a weird new discrete distribution which samples from the alphabet [\"A\", \"B\"].","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"(Why would you want to do this? Well, why shouldn't you be able to do it? Turing's docs tell you how to define your own distributions, but it doesn't say that you have to use numbers. The point is that FlexiChains doesn't force you to stick only to distributions over numbers.)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"using Distributions, Random\n\nstruct AlphabetDist <: Distributions.DiscreteUnivariateDistribution end\nDistributions.rand(rng::Random.AbstractRNG, ::AlphabetDist) = rand(rng) < 0.3 ? 'A' : 'B'\nfunction Distributions.logpdf(::AlphabetDist, x)\n    if x == 'A'\n        log(0.3)\n    elseif x == 'B'\n        log(0.7)\n    else\n        -Inf\n    end\nend\n\n@model function f()\n    x ~ AlphabetDist()\nend\n\n# A bit more boilerplate is needed here to actually make it work with Turing.\nusing Bijectors, DynamicPPL\nDynamicPPL.tovec(c::Char) = [c]\nBijectors.logabsdetjac(::typeof(identity), ::Char) = 0.0\n\nmcmc = sample(f(), MH(), 100; chain_type=Chains)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Great, that worked! (Surprisingly.)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Note that in DynamicPPL there is a conversion to Real so this isn't MCMCChains's fault –>","category":"page"},{"location":"mcmcchains/#Accessing-'generated-quantities'-(using-:)","page":"Migrating from MCMCChains.jl","title":"Accessing 'generated quantities' (using :=)","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"TODO","category":"page"},{"location":"mcmcchains/#Convergence-checks","page":"Migrating from MCMCChains.jl","title":"Convergence checks","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"'Ah,' you say, 'but when I plot my chains I want to see the individual elements of mu as separate lines!'","category":"page"},{"location":"mcmcchains/#No-need-to-avoid-reserved-names","page":"Migrating from MCMCChains.jl","title":"No need to avoid reserved names","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"When sampling from a Turing model with MCMCChains as the output format, some metadata (non-parameter keys) such as lp are added to the chain. If your model contains a variable called lp, sampling will still work but odd things will happen. For example, it will look as if your chain does not actually have any variables:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"@model function lp_model()\n    lp ~ Normal()\nend\n\nmchain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=Chains)\ndescribe(mchain)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"When you index into mchain[:lp], how do you know whether it refers to the lp variable in your model or the lp metadata key?","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"any(mchain[:lp] .> 0)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Well, since there are some positive values, it has to be the parameter, because the metadata lp = logpdf(Normal(), value_of_lp_parameter) is always negative. But you didn't know that when you tried to index into it, you had to reverse engineer it.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Besides, if you actually want the log-density, it's now gone. Tough luck. (You can get it back with logjoint(lp_model(), mchain) if you want.)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"HMC samplers further include extra metadata such as hamiltonian_energy, and in general any sampler can include any kind of extra metadata it wants. As a user, you have no way of knowing what these names are, and you have to avoid using them in your model, which is quite unfair.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"FlexiChains circumvents this entirely since it stores these separately as Parameter(@varname(lp)) and OtherKey(:logprobs, :lp).","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"fchain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=VNChain)","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"You will of course run into ambiguities if you simply attempt to index the chain with [:lp], because both the Parameter(@varname(lp)) and the OtherKey(:logprobs, :lp) exist.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"fchain[:lp]\n# This code block isn't run because it would throw the following error:\n# ArgumentError: multiple keys correspond to symbol :lp.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"but you can still access the value using the original value of the Parameter:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"fchain[@varname(lp)]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"and the corresponding metadata:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"fchain[:logprobs, :lp]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"and indeed we can check that these do align:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"logpdf.(Normal(), fchain[@varname(lp)]) ≈ fchain[:logprobs, :lp]","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"TODO pretty-printing / summary stats","category":"page"},{"location":"mcmcchains/#For-DynamicPPL-developers","page":"Migrating from MCMCChains.jl","title":"For DynamicPPL developers","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"Hey, that's me!","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"TODO Write about how this makes life a lot easier for things like predict.","category":"page"},{"location":"mcmcchains/#Design-goals","page":"Migrating from MCMCChains.jl","title":"Design goals","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"My main design goals for FlexiChains.jl were twofold:","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"To provide a rich data structure that can more faithfully represent the outputs from sampling with Turing.jl.\nThe restriction of MCMCChains.jl to Symbol keys and Real values means that round-trip conversion is a lossy operation. Consider, e.g., the predict(::Model, ::MCMCChains.Chains) function, which is used to sample from the posterior predictive distribution. This requires one to extract the values from the chain and insert them back into the model (or technically the VarInfo).\nHowever, in general one cannot reconstruct a vector x from its constituent elements x[1], x[2], ... as we do not know the appropriate length of the vector! The current implementation of this function in DynamicPPL.jl thus has to, essentially, insert all the elements it can find and hope for the best.\nEssentially, MCMCChains' data structure forces packages like Turing.jl and DynamicPPL.jl to include workarounds to deal with the limitations of the chains package.\nTo create a robust and readable codebase.\nMuch Julia code is written with the intention of efficiency or versatility, often sacrificing clarity in the process. This is usually acceptable when creating simple scripts. However, I believe that library code should be held to a (much) higher standard.\nIn particular, I consider the overuse of multiple dispatch to be a major source of confusion in Julia code. Types cannot be fully inferred at compile time (and even when they can, it requires packages such as JET.jl, which do not (yet) have convenient language server integrations). This means that when reading code, one cannot easily determine which method is being called.\nA prime example is the Chains constructor in MCMCChains.jl. methods(Chains) returns 11 methods, and each time you see a call to Chains(...) you need to figure out which of these 11 it is. In writing FlexiChains I have made a conscious choice to create only two inner constructors for FlexiChain.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"In particular, notice that performance is not one of my considerations. In my opinion, performance is only a minor concern for FlexiChains.jl, because the main bottleneck in Bayesian inference is the sampling, not how fast one can construct or index into a chain. I have not performed any benchmarks but I would expect that most operations on MCMCChains.Chains will be faster than on FlexiChains.FlexiChain.","category":"page"}]
}
