var documenterSearchIndex = {"docs":
[{"location":"details/#FlexiChains-in-more-detail","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"On this page we go into more detail about how FlexiChains is designed, and the ways to manipulate and extract data from a FlexiChain.","category":"page"},{"location":"details/#The-FlexiChain-type","page":"FlexiChains in more detail","title":"The FlexiChain type","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"We begin by looking at the FlexiChain type itself. Fundamentally, a FlexiChain{T} is a mapping of keys to arrays of values. Indeed, a FlexiChain contains a _data field which is just a dictionary that maps keys to fixed-size arrays.","category":"page"},{"location":"details/#FlexiChains.FlexiChain","page":"FlexiChains in more detail","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey,NIter,NChains}\n\nNote that the ordering of keys within a FlexiChain is an implementation detail and is not guaranteed.\n\nTODO: Document further.\n\nFields\n\n_data::Dict{<:FlexiChains.ParameterOrExtra{TKey}, <:FlexiChains.SizedMatrix{NIter, NChains}} where {TKey, NIter, NChains}: Internal per-iteration data for parameters and extra keys. Do not access this directly unless you know what you are doing! You should use the interface methods defined instead.\n\n_metadata::NTuple{NChains, FlexiChains.FlexiChainMetadata} where NChains: Other items associated with the chain. These are not necessarily per-iteration (for example there may only be one per chain).\nYou should not access this directly; instead you should use the accessor functions (e.g. sampling_time(chain)).\n\n\n\n\n\n","category":"type"},{"location":"details/#Metadata","page":"FlexiChains in more detail","title":"Metadata","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"Before we discuss the actual data stored in a FlexiChain, we note that it also contains a _metadata field. This field stores miscellaneous information that is pertinent to the chain as a whole, rather than information that is per-iteration. However, it should not be accessed manually as its fields are considered internal and subject to change. Instead if you need to access this you can use:","category":"page"},{"location":"details/#FlexiChains.sampling_time","page":"FlexiChains in more detail","title":"FlexiChains.sampling_time","text":"sampling_time(chain::FlexiChain)\n\nReturn the time taken to sample the chain (in seconds). If the time was not recorded, this will be nothing.\n\nIf chain only has one chain, this will return a single value. If it has multiple chains, it will return a vector.\n\n\n\n\n\n","category":"function"},{"location":"details/#FlexiChains.last_sampler_state","page":"FlexiChains in more detail","title":"FlexiChains.last_sampler_state","text":"last_sampler_state(chain::FlexiChain)\n\nReturn the final state of the sampler used to generate the chain, if the save_state=true keyword argument was passed to sample. This can be used for resuming MCMC sampling.\n\nIf chain only has one chain, this will return a single value. If it has multiple chains, it will return a vector.\n\nIf the state was not saved, this will be nothing (or a vector thereof)..\n\n\n\n\n\n","category":"function"},{"location":"details/#Key-types","page":"FlexiChains in more detail","title":"Key types","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"The keys of a FlexiChain{T} must be one of two types:","category":"page"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"Parameter(::T): a parameter of the Markov chain itself\nExtra(::Symbol, ::Any): a key that is not a parameter, such as metadata. The Symbol argument identifies a section which the key belongs to, thus allowing for multiple keys to be grouped together in meaningful ways.","category":"page"},{"location":"details/#FlexiChains.Parameter","page":"FlexiChains in more detail","title":"FlexiChains.Parameter","text":"Parameter(name)\n\nA named parameter in a FlexiChain. The name can be of any type, but all parameters in a FlexiChain must have the same type for their names.\n\nSpecifically, if you have a FlexiChain{TKey}, then all parameters must be of type Parameter{TKey}.\n\n\n\n\n\n","category":"type"},{"location":"details/#FlexiChains.Extra","page":"FlexiChains in more detail","title":"FlexiChains.Extra","text":"Extra(section_name::Symbol, key_name::Any)\n\nA key in a FlexiChain that is not a parameter. FlexiChain allows for such informations to be grouped into sections, which are identified by Symbols. The name of the key itself can be of any type and is not constrained by the type of the FlexiChain.\n\n\n\n\n\n","category":"type"},{"location":"details/#FlexiChains.ParameterOrExtra","page":"FlexiChains in more detail","title":"FlexiChains.ParameterOrExtra","text":"ParameterOrExtra{T}\n\nEither a Parameter{T}, or an Extra.\n\nAll keys in a FlexiChain{T} must be a ParameterOrExtra{T}.\n\n\n\n\n\n","category":"type"},{"location":"details/#Dimensions-and-sizes","page":"FlexiChains in more detail","title":"Dimensions and sizes","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"size() when called on a FlexiChain returns a 2-tuple of (niters, nchains).","category":"page"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"note: MCMCChains difference\nMCMCChains returns a 3-tuple of (niters, nkeys, nchains) where nkeys is the total number of parameters. FlexiChains does not do this because the keys do not form a regular grid. If you want the total number of keys in a FlexiChain, you can use length(keys(chain)).","category":"page"},{"location":"details/#Base.size-Tuple{FlexiChains.FlexiChain}","page":"FlexiChains in more detail","title":"Base.size","text":"size(chain::FlexiChain{TKey,NIter,NChains}) where {TKey,NIter,NChains}\n\nReturns (niters, nchains).\n\n\n\n\n\nsize(chain::FlexiChain{TKey,NIter,NChains}, 1)\n\nNumber of iterations in the FlexiChain. Equivalent to niters(chain).\n\nsize(chain::FlexiChain{TKey,NIter,NChains}, 2)\n\nNumber of chains in the FlexiChain. Equivalent to nchains(chain).\n\n\n\n\n\n","category":"method"},{"location":"details/#Base.size-Tuple{FlexiChains.FlexiChain, Int64}","page":"FlexiChains in more detail","title":"Base.size","text":"size(chain::FlexiChain{TKey,NIter,NChains}, 1)\n\nNumber of iterations in the FlexiChain. Equivalent to niters(chain).\n\nsize(chain::FlexiChain{TKey,NIter,NChains}, 2)\n\nNumber of chains in the FlexiChain. Equivalent to nchains(chain).\n\n\n\n\n\n","category":"method"},{"location":"details/#FlexiChains.niters","page":"FlexiChains in more detail","title":"FlexiChains.niters","text":"niters(chain::FlexiChain{TKey,NIter,NChains}) where {TKey,NIter,NChains}\n\nThe number of iterations in the FlexiChain. Equivalent to size(chain, 1).\n\n\n\n\n\n","category":"function"},{"location":"details/#FlexiChains.nchains","page":"FlexiChains in more detail","title":"FlexiChains.nchains","text":"nchains(chain::FlexiChain{TKey,NIter,NChains}) where {TKey,NIter,NChains}\n\nThe number of chains in the FlexiChain. Equivalent to size(chain, 2).\n\n\n\n\n\n","category":"function"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"To provide (runtime) checks that all arrays have the same size, FlexiChains uses FlexiChains.SizedMatrix, which carries its size as a type parameter (although the underlying storage still uses Base.Array). The function data extracts the data from a SizedMatrix and returns it as a regular Array. Note that SizedMatrix and data are not public and are subject to breaking changes even in patch releases.","category":"page"},{"location":"details/#FlexiChains.SizedMatrix","page":"FlexiChains in more detail","title":"FlexiChains.SizedMatrix","text":"SizedMatrix{NIter,NChains,T}\n\nA matrix type that is used to store the data in a FlexiChain. It is similar to StaticArrays.SMatrix in terms of its type behaviour, but under the hood uses plain Arrays for storage. This allows us to have type-level guarantees about the size of the matrix, without having to opt into the performance characteristics and data structures of StaticArrays.\n\nT is the element type.\n\nThe underlying data in a SizedMatrix can be accessed using data(::SizedMatrix). If the matrix has only one chain, it will be returned as a vector. If it has multiple chains, it will be returned as a matrix.\n\nFields\n\n_data::Matrix: Internal data. Do not access this directly! Use data(::SizedMatrix) instead.\n\n\n\n\n\n","category":"type"},{"location":"details/#FlexiChains.data","page":"FlexiChains in more detail","title":"FlexiChains.data","text":"data(s::SizedMatrix{NIter,NChains,T}) where {NIter,NChains,T}\n\nReturn the underlying data of a SizedMatrix as a matrix, or a vector if NChains is 1.\n\nNote that this differs from Base.collect, which always returns a matrix.\n\n\n\n\n\n","category":"function"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"The element type of these arrays is unconstrained. Different keys may map to arrays with different element types.","category":"page"},{"location":"details/#Listing-keys","page":"FlexiChains in more detail","title":"Listing keys","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"keys() will return all the keys in an unspecified order.","category":"page"},{"location":"details/#Base.keys-Tuple{FlexiChains.FlexiChain}","page":"FlexiChains in more detail","title":"Base.keys","text":"keys(chain::FlexiChain{TKey}) where {TKey}\n\nReturns the keys of the FlexiChain as an iterable collection.\n\n\n\n\n\n","category":"method"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"If you only want Parameters, or only Extras you can use the following:","category":"page"},{"location":"details/#FlexiChains.parameters","page":"FlexiChains in more detail","title":"FlexiChains.parameters","text":"parameters(chain::FlexiChain{TKey}) where {TKey}\n\nReturns a vector of parameter names in the FlexiChain.\n\n\n\n\n\n","category":"function"},{"location":"details/#FlexiChains.extras","page":"FlexiChains in more detail","title":"FlexiChains.extras","text":"extras(chain::FlexiChain)\n\nReturns a vector of non-parameter names in the FlexiChain.\n\n\n\n\n\n","category":"function"},{"location":"details/#FlexiChains.extras_grouped","page":"FlexiChains in more detail","title":"FlexiChains.extras_grouped","text":"extras_grouped(chain::FlexiChain)\n\nReturns a NamedTuple of Extra names, grouped by their section.\n\n\n\n\n\n","category":"function"},{"location":"details/#Subsetting-and-merging-parameters","page":"FlexiChains in more detail","title":"Subsetting and merging parameters","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"To restrict a FlexiChain to a subset of its keys, you can use FlexiChains.subset.","category":"page"},{"location":"details/#FlexiChains.subset","page":"FlexiChains in more detail","title":"FlexiChains.subset","text":"subset(\n    chain::FlexiChain{TKey,NIter,NChain},\n    keys::AbstractVector{<:ParameterOrExtra{<:TKey}}\n)::FlexiChain{TKey,NIter,NChain} where {TKey,NIter,NChain}\n\nCreate a new FlexiChain containing only the specified keys and the data corresponding to them.\n\nNote that this function does not perform a deepcopy of the underlying data.\n\n\n\n\n\n","category":"function"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"Two common use cases are subsetting to only parameters and only extra keys:","category":"page"},{"location":"details/#FlexiChains.subset_parameters","page":"FlexiChains in more detail","title":"FlexiChains.subset_parameters","text":"subset_parameters(chain::FlexiChain{TKey,NIter,NChain})\n\nSubset a chain, retaining only the Parameter keys.\n\n\n\n\n\n","category":"function"},{"location":"details/#FlexiChains.subset_extras","page":"FlexiChains in more detail","title":"FlexiChains.subset_extras","text":"subset_parameters(chain::FlexiChain{TKey,NIter,NChain})\n\nSubset a chain, retaining only the keys that are Extras (i.e. not parameters).\n\n\n\n\n\n","category":"function"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"The reverse of subsetting is merging. This can only be done when the chains being merged have the same size.","category":"page"},{"location":"details/#Base.merge-Union{Tuple{NChain}, Tuple{NIter}, Tuple{TKey2}, Tuple{TKey1}, Tuple{FlexiChains.FlexiChain{TKey1, NIter, NChain, TMetadata} where TMetadata<:NTuple{NChain, FlexiChains.FlexiChainMetadata}, FlexiChains.FlexiChain{TKey2, NIter, NChain, TMetadata} where TMetadata<:NTuple{NChain, FlexiChains.FlexiChainMetadata}}} where {TKey1, TKey2, NIter, NChain}","page":"FlexiChains in more detail","title":"Base.merge","text":"Base.merge(\n    c1::FlexiChain{TKey1,NIter,NChain},\n    c2::FlexiChain{TKey2,NIter,NChain}\n) where {TKey1,TKey2,NIter,NChain}\n\nMerge the contents of two FlexiChains. If there are keys that are present in both chains, the values from c2 will overwrite those from c1.\n\nIf the key types are different, the resulting FlexiChain will have a promoted key type, and a warning will be issued.\n\nThe two FlexiChains being merged must have the same dimensions.\n\nNote that this function does not perform a deepcopy of the underlying data.\n\n\n\n\n\n","category":"method"},{"location":"details/#Indexing-via-parameters","page":"FlexiChains in more detail","title":"Indexing via parameters","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"This was covered in a more accessible manner on the previous page, but we provide the full docstrings here for completeness.","category":"page"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"The most unambiguous way to index into a FlexiChain is to use either Parameter or Extra.","category":"page"},{"location":"details/#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChains.FlexiChain{TKey, NIter, NChains} where {NIter, NChains}, FlexiChains.ParameterOrExtra{TKey}}} where TKey","page":"FlexiChains in more detail","title":"Base.getindex","text":"Base.getindex(chain::ChainOrSummary{TKey}, key::ParameterOrExtra{TKey}) where {TKey}\n\nUnambiguously access the data corresponding to the given key in the chain.\n\nYou will need to use this method if you have multiple keys that convert to the same Symbol, such as a Parameter(:x) and an Extra(:some_section, :x).\n\n\n\n\n\n","category":"method"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"This can be slightly verbose, so the following two methods are provided as a 'quick' way of accessing parameters and other keys respectively:","category":"page"},{"location":"details/#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChains.FlexiChain{TKey, NIter, NChains} where {NIter, NChains}, TKey}} where TKey","page":"FlexiChains in more detail","title":"Base.getindex","text":"Base.getindex(chain::ChainOrSummary{TKey}, parameter_name::TKey) where {TKey}\n\nConvenience method for retrieving parameters. Equal to chain[Parameter(parameter_name)].\n\n\n\n\n\n","category":"method"},{"location":"details/#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChains.FlexiChain{TKey, NIter, NChains} where {NIter, NChains}, Symbol, Any}} where TKey","page":"FlexiChains in more detail","title":"Base.getindex","text":"Base.getindex(chain::ChainOrSummary{TKey}, section_name::Symbol, key_name::Any) where {TKey}\n\nConvenience method for retrieving non-parameter keys. Equal to chain[Extra(section_name, key_name)].\n\n\n\n\n\n","category":"method"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"Finally, to preserve some semblance of backwards compatibility with MCMCChains.jl, FlexiChains can also be indexed by Symbols. It does so by looking for a unique Parameter or Extra which can be converted to that Symbol.","category":"page"},{"location":"details/#Base.getindex-Tuple{FlexiChains.FlexiChain, Symbol}","page":"FlexiChains in more detail","title":"Base.getindex","text":"Base.getindex(chain::ChainOrSummary{TKey}, sym_key::Symbol) where {TKey}\n\nThe most convenient method to index into a ChainOrSummary is using Symbol.\n\nHowever, recall that the keys in a ChainOrSummary{TKey} are not stored as Symbols but rather as either Parameter{TKey} or Extra. Thus, to access the data corresponding to a Symbol, we first convert all key names (both parameters and other keys) to Symbols, and then check if there is a unique match.\n\nIf there is, then we can return that data. If there are no valid matches, then we throw a KeyError.\n\nIf there are multiple matches: for example, if you have a Parameter(:x) and also an Extra(:some_section, :x), then this method will also throw a KeyError. You will then have to index into it using the actual key.\n\n\n\n\n\n","category":"method"},{"location":"details/#Concatenation-along-the-other-dimensions","page":"FlexiChains in more detail","title":"Concatenation along the other dimensions","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"If you have two chains and want to concatenate them along the iteration or chain dimension, you can use vcat and hcat respectively. The chains must have the same size along the other dimension (that is not being concatenated).","category":"page"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"If there are parameters that are present in one chain but not the other, they will be assigned missing values in the concatenated chain.","category":"page"},{"location":"details/#Base.vcat-Union{Tuple{NChains}, Tuple{NIter2}, Tuple{NIter1}, Tuple{TKey}, Tuple{FlexiChains.FlexiChain{TKey, NIter1, NChains, TMetadata} where TMetadata<:NTuple{NChains, FlexiChains.FlexiChainMetadata}, FlexiChains.FlexiChain{TKey, NIter2, NChains, TMetadata} where TMetadata<:NTuple{NChains, FlexiChains.FlexiChainMetadata}}} where {TKey, NIter1, NIter2, NChains}","page":"FlexiChains in more detail","title":"Base.vcat","text":"Base.vcat(cs...::FlexiChain{TKey}) where {TKey}\n\nConcatenate one or more FlexiChains along the iteration dimension. Both c1 and c2 must have the same number of chains and the same key type.\n\nThe resulting chain's keys are the union of both input chains' keys. Any keys that only have data in one of the arguments will be assigned missing data in the other chain during concatenation.\n\n\n\n\n\n","category":"method"},{"location":"details/#Base.hcat-Union{Tuple{NChains2}, Tuple{NChains1}, Tuple{NIter}, Tuple{TKey}, Tuple{FlexiChains.FlexiChain{TKey, NIter, NChains1, TMetadata} where TMetadata<:NTuple{NChains1, FlexiChains.FlexiChainMetadata}, FlexiChains.FlexiChain{TKey, NIter, NChains2, TMetadata} where TMetadata<:NTuple{NChains2, FlexiChains.FlexiChainMetadata}}} where {TKey, NIter, NChains1, NChains2}","page":"FlexiChains in more detail","title":"Base.hcat","text":"Base.hcat(cs...::FlexiChain{TKey}) where {TKey}\n\nConcatenate one or more FlexiChains along the chain dimension. Both c1 and c2 must have the same number of iterations and the same key type.\n\nThe resulting chain's keys are the union of both input chains' keys. Any keys that only have data in one of the arguments will be assigned missing data in the other chain during concatenation.\n\n\n\n\n\n","category":"method"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"The rather little-known AbstractMCMC.chainscat and AbstractMCMC.chainsstack methods (see AbstractMCMC.jl docs) are also defined on FlexiChains; they both make use of hcat.","category":"page"},{"location":"details/#Manually-constructing-a-FlexiChain","page":"FlexiChains in more detail","title":"Manually constructing a FlexiChain","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"If you ever need to construct a FlexiChain from scratch, there are exactly two ways to do so. One is to pass an array of dictionaries (i.e., one dictionary per iteration); the other is to pass a dictionary of arrays (i.e., the values for each key are already grouped together).","category":"page"},{"location":"details/#FlexiChains.FlexiChain-Union{Tuple{Any}, Tuple{TKey}} where TKey","page":"FlexiChains in more detail","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey}(\n    array_of_dicts::AbstractArray{<:AbstractDict,N};\n    sampling_time::Any=nothing,\n    last_sampler_state::Any=nothing,\n) where {TKey,N}\n\nConstruct a FlexiChain from a vector or matrix of dictionaries. Each dictionary corresponds to one iteration.\n\nEach dictionary must be a mapping from a ParameterOrExtra{TKey} (i.e., either a Parameter{TKey} or an Extra) to its value at that iteration.\n\nIf array_of_dicts is a vector (i.e., N = 1), then niter is the length of the vector and nchains is 1. If array_of_dicts is a matrix (i.e., N = 2), then (niter, nchains) = size(dicts).\n\nOther values of N will error.\n\nsampling_time and last_sampler_state are used to store metadata about each chain. If there is more than one chain (i.e., if size(arrayofdicts, 2) > 1), the parameters sampling_time and last_sampler_state must be vectors with length equal to the number of chains. If there is only one chain, they should be scalars.\n\nExample usage\n\nd = fill(\n    Dict(Parameter(:x) => rand(), Extra(:section, \"y\") => rand()), 200, 3\n)\nchn = FlexiChain{Symbol}(d)\n\n\n\n\n\nFlexiChain{TKey}(\n    dict_of_arrays::AbstractDict{<:Any,<:AbstractArray{<:Any,N}};\n    sampling_time::Any=nothing,\n    last_sampler_state::Any=nothing,\n) where {TKey,N}\n\nConstruct a FlexiChain from a dictionary of arrays.\n\nEach key in the dictionary must subtype ParameterOrExtra{TKey} (i.e., it is either a Parameter{TKey} or an Extra). The values of the dictionary must all be of the same size.\n\nIf the values are vectors (i.e., N = 1), then niters will be the length of the vector, and nchains will be 1. If the values are matrices (i.e., N = 2), then (niter, nchains) = size(array).\n\nOther values of N will error.\n\nsampling_time and last_sampler_state are used to store metadata about each chain. If there is more than one chain (i.e., for some value v in dict_of_arrays, size(v, 2) > 1), the parameters sampling_time and last_sampler_state must be vectors with length equal to the number of chains. If there is only one chain, they should be scalars.\n\nExample usage\n\nd = Dict(\n    Parameter(:x) => rand(200, 3),\n    Extra(:section, \"y\") => rand(200, 3),\n)\nchn = FlexiChain{Symbol}(d)\n\n\n\n\n\n","category":"method"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"Note that, although the dictionaries themselves may have loose types, the key type of the FlexiChain must be specified (and the keys of the dictionaries will be checked against this).","category":"page"},{"location":"details/#Deconstructing-a-FlexiChain","page":"FlexiChains in more detail","title":"Deconstructing a FlexiChain","text":"","category":"section"},{"location":"details/","page":"FlexiChains in more detail","title":"FlexiChains in more detail","text":"Sometimes you may want to retrieve the mapping of keys to values for a particular iteration. This is useful especially for DynamicPPL developers. To this end, the following functions are provided:","category":"page"},{"location":"details/#FlexiChains.get_dict_from_iter","page":"FlexiChains in more detail","title":"FlexiChains.get_dict_from_iter","text":"get_dict_from_iter(\n    chain::FlexiChain{TKey},\n    iteration_number::Int,\n    chain_number::Union{Int,Nothing}=nothing\n)::Dict{ParameterOrExtra{TKey},Any}\n\nExtract the dictionary mapping keys to their values in a single MCMC iteration.\n\nIf chain only contains a single chain, then chain_number does not need to be specified.\n\nThe order of keys in the returned dictionary is not guaranteed.\n\nTo get only the parameter keys, use get_parameter_dict_from_iter.\n\n\n\n\n\n","category":"function"},{"location":"details/#FlexiChains.get_parameter_dict_from_iter","page":"FlexiChains in more detail","title":"FlexiChains.get_parameter_dict_from_iter","text":"get_parameter_dict_from_iter(\n    chain::FlexiChain{TKey},\n    iteration_number::Int,\n    chain_number::Union{Int,Nothing}=nothing\n)::Dict{TKey,Any} where {TKey}\n\nExtract the dictionary corresponding to a single MCMC iteration, but with only the parameters.\n\nTo get all other non-parameter keys as well, use get_dict_from_iter.\n\nThe order of keys in the returned dictionary is not guaranteed.\n\n\n\n\n\n","category":"function"},{"location":"turing/#Usage-with-Turing.jl","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"This page describes how to use FlexiChains from the perspective of a Turing.jl user.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In particular, it does not explain 'under the hood' how FlexiChains works. Rather, it focuses on the usage of FlexiChains within a typical Bayesian inference workflow. For more detailed information about the inner workings of FlexiChains, please see the next page.","category":"page"},{"location":"turing/#Sampling","page":"Usage with Turing.jl","title":"Sampling","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To obtain a FlexiChain from Turing.jl, you will need to specify a chain_type of FlexiChains.VNChain when performing MCMC sampling.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Let's use a non-trivial model so that we can illustrate some features of FlexiChains.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using Turing\nusing FlexiChains: VNChain\n\ny = [28, 8, -3, 7, -1, 1, 18, 12]\nsigma = [15, 10, 16, 11, 9, 11, 10, 18]\n@model function eight_schools(y, sigma)\n    mu ~ Normal(0, 5)\n    tau ~ truncated(Cauchy(0, 5); lower=0)\n    theta ~ MvNormal(fill(mu, length(y)), tau^2 * I)\n    for i in eachindex(y)\n        y[i] ~ Normal(theta[i], sigma[i])\n    end\n    return (mu=mu, tau=tau)\nend\nmodel = eight_schools(y, sigma)\nchain = sample(model, NUTS(), 5; chain_type=VNChain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Note\nWe only run 5 MCMC iterations here to keep the output in the following sections small.","category":"page"},{"location":"turing/#Accessing-data","page":"Usage with Turing.jl","title":"Accessing data","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"First, notice in the printout above that a FlexiChain stores parameters and 'other keys' separately. The way to access these differs slightly.","category":"page"},{"location":"turing/#Parameters","page":"Usage with Turing.jl","title":"Parameters","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To access parameters, the most correct way is to use VarNames to index into the chain. VarName is a data structure defined in AbstractPPL.jl, and is what Turing.jl uses to represent the name of a random variable (appearing on the left-hand side of a tilde-statement).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"For example, this directly gives us the value of mu in each iteration as a plain old vector of floats.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(mu)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Multiple chains\nIf you sample multiple chains, e.g. with sample(model, NUTS(), MCMCThreads(), 1000, 3; chain_type=VNChain), then indexing into the FlexiChain will give you a matrix of floats instead.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"For vector-valued parameters like theta, this works in exactly the same way, except that you get a vector of vectors (note: not a matrix).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(theta)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"This is probably the most major difference between FlexiChains and MCMCChains. MCMCChains by default will break vector-valued parameters into multiple scalar-valued parameters called theta[1], theta[2], etc., whereas FlexiChains keeps them together as they were defined in the model.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you want to obtain the first element of theta, you can index into it with the corresponding VarName:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(theta[1])]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Note that this can only be used to 'break down', or access nested fields of, larger parameters. That is, if your model has x ~ dist, FlexiChains will let you access some field or index of x.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"However, you cannot go the other way: if your model has x[1] ~ dist you cannot 'reconstruct' x from its component elements. (Or at least, you can't do it with FlexiChains. You can still call chain[@varname(x[1])] and chain[@varname(x[2])] and then perform hcat or similar to put them together yourself.)","category":"page"},{"location":"turing/#Other-information-in-the-chain","page":"Usage with Turing.jl","title":"Other information in the chain","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In general Turing.jl tries to package up some extra metadata into the chain that may be helpful. For example, the log-joint probability of each sample is stored with the key :lp. Notice in the FlexiChain output displayed above, this is associated with a section, labelled :logprobs. In FlexiChains, all non-parameter keys are grouped into sections.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To access these, you need to specify both the section name and the key name.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[:logprobs, :lp]","category":"page"},{"location":"turing/#Shortcuts","page":"Usage with Turing.jl","title":"Shortcuts","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you are used to MCMCChains.jl, you may find this more cumbersome than before. So, FlexiChains provides some shortcuts for accessing data. You can index into a FlexiChain with a single Symbol, and as long as it is unambiguous, it will return the corresponding data.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[:mu] # parameter","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: What does unambiguous mean?\nIn this case, because the only parameter p for which Symbol(p) == :mu is @varname(mu), we can safely identify @varname(mu) as the parameter that we want.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Likewise, we can omit the section symbol for the :lp data.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[:lp] # other key","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If there is any ambiguity present (for example if there is a parameter named lp as well), FlexiChains will throw an error.","category":"page"},{"location":"turing/#Saving-and-resuming-MCMC-sampling-progress","page":"Usage with Turing.jl","title":"Saving and resuming MCMC sampling progress","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you want to sample a fewer number of iterations first and then resume it later, you can use the following:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chn1 = sample(model, NUTS(), 10; chain_type=VNChain, save_state=true)\nchn2 = sample(model, NUTS(), 10; chain_type=VNChain, resume_from=chn1)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The chains can be combined using vcat:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chn = vcat(chn1, chn2)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Multiple-chain sampling\nIn general, the resume_from argument only works automatically if both the original and resumed sampling use the same number of chains. That is, chn1 and chn2 must either both be invoked as sample(model, spl, N), or both invoked as sample(model, spl, MCMCThreads(), N, C) with the same C.If you need more flexibility than this, then the initial_state keyword argument is recommended instead. When performing single-chain sampling with sample(model, spl, N; initial_state=state), initial_state should be either nothing (to start a new chain) or the state to resume from. For parallel sampling with sample(model, spl, MCMCThreads(), N, C), initial_state should be a vector of length C, where initial_state[i] is the state to resume the i-th chain from (or nothing to start a new chain).To obtain the saved final state of a chain, you can use FlexiChains.last_sampler_state. This is either a single state (for single-chain sampling) or a vector of states (for multi-chain sampling).The above applies equally to MCMCSerial() and MCMCDistributed().","category":"page"},{"location":"turing/#Posterior-predictions-and-friends","page":"Usage with Turing.jl","title":"Posterior predictions and friends","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The functions predict, returned, logjoint, loglikelihood, and logprior all work 'as expected' using FlexiChains with exactly the same signatures that you are used to. Please consult the Turing.jl documentation for more details.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"returned(model, chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The pointwise_logdensity family of functions is not yet implemented.","category":"page"},{"location":"turing/#Statistics-and-plotting","page":"Usage with Turing.jl","title":"Statistics and plotting","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Right now FlexiChains does not (yet) provide any functionality for calculating statistics or plotting, although these are planned for the future.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In the meantime, you can convert a FlexiChain to an MCMCChains.Chains object using the MCMCChains.Chains constructor.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using MCMCChains\nmcmc = MCMCChains.Chains(chain)","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"FlexiChains.jl provides an information-rich data structure for Markov chains. It is intended as a drop-in (but better) replacement for MCMCChains.jl.","category":"page"},{"location":"whynew/#Why-a-new-package?","page":"Why a new package?","title":"Why a new package?","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"FlexiChains.jl has been designed from the ground up to address existing limitations of MCMCChains.jl.","category":"page"},{"location":"whynew/#The-fundamental-difference","page":"Why a new package?","title":"The fundamental difference","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Under the hood, MCMCChains.jl uses AxisArrays.AxisArray as its data structure. Specifically, this allows it to store data in a compact 3-dimensional matrix, and index into the matrix using Symbols.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The downside of this is that it enforces a key type of Symbol and a value type of Tval<:Real. This means that, for example, if you have a model with vector-valued parameters (like x above), the vectors will be split up into their individual elements before being stored in the chain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"This is the core of how MCMCChains and FlexiChains differ, and all of the behaviour shown below stems from this.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"To illustrate this, let's sample from a Turing model and store the results in both MCMCChains.Chains and FlexiChains.VNChain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"using Turing\nusing MCMCChains: Chains\nusing FlexiChains: VNChain, VarName, @varname\nusing Random: Xoshiro\nusing PDMats: PDMats\n\nTuring.setprogress!(false)\n\n@model function f(x)\n    sigma ~ truncated(Normal(0, 1); lower=0)\n    chol ~ LKJCholesky(3, 1.0)\n    corr := PDMats.PDMat(chol)\n    mu ~ MvNormal(zeros(3), sigma^2 * I)\n    return x ~ MvNormal(mu, corr)\nend\n\nmodel = f(randn(Xoshiro(468), 3))","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The default chain type for Turing's sample is still MCMCChains.Chains; we just specify it here for clarity.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"mcmc = sample(Xoshiro(468), model, NUTS(), 100; chain_type=Chains)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Because FlexiChains does not enforce a key type, you are technically required to specify the key type of the chain as a type parameter. You could, for example, write FlexiChains.FlexiChain{DynamicPPL.VarName}. But since this is really the main use case of FlexiChains, we provide a convenient alias for this, FlexiChains.VNChain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"flexi = sample(Xoshiro(468), model, NUTS(), 100; chain_type=VNChain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Here, we expect the following parameters to be present in the chain:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"sigma is a scalar;\nchol is a Cholesky factor which contains a 3×3 lower triangular matrix;\ncorr is a 3×3 correlation matrix, which is a positive-definite matrix;\nmu is a length-3 vector.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Let's test first that both chains contain the same values for sigma. (Some fiddling is required because mcmc[:sigma] returns an AxisArray with a 100×1 matrix, while flexi[:sigma] returns a 100-element vector.)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"vec(mcmc[:sigma].data) == flexi[@varname(sigma)]","category":"page"},{"location":"whynew/#Indexing-keys","page":"Why a new package?","title":"Indexing keys","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"There is already one difference here: when indexing into MCMCChains you need to use a Symbol or String, whereas with FlexiChains you can use the original VarName.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"If you think this is too verbose, fret not! FlexiChains also lets you use Symbols (mainly for compatibility with MCMCChains):","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"flexi[:sigma] == flexi[@varname(sigma)]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The rest of this page uses VarNames, but you can mentally replace them with Symbols if you prefer.","category":"page"},{"location":"whynew/#Accessing-vector-valued-parameters","page":"Why a new package?","title":"Accessing vector-valued parameters","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Suppose you want to access the value of mu in the first iteration.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"With FlexiChains, you can do this directly as:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"flexi[:mu][1]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"With MCMCChains, because mu has been split up into its constituent elements, you need to do:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"[mu[1] for mu in (mcmc[\"mu[1]\"], mcmc[\"mu[2]\"], mcmc[\"mu[3]\"])]","category":"page"},{"location":"whynew/#Accessing-parameters-with-even-more-special-types","page":"Why a new package?","title":"Accessing parameters with even more special types","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Now suppose you want to extract the sampled values of chol and corr, and check that","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"# This code block isn't executed because we haven't defined `chols` and `corrs`\nfor (chol, corr) in zip(chols, corrs)\n    chol == cholesky(corr) || error(\"oops\")\nend","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The question is of course how one can obtain the vectors chols and corrs from the chain. With FlexiChains, you can do this directly as:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"chols = flexi[:chol]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and likewise for :corr.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"On the other hand, with MCMCChains, reconstructing the chols becomes a non-trivial task:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"using LinearAlgebra\n\nchols = map(1:length(mcmc)) do i\n    c = Cholesky(LowerTriangular(zeros(3, 3)))\n    for j in 1:3\n        for k in 1:j\n            c.L[j, k] = mcmc[\"chol.L[$j, $k]\"][i]\n        end\n    end\n    c\nend","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and similarly for the corrs (which we won't demonstrate here).","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"In general the point is that in any situation where you want to work with the actual types of the parameters, rather than their individual elements, FlexiChains makes this much easier.","category":"page"},{"location":"whynew/#Accessing-individual-elements","page":"Why a new package?","title":"Accessing individual elements","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Sometimes maybe you really want to access just mu[2] without any reference to mu[1] or mu[3].","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Because FlexiChains stores the entire vector mu, you will then need to index into it:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"[mu_sample[2] for mu_sample in flexi[:mu]]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"In MCMCChains you can of course do","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"mcmc[\"mu[2]\"]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Note, though, that MCMCChains requires you to pass a string \"2\" to get the second variable. Of course, if you have an integer 2 this is quite easily done with interpolation, but I would argue from a readability perspective it's much clearer to index with an integer 2 rather than a string.","category":"page"},{"location":"whynew/#Other-types-of-data","page":"Why a new package?","title":"Other types of data","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Let's say we define a weird new discrete distribution which samples from the two structs Duck() and Goose().","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"(Why would you want to do this? Well, why shouldn't you be able to do it? Turing's docs tell you how to define your own distributions, but it doesn't say that you have to use numbers. The point is that FlexiChains doesn't force you to stick only to distributions over numbers.)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"using Distributions, Random\n\nabstract type Bird end\nstruct Duck <: Bird end\nstruct Goose <: Bird end\n\nstruct BirdDist <: Distributions.DiscreteUnivariateDistribution end\nDistributions.rand(rng::Random.AbstractRNG, ::BirdDist) = rand(rng) < 0.3 ? Duck() : Goose()\nDistributions.logpdf(::BirdDist, x::Duck) = log(0.3)\nDistributions.logpdf(::BirdDist, x::Goose) = log(0.7)\n\n@model function f()\n    return x ~ BirdDist()\nend\n\n# A bit more boilerplate is needed here to actually make it work with Turing.\nusing Bijectors, DynamicPPL\nDynamicPPL.tovec(b::Bird) = [b]\nBijectors.logabsdetjac(::typeof(identity), ::Bird) = 0.0\n\n# mcmc = sample(f(), MH(), 100; chain_type=VNChain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"TODO: Fix the example above, it fails with typed VarInfo because typed VarInfo expects Real things to put into Metadata. SimpleVarInfo would work. See https://github.com/TuringLang/DynamicPPL.jl/pull/1003","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Well, that worked quite nicely with FlexiChains.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"MCMCChains on the other hand would completely error here because it requires all its values to be Real. (To be precise, it requires all its values to be convertable to Real. So a distribution over Char works, even though Char <: Real is false, because Chars can be converted to Real.)","category":"page"},{"location":"whynew/#No-need-to-avoid-reserved-names","page":"Why a new package?","title":"No need to avoid reserved names","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"When sampling from a Turing model with MCMCChains as the output format, some metadata (non-parameter keys) such as lp are added to the chain. If your model contains a variable called lp, sampling will still work but odd things will happen. For example, it will look as if your chain does not actually have any variables:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"@model function lp_model()\n    return lp ~ Normal()\nend\n\nmchain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=Chains)\ndescribe(mchain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"When you index into mchain[:lp], how do you know whether it refers to the lp variable in your model or the lp metadata key?","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"any(mchain[:lp] .> 0)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Well, since there are some positive values, it has to be the parameter, because the metadata lp = logpdf(Normal(), value_of_lp_parameter) is always negative. But you didn't know that when you tried to index into it, you had to reverse engineer it.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Besides, if you actually want the log-density, it's now gone. Tough luck. (You can get it back with logjoint(lp_model(), mchain) if you want.)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"HMC samplers further include extra metadata such as hamiltonian_energy, and in general any sampler can include any kind of extra metadata it wants. As a user, you have no way of knowing what these names are, and you have to avoid using them in your model, which is quite unfair.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"FlexiChains circumvents this entirely since it stores these separately as Parameter(@varname(lp)) and Extra(:logprobs, :lp).","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"fchain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=VNChain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"You will of course run into ambiguities if you simply attempt to index the chain with [:lp], because both the Parameter(@varname(lp)) and the Extra(:logprobs, :lp) exist.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"fchain[:lp]\n# This code block isn't run because it would throw the following error:\n# ArgumentError: multiple keys correspond to symbol :lp.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"but you can still access the value using the original value of the Parameter:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"fchain[@varname(lp)]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and the corresponding metadata:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"fchain[:logprobs, :lp]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and indeed we can check that these do align:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"logpdf.(Normal(), fchain[@varname(lp)]) ≈ fchain[:logprobs, :lp]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"TODO pretty-printing / summary stats","category":"page"},{"location":"whynew/#For-DynamicPPL-developers","page":"Why a new package?","title":"For DynamicPPL developers","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"TODO Write about how this makes life a lot easier for things like predict.","category":"page"},{"location":"whynew/#Design-goals","page":"Why a new package?","title":"Design goals","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"My main design goals for FlexiChains.jl were twofold:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"To provide a rich data structure that can more faithfully represent the outputs from sampling with Turing.jl.\nThe restriction of MCMCChains.jl to Symbol keys and Real values means that round-trip conversion is a lossy operation. Consider, e.g., the predict(::Model, ::MCMCChains.Chains) function, which is used to sample from the posterior predictive distribution. This requires one to extract the values from the chain and insert them back into the model (or technically the VarInfo).\nHowever, in general one cannot reconstruct a vector x from its constituent elements x[1], x[2], ... as we do not know the appropriate length of the vector! The current implementation of this function in DynamicPPL.jl thus has to, essentially, insert all the elements it can find and hope for the best.\nEssentially, MCMCChains' data structure forces packages like Turing.jl and DynamicPPL.jl to include workarounds to deal with the limitations of the chains package.\nTo create a robust and readable codebase.\nMuch Julia code is written with the intention of efficiency or versatility, often sacrificing clarity in the process. This is usually acceptable when creating simple scripts. However, I believe that library code should be held to a (much) higher standard.\nIn particular, I consider the overuse of multiple dispatch to be a major source of confusion in Julia code. Types cannot be fully inferred at compile time (and even when they can, it requires packages such as JET.jl, which do not (yet) have convenient language server integrations). This means that when reading code, one cannot easily determine which method is being called.\nA prime example is the Chains constructor in MCMCChains.jl. methods(Chains) returns 11 methods, and each time you see a call to Chains(...) you need to figure out which of these 11 it is. In writing FlexiChains I have made a conscious choice to create only two inner constructors for FlexiChain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"In particular, notice that performance is not one of my considerations. In my opinion, performance is only a minor concern for FlexiChains.jl, because the main bottleneck in Bayesian inference is the sampling, not how fast one can construct or index into a chain.","category":"page"}]
}
