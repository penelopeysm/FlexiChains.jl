var documenterSearchIndex = {"docs":
[{"location":"#FlexiChains.jl","page":"Home","title":"FlexiChains.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FlexiChains.jl provides an information-rich data structure for Markov chains.","category":"page"},{"location":"#Core-data-structure","page":"Home","title":"Core data structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fundamentally, a FlexiChain{T} is a mapping of keys to values.","category":"page"},{"location":"#FlexiChains.FlexiChain","page":"Home","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey,NIter,NChains,Sections}\n\nTODO: Document further.\n\nFields\n\n_data::Dict{<:FlexiChainKey{TKey}, <:FlexiChains.SizedMatrix{NIter, NChains}} where {TKey, NIter, NChains}: Internal data. Do not access this directly unless you know what you are doing! You should use the interface methods defined instead.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"The values must be matrices or vectors that all have the same size. The element type is unconstrained.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The keys must be one of two types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parameter(::T): a parameter of the Markov chain itself\nOtherKey(::Symbol, ::Any): a key that is not a parameter, such as metadata. The Symbol argument identifies a section which the key belongs to, thus allowing for multiple keys to be grouped together in meaningful ways.","category":"page"},{"location":"#FlexiChains.Parameter","page":"Home","title":"FlexiChains.Parameter","text":"Parameter(name)\n\nA named parameter in a FlexiChain. The name can be of any type, but all parameters in a FlexiChain must have the same type for their names.\n\nSpecifically, if you have a FlexiChain{TKey}, then all parameters must be of type Parameter{TKey}.\n\n\n\n\n\n","category":"type"},{"location":"#FlexiChains.OtherKey","page":"Home","title":"FlexiChains.OtherKey","text":"OtherKey(section_name::Symbol, key_name::Any)\n\nA key in a FlexiChain that is not a parameter. FlexiChain allows for such informations to be grouped into sections, which are identified by Symbols. The name of the key itself can be of any type and is not constrained by the type of the FlexiChain.\n\n\n\n\n\n","category":"type"},{"location":"#FlexiChains.FlexiChainKey","page":"Home","title":"FlexiChains.FlexiChainKey","text":"FlexiChainKey{T}\n\nEither a Parameter{T}, or an OtherKey.\n\nAll keys in a FlexiChain{T} must be a FlexiChainKey{T}.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Bearing this in mind, there are two ways to construct a FlexiChain. One is to pass an array of dictionaries (i.e., one dictionary per iteration); the other is to pass a dictionary of arrays (i.e., the values for each key are already grouped together).","category":"page"},{"location":"#FlexiChains.FlexiChain-Union{Tuple{Any}, Tuple{TKey}} where TKey","page":"Home","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey}(\n    array_of_dicts::AbstractArray{<:AbstractDict,N}\n) where {TKey,N}\n\nConstruct a FlexiChain from a vector or matrix of dictionaries. Each dictionary corresponds to one iteration.\n\nEach dictionary must be a mapping from a FlexiChainKey{TKey} (i.e., either a Parameter{TKey} or an OtherKey) to its value at that iteration.\n\nIf array_of_dicts is a vector (i.e., N = 1), then niter is the length of the vector and nchains is 1. If array_of_dicts is a matrix (i.e., N = 2), then (niter, nchains) = size(dicts).\n\nOther values of N will error.\n\nExample usage\n\nd = fill(\n    Dict(Parameter(:x) => rand(), OtherKey(:section, \"y\") => rand()), 200, 3\n)\nchn = FlexiChain{Symbol}(d)\n\n\n\n\n\nFlexiChain{TKey}(\n    dict_of_arrays::AbstractDict{<:Any,<:AbstractArray{<:Any,N}}\n) where {TKey,N}\n\nConstruct a FlexiChain from a dictionary of arrays.\n\nEach key in the dictionary must subtype FlexiChainKey{TKey} (i.e., it is either a Parameter{TKey} or an OtherKey). The values of the dictionary must all be of the same size.\n\nIf the values are vectors (i.e., N = 1), then niters will be the length of the vector, and nchains will be 1. If the values are matrices (i.e., N = 2), then (niter, nchains) = size(array).\n\nOther values of N will error.\n\nExample usage\n\nd = Dict(\n    Parameter(:x) => rand(200, 3),\n    OtherKey(:section, \"y\") => rand(200, 3),\n)\nchn = FlexiChain{Symbol}(d)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Note that, although the dictionaries themselves may have loose types, the key type of the FlexiChain must be specified (and the keys of the dictionaries will be checked against this).","category":"page"},{"location":"#Accessing-values","page":"Home","title":"Accessing values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Indexing into a FlexiChain can be done in two ways:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Symbol, which is a lossy operation but more convenient;\ndirectly using Parameter or OtherKey, which is most faithful to the underlying data structure;","category":"page"},{"location":"#Base.getindex-Tuple{FlexiChain, Symbol}","page":"Home","title":"Base.getindex","text":"Base.getindex(chain::FlexiChain{TKey}, sym_key::Symbol) where {TKey}\n\nThe most convenient method to index into a FlexiChain is using Symbol.\n\nHowever, recall that the keys in a FlexiChain{TKey} are not stored as Symbols but rather as either Parameter{TKey} or OtherKey. Thus, to access the data corresponding to a Symbol, we first convert all key names (both parameters and other keys) to Symbols, and then check if there is a unique match.\n\nIf there is, then we can return that data. If there are no valid matches, then we throw a KeyError.\n\nIf there are multiple matches: for example, if you have a Parameter(:x) and also an OtherKey(:some_section, :x), then this method will also throw a KeyError. You will then have to index into it using the actual key.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChain{TKey}, FlexiChainKey{TKey}}} where TKey","page":"Home","title":"Base.getindex","text":"Base.getindex(chain::FlexiChain{TKey}, key::FlexiChainKey{TKey}) where {TKey}\n\nUnambiguously access the data corresponding to the given key in the chain.\n\nYou will need to use this method if you have multiple keys that convert to the same Symbol, such as a Parameter(:x) and an OtherKey(:some_section, :x).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"For convenience when accessing non-parameter keys, you can also use:","category":"page"},{"location":"#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChain{TKey}, Symbol, Any}} where TKey","page":"Home","title":"Base.getindex","text":"Base.getindex(chain::FlexiChain{TKey}, section_name::Symbol, key_name::Symbol) where {TKey}\n\nConvenience method for chain[OtherKey(section_name, key_name)].\n\n\n\n\n\n","category":"method"},{"location":"mcmcchains/#Migrating-from-MCMCChains.jl","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"FlexiChains.jl has been designed from the ground up to address existing limitations of MCMCChains.jl.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"This page describes some key differences from MCMCChains.jl and how you can migrate your code to use FlexiChains.jl.","category":"page"},{"location":"mcmcchains/#Chain-key-types","page":"Migrating from MCMCChains.jl","title":"Chain key types","text":"","category":"section"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"MCMCChains.jl enforces a key type of Symbol and a value type of Tval<:Real. This means that, for example, if you have a model with vector-valued parameters, the vectors will be split up into their individual elements before being stored in the chain.","category":"page"},{"location":"mcmcchains/","page":"Migrating from MCMCChains.jl","title":"Migrating from MCMCChains.jl","text":"(To be continued...)","category":"page"}]
}
