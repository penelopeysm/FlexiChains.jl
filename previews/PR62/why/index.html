<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Why FlexiChains? · FlexiChains.jl</title><meta name="title" content="Why FlexiChains? · FlexiChains.jl"/><meta property="og:title" content="Why FlexiChains? · FlexiChains.jl"/><meta property="twitter:title" content="Why FlexiChains? · FlexiChains.jl"/><meta name="description" content="Documentation for FlexiChains.jl."/><meta property="og:description" content="Documentation for FlexiChains.jl."/><meta property="twitter:description" content="Documentation for FlexiChains.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexiChains.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../turing/">Usage with Turing.jl</a></li><li><a class="tocitem" href="../summarising/">Summarising</a></li><li><a class="tocitem" href="../indexing/">Indexing</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../integrations/">Integrations with other packages</a></li><li><a class="tocitem" href="../api/">Public API</a></li><li class="is-active"><a class="tocitem" href>Why FlexiChains?</a><ul class="internal"><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li><li><a class="tocitem" href="#Heterogeneous-parameter-types"><span>Heterogeneous parameter types</span></a></li><li><a class="tocitem" href="#Missing-data"><span>Missing data</span></a></li><li><a class="tocitem" href="#Arbitrary-types"><span>Arbitrary types</span></a></li><li><a class="tocitem" href="#Reconstructing-parameters"><span>Reconstructing parameters</span></a></li><li><a class="tocitem" href="#VarNames-as-keys"><span>VarNames as keys</span></a></li><li><a class="tocitem" href="#Performance-(on-important-things)"><span>Performance (on important things)</span></a></li><li><a class="tocitem" href="#Avoiding-name-clashes"><span>Avoiding name clashes</span></a></li><li><a class="tocitem" href="#DimensionalData.jl-indexing"><span>DimensionalData.jl indexing</span></a></li><li><a class="tocitem" href="#If-you&#39;re-a-Turing-developer..."><span>If you&#39;re a Turing developer...</span></a></li></ul></li><li><a class="tocitem" href="../whynot/">Why not FlexiChains?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Why FlexiChains?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Why FlexiChains?</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl/blob/main/docs/src/why.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Why-FlexiChains?"><a class="docs-heading-anchor" href="#Why-FlexiChains?">Why FlexiChains?</a><a id="Why-FlexiChains?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-FlexiChains?" title="Permalink"></a></h1><p>If you are a Turing user (or developer!), you may well be asking why you should consider using FlexiChains.jl.</p><p>In one sentence: <strong>FlexiChains is a more faithful representation of data.</strong> MCMCChains.jl places extremely strong restrictions on its data structure, which leads to an irrevocable loss of information.</p><p>Of course, on its own this doesn&#39;t mean much (unless you are a software engineering purist!). So this page will demonstrate a few concrete scenarios where FlexiChains has a practical advantage.</p><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><p>This package is much better documented. In my opinion. (To be fair, I did put a lot of work into it, and if I spent the same amount of time on MCMCChains, I suppose its docs would also look better.)</p><h2 id="Heterogeneous-parameter-types"><a class="docs-heading-anchor" href="#Heterogeneous-parameter-types">Heterogeneous parameter types</a><a id="Heterogeneous-parameter-types-1"></a><a class="docs-heading-anchor-permalink" href="#Heterogeneous-parameter-types" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model function f()
    x ~ Normal()
    y ~ Poisson(3.0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 2 methods)</code></pre><p>When sampling from this model, one should expect that the samples of <code>x</code> are stored as floats, whereas the samples of <code>y</code> are stored as integers, because that is what these distributions produce.</p><p>Under the hood, MCMCChains stores the values of all parameters in a single array, which means that all samples get converted into the same type.</p><pre><code class="language- hljs">mchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=MCMCChains.Chains)
fchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=FlexiChains.VNChain)
(eltype(mchain[:y]), eltype(fchain[:y]))</code></pre><p>In general, this doesn&#39;t cause problems with functions like <code>predict</code> because Distributions.jl kindly allows you to call <code>logpdf(::Poisson, x::Float64)</code> and returns the correct value if <code>isinteger(x)</code>. In fact, this is true of all discrete univariate distributions in Distributions.jl. But if you were to define your own discrete distribution, you would have to remember to implement this method, or else you would get an error when trying to use things like <code>predict</code>.</p><h2 id="Missing-data"><a class="docs-heading-anchor" href="#Missing-data">Missing data</a><a id="Missing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data" title="Permalink"></a></h2><p>Okay, maybe the above is still quite abstract. (For us, it&#39;s not: we actually ran into a bug with Turing&#39;s test suite once because of this very issue.) But after all, if it works for everything in Distributions, surely we&#39;re fine?</p><p>Consider the case where some data is missing:</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model function f()
    x ~ Normal()
    if x &gt; 0
        y ~ Normal(x)
    end
end

mchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=MCMCChains.Chains)
fchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=FlexiChains.VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50-element Vector{Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}}:
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.6327762377562545, y =&gt; -0.34720136411667235), -2.518258000030132, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.6327762377562545, y =&gt; -0.34720136411667235), -2.518258000030132, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.3719817960998872), -0.9881237615195217, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.3719817960998872), -0.9881237615195217, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.3719817960998872), -0.9881237615195217, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.8107157860698893), -1.247568576096132, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.02294530265801235), -0.9192017766617067, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.02294530265801235), -0.9192017766617067, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.0767911967117383), -1.4986781738626216, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.29470466415926244), -0.9623639527432846, 0.0, NamedTuple())
 ⋮
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.0037048609694152), -1.4226502571714894, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.0037048609694152), -1.4226502571714894, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.3586484219613388), -1.8419013004536908, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.3586484219613388), -1.8419013004536908, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.3586484219613388), -1.8419013004536908, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.3586484219613388), -1.8419013004536908, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.3586484219613388), -1.8419013004536908, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.3586484219613388), -1.8419013004536908, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.3586484219613388), -1.8419013004536908, 0.0, NamedTuple())</code></pre><p>In some samples, <code>y</code> will be present and not in others. Because MCMCChains forces all parameters to be in the same array, this means that the entire array must have an element type of <code>Union{Missing, Float64}</code>. With MCMCChains this gets propagated to all parameters, even those that are never missing, such as <code>x</code>.</p><pre><code class="language- hljs">(eltype(mchain[:x]), eltype(fchain[:x]))</code></pre><p>Okay, maybe you don&#39;t ever have such weird models. It turns out though that you can still run into this. In Turing&#39;s MCMC sampling, the first step is not an actual MCMC step, but rather just the initial parameters (either sampled or provided by the user). Thus, there are no &#39;sampler statistics&#39; for the first step, and these are stored as <code>missing</code> in MCMCChains. That means that all the parameters become <code>Union{Missing, Float64}</code>!</p><h2 id="Arbitrary-types"><a class="docs-heading-anchor" href="#Arbitrary-types">Arbitrary types</a><a id="Arbitrary-types-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrary-types" title="Permalink"></a></h2><p><a href="https://turinglang.org/docs/usage/tracking-extra-quantities/">Turing provides this very nice operator <code>:=</code></a>, which lets you store arbitrary values in the chain during an MCMC run.</p><p>The problem with MCMCChains is, as ever, you can only store things that are <code>Real</code> or some array thereof. Even a simple string will fail:</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model function hasstring()
    x ~ Normal()
    y := &quot;$x&quot;
end
mchain = sample(Xoshiro(468), hasstring(), MH(), 50; chain_type=MCMCChains.Chains, progress=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MethodError: no method matching MCMCChains.Chains(::Matrix{Any}, ::Vector{Symbol}, ::@NamedTuple{internals::Vector{Symbol}}; evidence::Missing, info::@NamedTuple{varname_to_symbol::OrderedCollections.OrderedDict{VarName, Symbol}, start_time::Float64, stop_time::Float64}, start::Int64, thin::Int64)
The type `MCMCChains.Chains` exists, but no method is defined for this combination of argument types when trying to construct it.

Closest candidates are:
  MCMCChains.Chains(!Matched::AbstractArray{&lt;:Union{Missing, Real}, 3}, ::AbstractVector{Symbol}, ::Any; start, thin, iterations, evidence, info)
   @ MCMCChains ~/.julia/packages/MCMCChains/ZUYyp/src/chains.jl:28
  MCMCChains.Chains(!Matched::AbstractArray{&lt;:Union{Missing, Real}, 3}, ::AbstractVector, ::Any...; kwargs...)
   @ MCMCChains ~/.julia/packages/MCMCChains/ZUYyp/src/chains.jl:18
  MCMCChains.Chains(!Matched::AbstractMatrix{&lt;:Union{Missing, Real}}, ::Any...; kwargs...)
   @ MCMCChains ~/.julia/packages/MCMCChains/ZUYyp/src/chains.jl:14
  ...</code></pre><p>FlexiChains will let you store anything you like. String? No problem. ODE solver output? No problem.</p><pre><code class="language-julia hljs">fchain = sample(Xoshiro(468), hasstring(), MH(), 50; chain_type=FlexiChains.VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50-element Vector{Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}}:
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.0740437565595174, y =&gt; &quot;-0.0740437565595174&quot;), -0.9216797721473953, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.6327762377562545, y =&gt; &quot;0.6327762377562545&quot;), -1.1191414167391527, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 1.6115229499167665, y =&gt; &quot;1.6115229499167665&quot;), -2.2174416422588914, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.11920608730988999, y =&gt; &quot;0.11920608730988999&quot;), -0.9260435788305393, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 1.501023386794385, y =&gt; &quot;1.501023386794385&quot;), -2.0454741370565155, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.20318141265857553, y =&gt; &quot;-0.20318141265857553&quot;), -0.9395798764296399, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.07028870940645648, y =&gt; &quot;0.07028870940645648&quot;), -0.9214087845396854, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.29864819524237707, y =&gt; &quot;-0.29864819524237707&quot;), -0.9635339054654373, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.8107157860698893, y =&gt; &quot;-0.8107157860698893&quot;), -1.247568576096132, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -1.134858899633543, y =&gt; &quot;-1.134858899633543&quot;), -1.5628908942434006, 0.0, NamedTuple())
 ⋮
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -2.4595027455792295, y =&gt; &quot;-2.4595027455792295&quot;), -3.943515410960557, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.7014980158676153, y =&gt; &quot;-0.7014980158676153&quot;), -1.1649882663377733, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.8191370032266061, y =&gt; &quot;0.8191370032266061&quot;), -1.2544312482322053, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.07832879312548462, y =&gt; &quot;-0.07832879312548462&quot;), -0.9220062331209202, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.08587068631749172, y =&gt; &quot;-0.08587068631749172&quot;), -0.9226254205889913, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.27915664170268856, y =&gt; &quot;-0.27915664170268856&quot;), -0.9579027485080344, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; -0.30656188402794105, y =&gt; &quot;-0.30656188402794105&quot;), -0.9659286275740532, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.5443657513412752, y =&gt; &quot;0.5443657513412752&quot;), -1.0671055688213482, 0.0, NamedTuple())
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; 0.0536750474175961, y =&gt; &quot;0.0536750474175961&quot;), -0.9203790385623134, 0.0, NamedTuple())</code></pre><h2 id="Reconstructing-parameters"><a class="docs-heading-anchor" href="#Reconstructing-parameters">Reconstructing parameters</a><a id="Reconstructing-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-parameters" title="Permalink"></a></h2><p>Suppose you have some array-valued parameter.</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model lkj() = x ~ LKJCholesky(3, 2.0)

mchain = sample(Xoshiro(468), lkj(), NUTS(), 50; chain_type=MCMCChains.Chains);
fchain = sample(Xoshiro(468), lkj(), NUTS(), 50; chain_type=FlexiChains.VNChain);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50-element Vector{Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}}:
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.26655691549952465 0.963819179514176 0.0; -0.5644720607711801 0.045408290855542655 0.8242022687000538], &#39;L&#39;, 0)), -1.112716678323346, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.8595053195525052, log_density = -1.7649223957640388, hamiltonian_energy = 2.2675404004747883, hamiltonian_energy_error = 0.22095755452325472, max_hamiltonian_energy_error = 0.25261709987700387, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.5310092231838637 0.8473660394974947 0.0; -0.367416867884375 -0.31063690902914254 0.8766467680559006], &#39;L&#39;, 0)), -1.3756531728020382, 0.0, (n_steps = 7, is_accept = true, acceptance_rate = 0.8394954513892214, log_density = -2.0427105751088463, hamiltonian_energy = 3.5311395921154993, hamiltonian_energy_error = 0.1356780882904025, max_hamiltonian_energy_error = 0.27059906617577933, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.5230324077499445 0.8523127949545846 0.0; 0.3728229414598638 0.20210943566665476 0.9056240005298674], &#39;L&#39;, 0)), -1.2931505450929017, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 1.0, log_density = -1.8858446763330758, hamiltonian_energy = 2.2397352018400016, hamiltonian_energy_error = -0.03386760849274584, max_hamiltonian_energy_error = -0.2118025734254947, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.020335015063841687 0.9997932222026479 0.0; 0.26593129146631617 -0.6292182169433862 0.7303184125336311], &#39;L&#39;, 0)), -1.2446530524362176, 0.0, (n_steps = 11, is_accept = true, acceptance_rate = 0.9668341534112913, log_density = -1.91028826570968, hamiltonian_energy = 2.7374425534079148, hamiltonian_energy_error = -0.06308068264357214, max_hamiltonian_energy_error = -0.2340451171571063, tree_depth = 3, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.8517004630635978 0.5240289316605076 0.0; 0.23091666102990807 0.18902336129740907 0.954435783351938], &#39;L&#39;, 0)), -2.6473783191392077, 0.0, (n_steps = 7, is_accept = true, acceptance_rate = 0.63493331316967, log_density = -4.060463315800689, hamiltonian_energy = 5.357580262043989, hamiltonian_energy_error = 0.5558709556830728, max_hamiltonian_energy_error = 0.6691468529136335, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.10131301845023818 0.9948545985683042 0.0; -0.21766991131129773 -0.5051501462375907 0.8351306122193538], &#39;L&#39;, 0)), -0.9912936809978619, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 1.0, log_density = -1.3862150369842219, hamiltonian_energy = 4.071162354908, hamiltonian_energy_error = -0.6413138373259653, max_hamiltonian_energy_error = -0.6413138373259653, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.1317116087091325 0.9912880772667713 0.0; 0.1821297384759965 -0.3135082452456973 0.9319556526603767], &#39;L&#39;, 0)), -0.7826737151102121, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.9982985892302172, log_density = -0.9579809410401979, hamiltonian_energy = 1.6136588666867264, hamiltonian_energy_error = -0.08510684505084143, max_hamiltonian_energy_error = -0.08968931222880583, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.20277912615685112 0.9792245023461494 0.0; 0.47348687913040943 0.3900623769329704 0.7897224305999838], &#39;L&#39;, 0)), -1.150613870138363, 0.0, (n_steps = 7, is_accept = true, acceptance_rate = 0.8604035596101401, log_density = -1.7916737615298075, hamiltonian_energy = 2.3304733975545453, hamiltonian_energy_error = 0.20534134000055193, max_hamiltonian_energy_error = 0.2278139242883186, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.11693425975663753 0.9931396572965794 0.0; 0.12300418846668632 0.4364027543481473 0.8913038795029461], &#39;L&#39;, 0)), -0.8662749976793891, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.9677312452583463, log_density = -1.1178055027259743, hamiltonian_energy = 2.3340712731411086, hamiltonian_energy_error = -0.179498480616481, max_hamiltonian_energy_error = -0.2888058962282489, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.7174328768696746 0.6966276388333312 0.0; -0.5786587786121092 0.38049544349244696 0.7213717733711432], &#39;L&#39;, 0)), -2.3531973510451847, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.4754109791011616, log_density = -3.933275448501869, hamiltonian_energy = 4.978623211375075, hamiltonian_energy_error = 0.7641813755136209, max_hamiltonian_energy_error = 0.7874766345504263, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 ⋮
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.056846540649590355 0.9983829279470751 0.0; 0.7328207537840303 -0.549068991821507 0.4018668747776053], &#39;L&#39;, 0)), -2.443607285857456, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.48316818694941016, log_density = -4.6551553213969274, hamiltonian_energy = 5.116921316186184, hamiltonian_energy_error = 0.7936923158747682, max_hamiltonian_energy_error = 0.7936923158747682, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.39293207727305646 0.9195674976041077 0.0; -0.06399208952465367 0.05968949737968772 0.9961637297055282], &#39;L&#39;, 0)), -0.8747261257610087, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 1.0, log_density = -1.0521687800905792, hamiltonian_energy = 4.358620124922847, hamiltonian_energy_error = -0.7625820317173906, max_hamiltonian_energy_error = -0.7625820317173906, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.1823464403962008 0.9832343442307305 0.0; -0.2070284406469261 -0.22608073839123707 0.9518543609669367], &#39;L&#39;, 0)), -0.764893185072686, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.9980616572200041, log_density = -0.9192984505951131, hamiltonian_energy = 1.2468942955484759, hamiltonian_energy_error = -0.0338919036200358, max_hamiltonian_energy_error = -0.0338919036200358, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.20979038863912003 0.9777463847208268 0.0; 0.7924448448840293 0.33712140086423953 0.5083112519864765], &#39;L&#39;, 0)), -2.0363208633708387, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.6275348163844218, log_density = -3.9290422475941185, hamiltonian_energy = 3.97874317618065, hamiltonian_energy_error = 0.6749140235540749, max_hamiltonian_energy_error = 0.6749140235540749, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.32414204834778504 0.9460084209418552 0.0; 0.5535487409577037 0.47913089872672965 0.6811882069365686], &#39;L&#39;, 0)), -1.5498280482129174, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 1.0, log_density = -2.611610561264789, hamiltonian_energy = 4.044208797529123, hamiltonian_energy_error = -0.18521797548892138, max_hamiltonian_energy_error = -0.5662530774499244, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.3699098877109095 0.9290676374590293 0.0; -0.431198739252221 0.7058210246687989 0.5620358782166686], &#39;L&#39;, 0)), -1.9885837281366494, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.969378776962896, log_density = -3.3909662879057874, hamiltonian_energy = 4.370757163840806, hamiltonian_energy_error = 0.09636076750081113, max_hamiltonian_energy_error = -0.20413055937530888, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.026290180876000425 0.9996543534589879 0.0; 0.16718616932723482 0.01606731730138103 0.9857944137092793], &#39;L&#39;, 0)), -0.6451353599699876, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.9436121109442833, log_density = -0.6886163183585251, hamiltonian_energy = 4.369994387576003, hamiltonian_energy_error = -0.7177474975008868, max_hamiltonian_energy_error = -0.7177474975008868, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.026290180876000425 0.9996543534589879 0.0; 0.16718616932723482 0.01606731730138103 0.9857944137092793], &#39;L&#39;, 0)), -0.6451353599699876, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.28842689108222114, log_density = -0.6886163183585251, hamiltonian_energy = 5.413099168596178, hamiltonian_energy_error = 0.0, max_hamiltonian_energy_error = 1.3490737333687868, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))
 Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{n_steps::Int64, is_accept::Bool, acceptance_rate::Float64, log_density::Float64, hamiltonian_energy::Float64, hamiltonian_energy_error::Float64, max_hamiltonian_energy_error::Float64, tree_depth::Int64, numerical_error::Bool, step_size::Float64, nom_step_size::Float64}}(OrderedCollections.OrderedDict{VarName, Any}(x =&gt; LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.6845648829608733 0.7289519332691051 0.0; -0.4132291390236351 0.002382763026700631 0.910623962512597], &#39;L&#39;, 0)), -1.7511762737396905, 0.0, (n_steps = 3, is_accept = true, acceptance_rate = 0.7422080774112043, log_density = -2.66434354303677, hamiltonian_energy = 2.8608617225673947, hamiltonian_energy_error = 0.4987680002599326, max_hamiltonian_energy_error = 0.4987680002599326, tree_depth = 2, numerical_error = false, step_size = 0.45463289188269185, nom_step_size = 0.45463289188269185))</code></pre><p>With FlexiChains the Cholesky samples are kept together:</p><pre><code class="language- hljs">fchain[@varname(x)][iter=1, chain=1]</code></pre><p>Because MCMCChains stores <em>all</em> its data in a single array, it has to flatten this parameter, so good luck trying to reconstruct it.</p><pre><code class="language-julia hljs">(mchain[Symbol(&quot;x.L[1, 1]&quot;)][1, 1], mchain[Symbol(&quot;x.L[2, 1]&quot;)][1, 1]) # ...</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.0, 0.26655691549952465)</code></pre><p>Of course, if you really wanted to flatten a chain, FlexiChains lets you do that with <a href="../api/#FlexiChains.split_varnames"><code>FlexiChains.split_varnames</code></a>.</p><h2 id="VarNames-as-keys"><a class="docs-heading-anchor" href="#VarNames-as-keys">VarNames as keys</a><a id="VarNames-as-keys-1"></a><a class="docs-heading-anchor-permalink" href="#VarNames-as-keys" title="Permalink"></a></h2><p>Did you notice in that last line we had to write something like <code>Symbol(&quot;x.L[1, 1]&quot;)</code>? And since it&#39;s a <code>Symbol</code>, we <em>have</em> to get the name exactly right, we couldn&#39;t do (for example) <code>x.L[1,1]</code> without the space after the comma?</p><p>That&#39;s because MCMCChains uses AxisArrays.jl under the hood, which allows you to index into the chain using <code>Symbol</code>s — but <em>only</em> <code>Symbol</code>s. FlexiChains retains the original <code>VarName</code>s used by Turing, which is a far richer type and allows you to use keys that actually carry meaning, rather than just being strings that <em>have</em> to match exactly.</p><pre><code class="language- hljs">fchain[@varname(x.L[1,1])][iter=1, chain=1] # No space!</code></pre><pre><code class="language- hljs">fchain[@varname(x.L[:, 1])][iter=1, chain=1] # Index into `x` any way you like</code></pre><h2 id="Performance-(on-important-things)"><a class="docs-heading-anchor" href="#Performance-(on-important-things)">Performance (on important things)</a><a id="Performance-(on-important-things)-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-(on-important-things)" title="Permalink"></a></h2><p>In the following model, <code>y</code> is a single parameter that is a vector of length <code>N</code>. That means that when you use functions like <code>returned</code> or <code>predict</code> on a chain, MCMCChains has to <em>somehow</em> reconstruct the vector <code>y</code> from its components which are all stored separately.</p><pre><code class="language-julia hljs">using Turing, FlexiChains, MCMCChains, Random

@model function longvec(N)
    m ~ Normal(0)
    y ~ filldist(Normal(m), N)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">longvec (generic function with 2 methods)</code></pre><p>It turns out that if <code>N</code> is small, MCMCChains does just fine, and is in fact even faster than FlexiChains (because constructing a FlexiChain has more overhead).</p><pre><code class="language- hljs">using Chairmarks: @be

function benchmark(N)
    model = (longvec(N) | (y = rand(Xoshiro(468), Normal(2.0), N),))
    mchain = sample(Xoshiro(468), model, NUTS(), 500; chain_type=MCMCChains.Chains);
    fchain = sample(Xoshiro(468), model, NUTS(), 500; chain_type=FlexiChains.VNChain);
    mt = @be predict(longvec(N), mchain)
    ft = @be predict(longvec(N), fchain)
    return (N=N, mcmcchains=median(mt).time, flexichains=median(ft).time)
end

benchmark(2) # The results are in seconds</code></pre><p>But MCMCChains scales really poorly with <code>N</code>.</p><pre><code class="language- hljs">benchmark(1000)</code></pre><h2 id="Avoiding-name-clashes"><a class="docs-heading-anchor" href="#Avoiding-name-clashes">Avoiding name clashes</a><a id="Avoiding-name-clashes-1"></a><a class="docs-heading-anchor-permalink" href="#Avoiding-name-clashes" title="Permalink"></a></h2><p>All of Turing.jl&#39;s samplers include some &#39;sampler statistics&#39; in the output chain. These are pretty useful things like the step size, whether a transition was accepted, the log-probabilities, and so on.</p><p>But if you have a parameter that <em>just happens</em> to share a name with these, then MCMCChains will make it pretty hard for you to get one of them.</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

# Oops! This will clash with the actual log prior.
@model pr() = logprior ~ Normal()

mchain = sample(Xoshiro(468), pr(), MH(), 50; chain_type=MCMCChains.Chains);
collect(keys(mchain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Symbol}:
 :logprior
 :lp
 :logprior
 :loglikelihood</code></pre><p>There are two columns labelled <code>:logprior</code>. Of course, one is your parameter, the other is the actual log prior probability. It&#39;s a mystery which one is which, and which you get when you do <code>mchain[:logprior]</code>! You could avoid this if you knew exactly which keys the sampler returns, but in general this isn&#39;t documented anywhere. (It <em>should</em> be, of course.)</p><p>FlexiChains avoids clashes by completely separating <code>Parameter</code> and <code>Extra</code> keys, meaning that you can use any name you like without worrying about a rogue sampler breaking your workflow.</p><h2 id="DimensionalData.jl-indexing"><a class="docs-heading-anchor" href="#DimensionalData.jl-indexing">DimensionalData.jl indexing</a><a id="DimensionalData.jl-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#DimensionalData.jl-indexing" title="Permalink"></a></h2><p>As you will have noticed, FlexiChains uses DimensionalData.jl to return information-rich matrices. That means that you can <a href="../indexing/">use all the selectors from DimensionalData.jl</a> to extract exactly what you want. Don&#39;t want to use those? No problem; good old 1-based indices work fine too.</p><h2 id="If-you&#39;re-a-Turing-developer..."><a class="docs-heading-anchor" href="#If-you&#39;re-a-Turing-developer...">If you&#39;re a Turing developer...</a><a id="If-you&#39;re-a-Turing-developer...-1"></a><a class="docs-heading-anchor-permalink" href="#If-you&#39;re-a-Turing-developer..." title="Permalink"></a></h2><p>I suppose I am somewhat qualified to comment on this... There are a number of places in TuringLang where the unfaithful data structure of MCMCChains leads to hacky workarounds. Most of them centre around the difficulty of reconstructing vectors <code>x</code> from its flattened components <code>x[1]</code>, <code>x[2]</code>, and so on.</p><p>For example, <a href="https://github.com/TuringLang/AbstractPPL.jl/blob/v0.13.5/ext/AbstractPPLDistributionsExt.jl">AbstractPPLDistributionsExt</a> exists <em>solely</em> for this reason. (None of us are particularly happy about this: see <a href="https://github.com/TuringLang/AbstractPPL.jl/pull/125">this PR</a>.) The methods defined here allow you to check whether a dictionary like <code>Dict(@varname(x[1]) =&gt; 1.0, @varname(x[2]) =&gt; 2.0)</code> can be reconstructed into a vector-valued parameter <code>x</code>, <em>given</em> that <code>x</code> is drawn from <code>MvNormal(zeros(2), I)</code>. This is precisely because we can only obtain the former dictionary from MCMCChains, but when evaluating a model we need the latter.</p><p>On top of that, MCMCChains doesn&#39;t store the keys as <code>VarName</code>s: it stores them as <code>Symbol</code>s. That means that any time we need to retrieve the original <code>VarName</code>s, we need to use a secret dictionary that is stored inside <code>chain.info</code>. This is <a href="https://github.com/TuringLang/Turing.jl/blob/cabe73fd07b3ddb37b51f6c0c9db66891e179f3c/src/mcmc/Inference.jl#L351-L353">automatically included when sampling using Turing</a>, but it makes it somewhat frustrating to test MCMCChains-related functionality in isolation. In general, though, this is a very fragile solution and relies on Turing &#39;just happening&#39; to do the right thing.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« Public API</a><a class="docs-footer-nextpage" href="../whynot/">Why not FlexiChains? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 22 October 2025 17:32">Wednesday 22 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
