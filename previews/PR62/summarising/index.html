<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Summarising · FlexiChains.jl</title><meta name="title" content="Summarising · FlexiChains.jl"/><meta property="og:title" content="Summarising · FlexiChains.jl"/><meta property="twitter:title" content="Summarising · FlexiChains.jl"/><meta name="description" content="Documentation for FlexiChains.jl."/><meta property="og:description" content="Documentation for FlexiChains.jl."/><meta property="twitter:description" content="Documentation for FlexiChains.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexiChains.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../turing/">Usage with Turing.jl</a></li><li class="is-active"><a class="tocitem" href>Summarising</a><ul class="internal"><li><a class="tocitem" href="#Unsupported-data-types"><span>Unsupported data types</span></a></li><li><a class="tocitem" href="#Overall-summary-statistics"><span>Overall summary statistics</span></a></li><li><a class="tocitem" href="#Individual-statistics"><span>Individual statistics</span></a></li><li><a class="tocitem" href="#Custom-statistics"><span>Custom statistics</span></a></li></ul></li><li><a class="tocitem" href="../indexing/">Indexing</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../integrations/">Integrations with other packages</a></li><li><a class="tocitem" href="../api/">Public API</a></li><li><a class="tocitem" href="../why/">Why FlexiChains?</a></li><li><a class="tocitem" href="../whynot/">Why not FlexiChains?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Summarising</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Summarising</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl/blob/main/docs/src/summarising.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Summarising"><a class="docs-heading-anchor" href="#Summarising">Summarising</a><a id="Summarising-1"></a><a class="docs-heading-anchor-permalink" href="#Summarising" title="Permalink"></a></h1><p>In general a <code>FlexiChain</code> contains data in matrices of size <code>(niters, nchains)</code>. Often it is useful to summarise this data along one or both dimensions.</p><p>FlexiChains allows you to calculate one or more statistics for each variable stored in a <code>FlexiChain</code>. The result is a <code>FlexiSummary</code> object, which can be indexed into in a very similar way to <code>FlexiChain</code>s: see <a href="../indexing/">the Indexing page</a> for full details, or the examples on this page.</p><h2 id="Unsupported-data-types"><a class="docs-heading-anchor" href="#Unsupported-data-types">Unsupported data types</a><a id="Unsupported-data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Unsupported-data-types" title="Permalink"></a></h2><p>Before we launch into the available summary statistics, it is worth mentioning one point about data types. Since FlexiChains allows for storage of completely arbitrary data types, it can contain data for which the mean (or other statistic) is not defined. For example, the mean of <code>String</code> values is not defined. In such cases, the key will be silently dropped from the result, and a warning issued (you can suppress the warning by passing the <code>warn=false</code> keyword argument).</p><p>If multiple summary statistics are requested (e.g. with <a href="#StatsBase.summarystats-Tuple{FlexiChains.FlexiChain}"><code>summarystats</code></a>), the key is only dropped if <em>all</em> of them fail. If at least one statistic is successfully computed for a key, that key will be included in the result, with <code>missing</code> values for the statistics that failed.</p><p>To give a flavour of how this works, here is an example:</p><pre><code class="language-julia hljs">using FlexiChains, Turing

@model function f()
    f ~ Normal()               # float
    v ~ MvNormal(zeros(2), I)  # vector
    s := &quot;a string&quot;            # string
end

chain = sample(f(), MH(), MCMCThreads(), 20, 3; chain_type=VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}}}:
 [Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.1618477068287552, v =&gt; [-0.5872452734042903, 1.188409862435233], s =&gt; &quot;a string&quot;), -4.310348152680142, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.11928842193494052, v =&gt; [-0.14716050917566648, 0.23465293344718793], s =&gt; &quot;a string&quot;), -2.8022895707359883, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.9268695698636876, v =&gt; [0.19160164679234318, -0.21154318418159548], s =&gt; &quot;a string&quot;), -3.22709005429728, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.4662231466582108, v =&gt; [0.7657068328462808, 1.0728503182244777], s =&gt; &quot;a string&quot;), -3.7341549904448827, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.978422209780088, v =&gt; [-0.5581084849476032, 0.09499456459258439], s =&gt; &quot;a string&quot;), -3.3957251340458154, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.6485768540108937, v =&gt; [0.4298753639468365, 0.9176024611824292], s =&gt; &quot;a string&quot;), -3.4805351200415906, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.2960883318572719, v =&gt; [0.8292268245304837, 0.810052952582895], s =&gt; &quot;a string&quot;), -3.472551205999617, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.8240978192357471, v =&gt; [-0.15362892326158098, 0.8606420583579211], s =&gt; &quot;a string&quot;), -3.4785375067871116, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.1949678106634305, v =&gt; [0.6315257179324921, -1.5379576394598138], s =&gt; &quot;a string&quot;), -4.8528588504663706, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.9204164343973155, v =&gt; [0.21456468903795886, -0.30737518703196937], s =&gt; &quot;a string&quot;), -3.250657561660799, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.867793542469937, v =&gt; [0.09786695487058367, -0.14776828964616057], s =&gt; &quot;a string&quot;), -3.149055119930576, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.42754815140987, v =&gt; [0.40429826544310404, -0.6305260411329936], s =&gt; &quot;a string&quot;), -3.128724398494591, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.11469617053729048, v =&gt; [-1.379437770746219, -0.033635181342170806], s =&gt; &quot;a string&quot;), -3.7153831497745875, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.7991399890280233, v =&gt; [-1.149298097943847, 0.9722606932502447], s =&gt; &quot;a string&quot;), -5.508356436462291, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.8933692030692477, v =&gt; [0.3108864607293372, -1.825659401923788], s =&gt; &quot;a string&quot;), -4.8707111877590785, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.5815116644313074, v =&gt; [0.459669612015505, -0.041792492296197914], s =&gt; &quot;a string&quot;), -3.0324148898602594, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 1.0072873733546515, v =&gt; [-0.23624333096698466, 0.9145238251947357], s =&gt; &quot;a string&quot;), -3.7102118950114686, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.9259714341704, v =&gt; [-0.13552542090557107, 1.4750305778572335], s =&gt; &quot;a string&quot;), -4.282568320726551, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.15755930879986804, v =&gt; [0.01362899601325511, 0.752915428236589], s =&gt; &quot;a string&quot;), -3.0527617633132724, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.0914087826751804, v =&gt; [1.0163327542939364, 1.5703869070471808], s =&gt; &quot;a string&quot;), -5.101925817702233, 0.0, NamedTuple())]
 [Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.2825582320407498, v =&gt; [-0.06523037577528594, -0.5501114082375331], s =&gt; &quot;a string&quot;), -2.950173958559449, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.8391336760703266, v =&gt; [-0.5167462051448939, -0.9878520192540972], s =&gt; &quot;a string&quot;), -3.730327389009691, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.4306974631293982, v =&gt; [-0.7425541402739521, -0.8752986277125844], s =&gt; &quot;a string&quot;), -3.5083329214438286, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.7016070077525624, v =&gt; [-0.798614867127118, -2.2500332421046205], s =&gt; &quot;a string&quot;), -5.853159444563918, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 1.101439380303267, v =&gt; [1.850190806439094, 1.0854800524652148], s =&gt; &quot;a string&quot;), -5.664136436121256, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 1.2095164618980476, v =&gt; [-0.04559539460457902, -1.2545649309341718], s =&gt; &quot;a string&quot;), -4.276286688384709, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.1052367120790451, v =&gt; [0.2585935875661943, -0.1834097075703666], s =&gt; &quot;a string&quot;), -2.8126078645793235, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 1.8745939033457433, v =&gt; [-0.9290722943095651, -1.4894177099532238], s =&gt; &quot;a string&quot;), -6.054636972232505, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.3687067682644278, v =&gt; [0.6338289894596384, 0.695977502716983], s =&gt; &quot;a string&quot;), -4.1365566444442425, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.5500986452791403, v =&gt; [0.20240454227994797, 0.7525943961715567], s =&gt; &quot;a string&quot;), -4.261901466604324, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.4768121217153007, v =&gt; [0.08861400926668137, 1.429803359410625], s =&gt; &quot;a string&quot;), -3.896585543931454, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.6119898570189695, v =&gt; [0.0550393407542262, -0.40609809445345707], s =&gt; &quot;a string&quot;), -3.028053887835762, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.20996668720214728, v =&gt; [0.07574147994510272, 0.4270351496255855], s =&gt; &quot;a string&quot;), -2.872906499881351, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.9338878169177552, v =&gt; [0.4389232462667502, -1.0445910229349633], s =&gt; &quot;a string&quot;), -3.8348008375625513, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.44962211130130525, v =&gt; [-0.532586481625269, 1.7829912937606096], s =&gt; &quot;a string&quot;), -4.589248778117598, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.40368898088719, v =&gt; [-0.8681339765463334, -0.0965764693172449], s =&gt; &quot;a string&quot;), -3.2197898040888546, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.123376426312933, v =&gt; [-0.3330529586719831, 0.6878810526844238], s =&gt; &quot;a string&quot;), -3.679855205173023, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -2.4103444386190764, v =&gt; [-0.605968821315163, 1.0379996339945106], s =&gt; &quot;a string&quot;), -6.384016482294387, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.0954870528432101, v =&gt; [2.6858070426218803, 0.27508643652637954], s =&gt; &quot;a string&quot;), -7.001477549966605, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.7754562774751438, v =&gt; [0.1578061683605426, -0.3275448206150388], s =&gt; &quot;a string&quot;), -3.1235760168940088, 0.0, NamedTuple())]
 [Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.30402911291738144, v =&gt; [0.06508592826480147, -0.29146369093905655], s =&gt; &quot;a string&quot;), -2.8476260809616374, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.9597065531583628, v =&gt; [0.6756245061347059, -0.4880108141824351], s =&gt; &quot;a string&quot;), -3.5646454477259555, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.7567770846809052, v =&gt; [-0.9592163649477696, 0.2685536213951454], s =&gt; &quot;a string&quot;), -3.539279918737113, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.1925708005525566, v =&gt; [-0.904368516774146, 1.2091935203029898], s =&gt; &quot;a string&quot;), -4.607943848616804, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.0638521122019357, v =&gt; [0.9661327603972065, -1.4596269560190214], s =&gt; &quot;a string&quot;), -4.290815826455383, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.7329277766908786, v =&gt; [0.4905185175448262, 0.6772783271059247], s =&gt; &quot;a string&quot;), -3.3750643367474225, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.5011818674775885, v =&gt; [0.17407167892923242, -0.34790381725310315], s =&gt; &quot;a string&quot;), -2.958076239490441, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.5390665863094224, v =&gt; [-0.30119877434921566, -0.4893834361356968], s =&gt; &quot;a string&quot;), -3.067220416468391, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.7992390565615616, v =&gt; [-0.21390045943350727, -0.6027382983648967], s =&gt; &quot;a string&quot;), -3.280730565811564, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.141772516912389, v =&gt; [0.9683716273274017, -0.45696569188094527], s =&gt; &quot;a string&quot;), -3.9819184658867197, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.7822553355314931, v =&gt; [1.767476320748389, 0.007323714796414064], s =&gt; &quot;a string&quot;), -4.624790395200104, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.2089052951198755, v =&gt; [-0.18466119850929794, 0.9928921346405958], s =&gt; &quot;a string&quot;), -3.2886035854116042, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.8722229492255588, v =&gt; [0.5987681076186648, -0.13537508878069962], s =&gt; &quot;a string&quot;), -3.325626866873694, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 1.1807931911118332, v =&gt; [-0.20739305414054537, -0.9389149939499116], s =&gt; &quot;a string&quot;), -3.9162385020869044, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.10586903028815779, v =&gt; [0.23843992258698493, 0.9822526821438378], s =&gt; &quot;a string&quot;), -3.273256689532121, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -1.8071422704810869, v =&gt; [1.134163369126472, 0.9200496905500568], s =&gt; &quot;a string&quot;), -5.45610618296857, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; 0.8937796382148924, v =&gt; [-0.9608094146228637, 1.8148228112005735], s =&gt; &quot;a string&quot;), -5.264604904098731, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.6862720472413606, v =&gt; [2.6005789027219053, 1.4656632809708383], s =&gt; &quot;a string&quot;), -7.447890002260678, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.8906035509850936, v =&gt; [-0.0939562867647646, -1.2280169118626825], s =&gt; &quot;a string&quot;), -3.9118296019493384, 0.0, NamedTuple()), Turing.Inference.Transition{OrderedCollections.OrderedDict{VarName, Any}, Float64, @NamedTuple{}}(OrderedCollections.OrderedDict{VarName, Any}(f =&gt; -0.5455071086215187, v =&gt; [0.028592920595935205, 0.0976747305635245], s =&gt; &quot;a string&quot;), -2.9107835564417543, 0.0, NamedTuple())]</code></pre><h2 id="Overall-summary-statistics"><a class="docs-heading-anchor" href="#Overall-summary-statistics">Overall summary statistics</a><a id="Overall-summary-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Overall-summary-statistics" title="Permalink"></a></h2><p>If you want a quick overview of what&#39;s in your chain, <a href="#StatsBase.summarystats-Tuple{FlexiChains.FlexiChain}"><code>summarystats</code></a> provides a handy selection of commonly used statistics:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.summarystats-Tuple{FlexiChains.FlexiChain}" href="#StatsBase.summarystats-Tuple{FlexiChains.FlexiChain}"><code>StatsBase.summarystats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StatsBase.summarystats(
    chain::FlexiChain{TKey};
    split_varnames::Bool=(TKey&lt;:VarName),
    warn::Bool=false,
) where {TKey}</code></pre><p>Compute a standard set of summary statistics for each key in the <code>chain</code>. The statistics include:</p><ul><li>mean (using <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.mean"><code>Statistics.mean</code></a>)</li><li>standard deviation (<a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.std"><code>Statistics.std</code></a>)</li><li>Monte Carlo standard error (<a href="https://turinglang.org/MCMCDiagnosticTools.jl/stable/#MCMCDiagnosticTools.mcse"><code>MCMCDiagnosticTools.mcse</code></a>)</li><li>bulk effective sample size (<a href="https://turinglang.org/MCMCDiagnosticTools.jl/stable/#MCMCDiagnosticTools.ess"><code>MCMCDiagnosticTools.ess</code></a>)</li><li>tail effective sample size</li><li>R-hat diagnostic (<a href="https://turinglang.org/MCMCDiagnosticTools.jl/stable/#MCMCDiagnosticTools.rhat"><code>MCMCDiagnosticTools.rhat</code></a>)</li><li>5th, 50th (median), and 95th percentiles (<a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.quantile"><code>Statistics.quantile</code></a>)</li></ul><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>If any of the statistics cannot be computed for a key, a <code>missing</code> value is returned. If <em>none</em> of the statistics can be computed for a key, that key will be dropped from the resulting <code>FlexiSummary</code>, and a warning issued. The warning can be suppressed by setting <code>warn=false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L713-L738">source</a></section></article><pre><code class="language- hljs">st = summarystats(chain)</code></pre><p>Note that in the result, the vector-valued <code>v</code> has been broken up into its individual elements <code>v[1]</code> and <code>v[2]</code>. This happens automatically for chains with <code>VarName</code> keys; you can disable this behaviour by passing <code>split_varnames=false</code>.</p><p>You can index with a variable name (or names!) and the <code>stat</code> dimension:</p><pre><code class="language- hljs">st[@varname(v[1]), stat=At(:mean)]  # Mean of first element of vector v</code></pre><div class="admonition is-info" id="At()-55f201556d87b192"><header class="admonition-header">At()<a class="admonition-anchor" href="#At()-55f201556d87b192" title="Permalink"></a></header><div class="admonition-body"><p>Notice to access the <em>mean</em> you have to use <code>stat=At(:mean)</code> rather than just <code>stat=:mean</code>. This seems a bit verbose, but is actually perfectly consistent with DimensionalData.jl&#39;s behaviour: <code>stat=1</code> means the first statistic, and <code>stat=At(:f)</code> means the statistic with the named index <code>:f</code>.</p></div></div><p>For more details on indexing, please see the <a href="../indexing/">Indexing page</a>.</p><h2 id="Individual-statistics"><a class="docs-heading-anchor" href="#Individual-statistics">Individual statistics</a><a id="Individual-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-statistics" title="Permalink"></a></h2><p>Sometimes you may only want to calculate a single statistic.</p><p>The following functions are all overloaded to accept <code>FlexiChain</code> objects. In all cases, they can be called with <code>dims=:both</code>, <code>dims=:iter</code>, or <code>dims=:chain</code> to specify the dimension over which to compute the statistic; the default is <code>dims=:both</code>.</p><p>All of these functions return a <code>FlexiSummary</code> where the <code>:stat</code> dimension has already been collapsed. That means that if you want to access the mean of a variable <code>@varname(a)</code> you don&#39;t need to further use the <code>stat</code> dimension:</p><pre><code class="language- hljs">m = mean(chain)
# Not needed: mean_f = m[@varname(f), stat=At(:mean)]
# Just do:
mean_f = m[@varname(f)]</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{FlexiChains.FlexiChain}" href="#Statistics.mean-Tuple{FlexiChains.FlexiChain}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Statistics.mean(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the mean across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.mean"><code>Statistics.mean</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L606-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median-Tuple{FlexiChains.FlexiChain}" href="#Statistics.median-Tuple{FlexiChains.FlexiChain}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Statistics.median(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the median across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.median-Tuple%7BAbstractVector%7B%3C%3AReal%7D%2C%20AbstractWeights%7D"><code>Statistics.median</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L610-L634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.std-Tuple{FlexiChains.FlexiChain}" href="#Statistics.std-Tuple{FlexiChains.FlexiChain}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Statistics.std(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the standard deviation across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.std"><code>Statistics.std</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L614-L638">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.var-Tuple{FlexiChains.FlexiChain}" href="#Statistics.var-Tuple{FlexiChains.FlexiChain}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Statistics.var(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the variance across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.var"><code>Statistics.var</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L618-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.quantile-Tuple{FlexiChains.FlexiChain, Any}" href="#Statistics.quantile-Tuple{FlexiChains.FlexiChain, Any}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Statistics.quantile(
    chain::FlexiChain{TKey},
    p;
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the quantile across all iterations and chains for each key in the <code>chain</code>. If it cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse.</p><ul><li><code>:iter</code>: collapse the iteration dimension only</li><li><code>:chain</code>: collapse the chain dimension only</li><li><code>:both</code>: collapse both the iteration and chain dimensions (default)</li></ul><p>The argument <code>p</code> specifies the quantile to compute, and is forwarded to <code>Statistics.quantile</code>, along with any other keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L668-L689">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{FlexiChains.FlexiChain}" href="#Base.minimum-Tuple{FlexiChains.FlexiChain}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.minimum(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the minimum across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://docs.julialang.org/en/v1/base/collections/#Base.minimum"><code>Base.minimum</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L622-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{FlexiChains.FlexiChain}" href="#Base.maximum-Tuple{FlexiChains.FlexiChain}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.maximum(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the maximum across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://docs.julialang.org/en/v1/base/collections/#Base.maximum"><code>Base.maximum</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L626-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum-Tuple{FlexiChains.FlexiChain}" href="#Base.sum-Tuple{FlexiChains.FlexiChain}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.sum(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the sum across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Base.sum"><code>Base.sum</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L630-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prod-Tuple{FlexiChains.FlexiChain}" href="#Base.prod-Tuple{FlexiChains.FlexiChain}"><code>Base.prod</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.prod(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the product across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://docs.julialang.org/en/v1/base/collections/#Base.prod"><code>Base.prod</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L634-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MCMCDiagnosticTools.ess-Tuple{FlexiChains.FlexiChain}" href="#MCMCDiagnosticTools.ess-Tuple{FlexiChains.FlexiChain}"><code>MCMCDiagnosticTools.ess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCMCDiagnosticTools.ess(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the effective sample size across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://turinglang.org/MCMCDiagnosticTools.jl/stable/#MCMCDiagnosticTools.ess"><code>MCMCDiagnosticTools.ess</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L638-L662">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MCMCDiagnosticTools.rhat-Tuple{FlexiChains.FlexiChain}" href="#MCMCDiagnosticTools.rhat-Tuple{FlexiChains.FlexiChain}"><code>MCMCDiagnosticTools.rhat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCMCDiagnosticTools.rhat(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the R-hat diagnostic across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://turinglang.org/MCMCDiagnosticTools.jl/stable/#MCMCDiagnosticTools.rhat"><code>MCMCDiagnosticTools.rhat</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L642-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MCMCDiagnosticTools.mcse-Tuple{FlexiChains.FlexiChain}" href="#MCMCDiagnosticTools.mcse-Tuple{FlexiChains.FlexiChain}"><code>MCMCDiagnosticTools.mcse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCMCDiagnosticTools.mcse(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the Monte Carlo standard error across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://turinglang.org/MCMCDiagnosticTools.jl/stable/#MCMCDiagnosticTools.mcse"><code>MCMCDiagnosticTools.mcse</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L646-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.mad-Tuple{FlexiChains.FlexiChain}" href="#StatsBase.mad-Tuple{FlexiChains.FlexiChain}"><code>StatsBase.mad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StatsBase.mad(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the median absolute deviation across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#StatsBase.mad"><code>StatsBase.mad</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L650-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.geomean-Tuple{FlexiChains.FlexiChain}" href="#StatsBase.geomean-Tuple{FlexiChains.FlexiChain}"><code>StatsBase.geomean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StatsBase.geomean(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the geometric mean across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#StatsBase.geomean"><code>StatsBase.geomean</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L654-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.harmmean-Tuple{FlexiChains.FlexiChain}" href="#StatsBase.harmmean-Tuple{FlexiChains.FlexiChain}"><code>StatsBase.harmmean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StatsBase.harmmean(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the harmonic mean across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#StatsBase.harmmean"><code>StatsBase.harmmean</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L658-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.iqr-Tuple{FlexiChains.FlexiChain}" href="#StatsBase.iqr-Tuple{FlexiChains.FlexiChain}"><code>StatsBase.iqr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StatsBase.iqr(
    chain::FlexiChain{TKey};
    dims::Symbol=:both,
    warn::Bool=true,
    split_varnames::Bool=(TKey&lt;:VarName),
    kwargs...
) where {TKey}</code></pre><p>Calculate the interquartile range across all iterations and chains for each key in the <code>chain</code>. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting <code>warn=false</code>).</p><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. The default value of <code>:both</code> collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p>The <code>split_varnames</code> keyword argument, if <code>true</code>, will first split up <code>VarName</code>s in the chain such that each <code>VarName</code> corresponds to a single scalar value. This is only supported for chains with <code>TKey&lt;:VarName</code>.</p><p>Other keyword arguments are forwarded to <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#StatsBase.iqr"><code>StatsBase.iqr</code></a>; please see its documentation for details of supported keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L662-L686">source</a></section></article><p>For highest density intervals and equal-tailed intervals, you will need to load <code>PosteriorStats</code> as these are defined in an extension.</p><h2 id="Custom-statistics"><a class="docs-heading-anchor" href="#Custom-statistics">Custom statistics</a><a id="Custom-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-statistics" title="Permalink"></a></h2><p>There are two scenarios where the above are not enough:</p><ol><li>you want to calculate a specific set of statistics that is not the same as what <code>summarystats</code> does; or</li><li>you want to calculate a completely custom statistic, which is not implemented above.</li></ol><p>In both cases, you can directly use [<code>FlexiChains.collapse</code>] to achieve this. (But in the latter case, please do also consider opening an issue so that we can implement it!)</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlexiChains.collapse" href="#FlexiChains.collapse"><code>FlexiChains.collapse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FlexiChains.collapse(
    chain::FlexiChain,
    funcs::AbstractVector;
    dims::Symbol=:both,
    warn::Bool=true,
    drop_stat_dim::Bool=false,
)</code></pre><p>Low-level function to collapse one or both dimensions of a <code>FlexiChain</code> by applying a list of summary functions.</p><p>The <code>funcs</code> argument must be a vector which contains either:</p><ul><li>tuples of the form <code>(statistic_name::Symbol, func::Function)</code>; or</li><li>just functions, in which case the statistic name is obtained from the function name.</li></ul><p>The <code>dims</code> keyword argument specifies which dimensions to collapse. By default, <code>dims</code> is <code>:both</code>, which collapses both the iteration and chain dimensions. Other valid values are <code>:iter</code> or <code>:chain</code>, which respectively collapse only the iteration or chain dimension.</p><p><strong>The functions in <code>funcs</code> must map a vector to a single value.</strong> For example, both <code>Statistics.mean</code> and <code>Statistics.std</code> satisfy this:</p><pre><code class="language-julia hljs">using FlexiChains: collapse
using Statistics: mean, std

collapse(chn, [mean, std]; dims=:both)</code></pre><p>If <code>dims=:iter</code> or <code>dims=:chain</code> are selected, then the functions are automatically applied to each column or row as appropriate. No adjustment to the functions is necessary:</p><pre><code class="language-julia hljs">collapse(chn, [mean, std]; dims=:iter)
collapse(chn, [mean, std]; dims=:chain)</code></pre><p>For <code>dims=:both</code>, the function is applied to all the samples stacked together as a single vector.</p><p>Sometimes, for more complicated functions like <code>quantile</code>, you have to pass an anonymous function (such as <code>x -&gt; quantile(x, 0.05)</code> or a closure (such as <code>Base.Fix2(quantile, 0.05)</code>). In this case, to get a sensible statistic name, instead of just passing the function you can pass a tuple of the form <code>(statistic_name::Symbol, func::Function)</code>.</p><pre><code class="language-julia hljs">collapse(chn, [
    mean,
    std,
    (:q5, x -&gt; quantile(x, 0.05)),
    (:q95, x -&gt; quantile(x, 0.95)),
])</code></pre><p>If a statistic function errors when applied to a key, that key is skipped and a warning is issued. The warning can be suppressed by setting <code>warn=false</code>.</p><p>If the <code>drop_stat_dim</code> keyword argument is <code>true</code> and only one function is provided in <code>funcs</code>, then the resulting <code>FlexiSummary</code> will have the <code>stat</code> dimension dropped. This allows for easier indexing into the result when only one statistic is computed. It is an error to set <code>drop_stat_dim=true</code> when more than one function is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/penelopeysm/FlexiChains.jl/blob/8d16cb151f325f4316046a9ee5a394570a94cc56/src/summary.jl#L415-L477">source</a></section></article><p>As an example, suppose you have a statistic that calculates the sum of the mean and standard deviation. (This is of course quite contrived: if you have a <em>real</em> example, again, please do open an issue!)</p><p>We start by defining our own function:</p><pre><code class="language-julia hljs">using Statistics

function mean_std_sum(x::AbstractVector{&lt;:Real})
    return mean(x) + std(x)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">mean_std_sum (generic function with 1 method)</code></pre><p>As noted in the docstring of <a href="#FlexiChains.collapse"><code>FlexiChains.collapse</code></a>, the function you provide must accept a vector argument and return a single value. Of course, it can also have other methods, but this is the one which <code>collapse</code> uses.</p><p>Now we can use <code>collapse</code> to apply this function to all variables in the chain. The second argument is a vector, which in this case will only contain our one function:</p><pre><code class="language- hljs">custom_stat = FlexiChains.collapse(chain, [mean_std_sum]; dims=:both)</code></pre><p>There are two things worth mentioning, which we will note in passing here without demonstrating (since they are also covered in the docstring):</p><ol><li><p>If there is only one function provided, you can additionally pass <code>drop_stat_dim=true</code> to remove the <code>:stat</code> dimension from the result, much like what <code>mean(chain)</code> et al. do.</p></li><li><p>The name of the statistic is inferred from the function. Sometimes this doesn&#39;t work out nicely, for example if you pass an anonymous function. In this case you can provide a tuple of <code>(:name, function)</code> instead of just the function.</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../turing/">« Usage with Turing.jl</a><a class="docs-footer-nextpage" href="../indexing/">Indexing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 22 October 2025 17:32">Wednesday 22 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
