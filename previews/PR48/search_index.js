var documenterSearchIndex = {"docs":
[{"location":"whynew/#Why-a-new-package?","page":"Why a new package?","title":"Why a new package?","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"FlexiChains.jl has been designed from the ground up to address existing limitations of MCMCChains.jl.","category":"page"},{"location":"whynew/#The-fundamental-difference","page":"Why a new package?","title":"The fundamental difference","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Under the hood, MCMCChains.jl uses AxisArrays.AxisArray as its data structure. Specifically, this allows it to store data in a compact 3-dimensional matrix, and index into the matrix using Symbols.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The downside of this is that it enforces a key type of Symbol and a value type of Tval<:Real. This means that, for example, if you have a model with vector-valued parameters (like x above), the vectors will be split up into their individual elements before being stored in the chain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"This is the core of how MCMCChains and FlexiChains differ, and all of the behaviour shown below stems from this.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"To illustrate this, let's sample from a Turing model and store the results in both MCMCChains.Chains and FlexiChains.VNChain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"using Turing\nusing MCMCChains: Chains\nusing FlexiChains: VNChain, VarName, @varname\nusing Random: Xoshiro\nusing PDMats: PDMats\n\nTuring.setprogress!(false)\n\n@model function f(x)\n    sigma ~ truncated(Normal(0, 1); lower=0)\n    chol ~ LKJCholesky(3, 1.0)\n    corr := PDMats.PDMat(chol)\n    mu ~ MvNormal(zeros(3), sigma^2 * I)\n    return x ~ MvNormal(mu, corr)\nend\n\nmodel = f(randn(Xoshiro(468), 3))","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The default chain type for Turing's sample is still MCMCChains.Chains; we just specify it here for clarity.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"mcmc = sample(Xoshiro(468), model, NUTS(), 100; chain_type=Chains)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Because FlexiChains does not enforce a key type, you are technically required to specify the key type of the chain as a type parameter. You could, for example, write FlexiChains.FlexiChain{DynamicPPL.VarName}. But since this is really the main use case of FlexiChains, we provide a convenient alias for this, FlexiChains.VNChain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"flexi = sample(Xoshiro(468), model, NUTS(), 100; chain_type=VNChain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Here, we expect the following parameters to be present in the chain:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"sigma is a scalar;\nchol is a Cholesky factor which contains a 3×3 lower triangular matrix;\ncorr is a 3×3 correlation matrix, which is a positive-definite matrix;\nmu is a length-3 vector.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Let's test first that both chains contain the same values for sigma. (Some fiddling is required because mcmc[:sigma] returns an AxisArray with a 100×1 matrix, while flexi[:sigma] returns a 100-element vector.)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"vec(mcmc[:sigma].data) == flexi[@varname(sigma)]","category":"page"},{"location":"whynew/#Indexing-keys","page":"Why a new package?","title":"Indexing keys","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"There is already one difference here: when indexing into MCMCChains you need to use a Symbol or String, whereas with FlexiChains you can use the original VarName.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"If you think this is too verbose, fret not! FlexiChains also lets you use Symbols (mainly for compatibility with MCMCChains):","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"flexi[:sigma] == flexi[@varname(sigma)]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The rest of this page uses VarNames, but you can mentally replace them with Symbols if you prefer.","category":"page"},{"location":"whynew/#Accessing-vector-valued-parameters","page":"Why a new package?","title":"Accessing vector-valued parameters","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Suppose you want to access the value of mu in the first iteration.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"With FlexiChains, you can do this directly as:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"flexi[:mu][1]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"With MCMCChains, because mu has been split up into its constituent elements, you need to do:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"[mu[1] for mu in (mcmc[\"mu[1]\"], mcmc[\"mu[2]\"], mcmc[\"mu[3]\"])]","category":"page"},{"location":"whynew/#Accessing-parameters-with-even-more-special-types","page":"Why a new package?","title":"Accessing parameters with even more special types","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Now suppose you want to extract the sampled values of chol and corr, and check that","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"# This code block isn't executed because we haven't defined `chols` and `corrs`\nfor (chol, corr) in zip(chols, corrs)\n    chol == cholesky(corr) || error(\"oops\")\nend","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"The question is of course how one can obtain the vectors chols and corrs from the chain. With FlexiChains, you can do this directly as:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"chols = flexi[:chol]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and likewise for :corr.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"On the other hand, with MCMCChains, reconstructing the chols becomes a non-trivial task:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"using LinearAlgebra\n\nchols = map(1:length(mcmc)) do i\n    c = Cholesky(LowerTriangular(zeros(3, 3)))\n    for j in 1:3\n        for k in 1:j\n            c.L[j, k] = mcmc[\"chol.L[$j, $k]\"][i]\n        end\n    end\n    c\nend","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and similarly for the corrs (which we won't demonstrate here).","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"In general the point is that in any situation where you want to work with the actual types of the parameters, rather than their individual elements, FlexiChains makes this much easier.","category":"page"},{"location":"whynew/#Accessing-individual-elements","page":"Why a new package?","title":"Accessing individual elements","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Sometimes maybe you really want to access just mu[2] without any reference to mu[1] or mu[3].","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Because FlexiChains stores the entire vector mu, you will then need to index into it:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"[mu_sample[2] for mu_sample in flexi[:mu]]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"In MCMCChains you can of course do","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"mcmc[\"mu[2]\"]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Note, though, that MCMCChains requires you to pass a string \"2\" to get the second variable. Of course, if you have an integer 2 this is quite easily done with interpolation, but I would argue from a readability perspective it's much clearer to index with an integer 2 rather than a string.","category":"page"},{"location":"whynew/#Other-types-of-data","page":"Why a new package?","title":"Other types of data","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Let's say we define a weird new discrete distribution which samples from the two structs Duck() and Goose().","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"(Why would you want to do this? Well, why shouldn't you be able to do it? Turing's docs tell you how to define your own distributions, but it doesn't say that you have to use numbers. The point is that FlexiChains doesn't force you to stick only to distributions over numbers.)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"using Distributions, Random\n\nabstract type Bird end\nstruct Duck <: Bird end\nstruct Goose <: Bird end\n\nstruct BirdDist <: Distributions.DiscreteUnivariateDistribution end\nDistributions.rand(rng::Random.AbstractRNG, ::BirdDist) = rand(rng) < 0.3 ? Duck() : Goose()\nDistributions.logpdf(::BirdDist, x::Duck) = log(0.3)\nDistributions.logpdf(::BirdDist, x::Goose) = log(0.7)\n\n@model function f()\n    return x ~ BirdDist()\nend\n\n# A bit more boilerplate is needed here to actually make it work with Turing.\nusing Bijectors, DynamicPPL\nDynamicPPL.tovec(b::Bird) = [b]\nBijectors.logabsdetjac(::typeof(identity), ::Bird) = 0.0\n\n# mcmc = sample(f(), MH(), 100; chain_type=VNChain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"TODO: Fix the example above, it fails with typed VarInfo because typed VarInfo expects Real things to put into Metadata. SimpleVarInfo would work. See https://github.com/TuringLang/DynamicPPL.jl/pull/1003","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Well, that worked quite nicely with FlexiChains.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"MCMCChains on the other hand would completely error here because it requires all its values to be Real. (To be precise, it requires all its values to be convertable to Real. So a distribution over Char works, even though Char <: Real is false, because Chars can be converted to Real.)","category":"page"},{"location":"whynew/#No-need-to-avoid-reserved-names","page":"Why a new package?","title":"No need to avoid reserved names","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"When sampling from a Turing model with MCMCChains as the output format, some metadata (non-parameter keys) such as lp are added to the chain. If your model contains a variable called lp, sampling will still work but odd things will happen. For example, it will look as if your chain does not actually have any variables:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"@model function lp_model()\n    return lp ~ Normal()\nend\n\nmchain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=Chains)\ndescribe(mchain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"When you index into mchain[:lp], how do you know whether it refers to the lp variable in your model or the lp metadata key?","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"any(mchain[:lp] .> 0)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Well, since there are some positive values, it has to be the parameter, because the metadata lp = logpdf(Normal(), value_of_lp_parameter) is always negative. But you didn't know that when you tried to index into it, you had to reverse engineer it.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"Besides, if you actually want the log-density, it's now gone. Tough luck. (You can get it back with logjoint(lp_model(), mchain) if you want.)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"HMC samplers further include extra metadata such as hamiltonian_energy, and in general any sampler can include any kind of extra metadata it wants. As a user, you have no way of knowing what these names are, and you have to avoid using them in your model, which is quite unfair.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"FlexiChains circumvents this entirely since it stores these separately as Parameter(@varname(lp)) and Extra(:lp). To be precise, the log joint is stored as Extra(:logjoint), so the point is that even if you had a parameter named @varname(logjoint) this woud still be fine.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"@model function lj_model()\n    return logjoint ~ Normal()\nend\n\nfchain = sample(Xoshiro(468), lj_model(), NUTS(), 100; chain_type=VNChain)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"You will of course run into ambiguities if you simply attempt to index the chain with [:logjoint], because both the Parameter(@varname(logjoint)) and the Extra(:logjoint) exist.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"fchain[:logjoint]\n# This code block isn't run because it would throw the following error:\n# ArgumentError: multiple keys correspond to symbol :logjoint.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"but you can still access the value using the original value of the Parameter:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"fchain[@varname(logjoint)]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and the corresponding metadata:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"(TODO: fix interface)","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"using FlexiChains: Extra\nfchain[Extra(:logjoint)]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"and indeed we can check that these do align:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"logpdf.(Normal(), fchain[@varname(logjoint)]) ≈ fchain[Extra(:logjoint)]","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"TODO pretty-printing / summary stats","category":"page"},{"location":"whynew/#For-DynamicPPL-developers","page":"Why a new package?","title":"For DynamicPPL developers","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"TODO Write about how this makes life a lot easier for things like predict.","category":"page"},{"location":"whynew/#Design-goals","page":"Why a new package?","title":"Design goals","text":"","category":"section"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"My main design goals for FlexiChains.jl were twofold:","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"To provide a rich data structure that can more faithfully represent the outputs from sampling with Turing.jl.\nThe restriction of MCMCChains.jl to Symbol keys and Real values means that round-trip conversion is a lossy operation. Consider, e.g., the predict(::Model, ::MCMCChains.Chains) function, which is used to sample from the posterior predictive distribution. This requires one to extract the values from the chain and insert them back into the model (or technically the VarInfo).\nHowever, in general one cannot reconstruct a vector x from its constituent elements x[1], x[2], ... as we do not know the appropriate length of the vector! The current implementation of this function in DynamicPPL.jl thus has to, essentially, insert all the elements it can find and hope for the best.\nEssentially, MCMCChains' data structure forces packages like Turing.jl and DynamicPPL.jl to include workarounds to deal with the limitations of the chains package.\nTo create a robust and readable codebase.\nMuch Julia code is written with the intention of efficiency or versatility, often sacrificing clarity in the process. This is usually acceptable when creating simple scripts. However, I believe that library code should be held to a (much) higher standard.\nIn particular, I consider the overuse of multiple dispatch to be a major source of confusion in Julia code. Types cannot be fully inferred at compile time (and even when they can, it requires packages such as JET.jl, which do not (yet) have convenient language server integrations). This means that when reading code, one cannot easily determine which method is being called.\nA prime example is the Chains constructor in MCMCChains.jl. methods(Chains) returns 11 methods, and each time you see a call to Chains(...) you need to figure out which of these 11 it is. In writing FlexiChains I have made a conscious choice to create only two inner constructors for FlexiChain.","category":"page"},{"location":"whynew/","page":"Why a new package?","title":"Why a new package?","text":"In particular, notice that performance is not one of my considerations. In my opinion, performance is only a minor concern for FlexiChains.jl, because the main bottleneck in Bayesian inference is the sampling, not how fast one can construct or index into a chain.","category":"page"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"danger: Danger\nThis page is still a work in progress. Please check back later for updates.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"The types and functions documented on this page form part of FlexiChains's public API.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"On Julia 1.11 and later, these are marked with the public keyword (or are extensions of other packages' APIs).","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"FlexiChains also guarantees that any changes to these APIs will be reflected with a breaking version bump.","category":"page"},{"location":"api/#The-FlexiChain-and-FlexiSummary-types","page":"Public API","title":"The FlexiChain and FlexiSummary types","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"The FlexiChain and FlexiSummary types are technically marked as public, but you should not handle them or their fields directly. For dispatch purposes, it is guaranteed that the first type parameter is always the key type; this should typically be all you need. Both types have extra type parameters, but they are considered internal and may change at any time.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"You can also use Base.keytype:","category":"page"},{"location":"api/#Base.keytype-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.keytype","text":"Base.keytype(cs::ChainOrSummary{TKey})\n\nReturns TKey.\n\n\n\n\n\n","category":"method"},{"location":"api/#Equality","page":"Public API","title":"Equality","text":"","category":"section"},{"location":"api/#Base.:==-Tuple{FlexiChains.FlexiChain, FlexiChains.FlexiChain}","page":"Public API","title":"Base.:==","text":"Base.:(==)(c1::FlexiChain{TKey1}, c2::FlexiChain{TKey2})::Bool where {TKey1,TKey2}\nBase.:(==)(c1::FlexiSummary{TKey1}, c2::FlexiSummary{TKey2})::Bool where {TKey1,TKey2}\n\nEquality operator for FlexiChains and FlexiSummarys. Two chains (or summaries) are equal if they have the same key type, the same size, the same data for each key, and the same metadata (which includes dimensional indices, sampling time, and sampler states).\n\nIf you only want to compare the data in a FlexiChain, you can use Dict(Base.pairs(c1)) == Dict(Base.pairs(c2)).\n\nnote: Note\nBecause missing == missing returns missing, and NaN == NaN returns false, this function will return false if there are any missing or NaN values in the chains, even if they appear in the same positions. In this case, use isequal(c1, c2) instead.\n\ntip: Tip\nIf you want to only compare equality of the data, you can use has_same_data.\n\ndanger: Danger\nBecause (==) on OrderedCollections.OrderedDict does not check key order, two chains with the same keys but in different orders will also be considered equal. If you think this is a mistake, please see this issue.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isequal-Tuple{FlexiChains.FlexiChain, FlexiChains.FlexiChain}","page":"Public API","title":"Base.isequal","text":"Base.isequal(c1::FlexiChain{TKey1}, c2::FlexiChain{TKey2})::Bool where {TKey1,TKey2}\nBase.isequal(c1::FlexiSummary{TKey1}, c2::FlexiSummary{TKey2})::Bool where {TKey1,TKey2}\n\nEquality operator for FlexiChains that treats missing and NaN values as equal if they appear in the same positions.\n\ntip: Tip\nIf you want to only compare equality of the data, you can use has_same_data.\n\ndanger: Danger\nBecause (==) on OrderedCollections.OrderedDict does not check key order, two chains with the same keys but in different orders will also be considered equal. If you think this is a mistake, please see this issue.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.has_same_data-Tuple{FlexiChains.FlexiChain, FlexiChains.FlexiChain}","page":"Public API","title":"FlexiChains.has_same_data","text":"FlexiChains.has_same_data(\n    c1::FlexiChain{TKey1},\n    c2::FlexiChain{TKey2};\n    strict=false\n) where {TKey1,TKey2}\n\nCheck if two FlexiChains have the same data, ignoring metadata such as sampling time, iteration indices, and chain indices.\n\nIf strict=true, then Base.:(==) is used to compare the data, which propagates missing values and treats NaN values as unequal. If strict=false (the default), then Base.isequal is used, which treats missing and NaN values as equal to themselves.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sizes","page":"Public API","title":"Sizes","text":"","category":"section"},{"location":"api/#Base.size-Tuple{FlexiChains.FlexiChain}","page":"Public API","title":"Base.size","text":"Base.size(chain::FlexiChain[, dim::Int])\n\nReturns (niters, nchains), or niters or nchains if dim=1 or dim=2 is specified.\n\nnote: MCMCChains difference\nMCMCChains returns a 3-tuple of (niters, nkeys, nchains) where nkeys is the total number of parameters. FlexiChains does not do this because the keys are not considered an axis of their own. If you want the total number of keys in a FlexiChain, you can use length(keys(chain)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{FlexiChains.FlexiSummary}","page":"Public API","title":"Base.size","text":"Base.size(summary::FlexiSummary[, dim::Int])\n\nReturns (niters, nchains, nstats), or niters, nchains, or nstats if dim=1, dim=2, or dim=3 is specified. If any of the dimensions have been collapsed, the corresponding value will be 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.niters","page":"Public API","title":"FlexiChains.niters","text":"FlexiChains.niters(chain::FlexiChain)\n\nThe number of iterations in the FlexiChain. Equivalent to size(chain, 1).\n\n\n\n\n\nFlexiChains.niters(summary::FlexiSummary)\n\nThe number of iterations in the FlexiSummary. Equivalent to size(summary, 1). Returns 0 if the iteration dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.nchains","page":"Public API","title":"FlexiChains.nchains","text":"FlexiChains.nchains(chain::FlexiChain)\n\nThe number of chains in the FlexiChain. Equivalent to size(chain, 2).\n\n\n\n\n\nFlexiChains.nchains(summary::FlexiSummary)\n\nThe number of chains in the FlexiSummary. Equivalent to size(summary, 2). Returns 0 if the chain dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.nstats","page":"Public API","title":"FlexiChains.nstats","text":"FlexiChains.nstats(summary::FlexiSummary)\n\nThe number of statistics in the FlexiSummary. Equivalent to size(summary, 3). Returns 0 if the statistics dimension has been collapsed (this means that there is a single statistic, but its name is not stored or displayed to the user).\n\n\n\n\n\n","category":"function"},{"location":"api/#Indices","page":"Public API","title":"Indices","text":"","category":"section"},{"location":"api/#FlexiChains.iter_indices","page":"Public API","title":"FlexiChains.iter_indices","text":"iter_indices(chain::FlexiChain)::DimensionalData.Lookup\n\nThe indices of each MCMC iteration in the chain. This tries to reflect the actual iteration numbers from the sampler: for example, if you discard the first 100 iterations and sampled 100 iterations but with a thinning factor of 2, this will be 101:2:300.\n\nThe accuracy of this field is reliant on the sampler providing this information, though.\n\n\n\n\n\niter_indices(summary::FlexiSummary)::DimensionalData.Lookup\n\nThe iteration indices, which are either the same as in the original chain, or nothing if the iter dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.chain_indices","page":"Public API","title":"FlexiChains.chain_indices","text":"chain_indices(chain::FlexiChain)::DimensionalData.Lookup\n\nThe indices of each MCMC chain in the chain. This will pretty much always be 1:nchains(chain) (unless the chain has been subsetted, or chain indices have been manually specified).\n\n\n\n\n\nchain_indices(summary::FlexiSummary)::DimensionalData.Lookup\n\nThe chain indices, which are either the same as in the original chain, or nothing if the chain dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.stat_indices","page":"Public API","title":"FlexiChains.stat_indices","text":"stat_indices(summary::FlexiSummary)::DimensionalData.Lookup\n\nThe indices for each statistic in the summary. This may be nothing if the stat  dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.renumber_iters","page":"Public API","title":"FlexiChains.renumber_iters","text":"renumber_iters(\n    chain::FlexiChain{TKey},\n    iter_indices::AbstractVector{<:Integer}=1:niters(chain)\n)::FlexiChain{TKey} where {TKey}\n\nReturn a copy of chain with the iteration indices replaced by iter_indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.renumber_chains","page":"Public API","title":"FlexiChains.renumber_chains","text":"renumber_chains(\n    chain::FlexiChain{TKey},\n    chain_indices::AbstractVector{<:Integer}=1:nchains(chain)\n)::FlexiChain{TKey} where {TKey}\n\nReturn a copy of chain with the chain indices replaced by chain_indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Key-types","page":"Public API","title":"Key types","text":"","category":"section"},{"location":"api/#FlexiChains.Parameter","page":"Public API","title":"FlexiChains.Parameter","text":"Parameter{T}(name::T)\n\nA named parameter in a FlexiChain. The name can be of any type, but all parameters in a FlexiChain must have the same type for their names.\n\nSpecifically, if you have a FlexiChain{TKey}, then all parameters must be of type Parameter{TKey}.\n\n\n\n\n\n","category":"type"},{"location":"api/#FlexiChains.Extra","page":"Public API","title":"FlexiChains.Extra","text":"Extra(name::Any)\n\nA key in a FlexiChain that is not a parameter. The name of the key itself can be of any type and is not constrained by the type of the FlexiChain.\n\n\n\n\n\n","category":"type"},{"location":"api/#FlexiChains.ParameterOrExtra","page":"Public API","title":"FlexiChains.ParameterOrExtra","text":"ParameterOrExtra{T}\n\nAlias for Union{Parameter{T},Extra}.\n\nAll keys in a FlexiChain{T} must satisfy k isa ParameterOrExtra{<:T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Accessing-key-value-pairs","page":"Public API","title":"Accessing key-value pairs","text":"","category":"section"},{"location":"api/#Base.keys-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.keys","text":"Base.keys(cs::ChainOrSummary)\n\nReturns the keys of the FlexiChain (or summary thereof).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Union{Tuple{TKey}, Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}}, TKey}} where TKey","page":"Public API","title":"Base.haskey","text":"Base.haskey(cs::ChainOrSummary{TKey}, key::TKey) where {TKey}\n\nReturns true if the FlexiChain or summary contains the given name as a parameter key.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Union{Tuple{TKey}, Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}}, Union{FlexiChains.Parameter{var\"#s7\"}, FlexiChains.Extra} where var\"#s7\"<:TKey}} where TKey","page":"Public API","title":"Base.haskey","text":"Base.haskey(cs::ChainOrSummary{TKey}, key::ParameterOrExtra{<:TKey}) where {TKey}\n\nReturns true if the FlexiChain or summary contains the given key.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.parameters-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"FlexiChains.parameters","text":"parameters(cs::ChainOrSummary{TKey}) where {TKey}\n\nReturns a vector of parameter names in the FlexiChain or summary thereof.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.extras-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"FlexiChains.extras","text":"extras(cs::ChainOrSummary)\n\nReturns a vector of non-parameter names in the FlexiChain or summary thereof.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.values-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.values","text":"Base.values(cs::ChainOrSummary)\n\nReturns the values of the FlexiChain or FlexiSummary, i.e., the matrices obtained by indexing into the chain with each key.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.pairs-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.pairs","text":"Base.pairs(cs::ChainOrSummary)\n\nReturns an iterator over the key-value pairs of the FlexiChain or FlexiSummary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Indexing-by-key","page":"Public API","title":"Indexing by key","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"For the public interface of getindex, please see the Indexing page.","category":"page"},{"location":"api/#Accessing-metadata","page":"Public API","title":"Accessing metadata","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Chains additionally store some metadata:","category":"page"},{"location":"api/#FlexiChains.sampling_time","page":"Public API","title":"FlexiChains.sampling_time","text":"sampling_time(chain::FlexiChain):Vector\n\nReturn the time taken to sample the chain (in seconds). If the time was not recorded, this will be missing.\n\nNote that this always returns a vector with length equal to the number of chains.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.last_sampler_state","page":"Public API","title":"FlexiChains.last_sampler_state","text":"last_sampler_state(chain::FlexiChain)::Vector\n\nReturn the final state of the sampler used to generate the chain, if the save_state=true keyword argument was passed to sample. This can be used for resuming MCMC sampling.\n\nNote that this always returns a vector with length equal to the number of chains.\n\nIf the state was not saved, this will be missing (or a vector thereof).\n\n\n\n\n\n","category":"function"},{"location":"api/#Combining-chains","page":"Public API","title":"Combining chains","text":"","category":"section"},{"location":"api/#Base.vcat-Union{Tuple{T}, Tuple{FlexiChains.FlexiChain{T}, FlexiChains.FlexiChain{T}}} where T","page":"Public API","title":"Base.vcat","text":"Base.vcat(cs...::FlexiChain{TKey}) where {TKey}\n\nConcatenate one or more FlexiChains along the iteration dimension. Both c1 and c2 must have the same number of chains and the same key type.\n\nThe resulting chain's keys are the union of both input chains' keys. Any keys that only have data in one of the arguments will be assigned missing data in the other chain during concatenation.\n\nThe resulting chain's sampling time is the sum of the input chains' sampling times, and the last sampler state is taken from the second chain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.hcat-Union{Tuple{T}, Tuple{FlexiChains.FlexiChain{T}, FlexiChains.FlexiChain{T}}} where T","page":"Public API","title":"Base.hcat","text":"Base.hcat(cs...::FlexiChain{TKey}) where {TKey}\n\nConcatenate one or more FlexiChains along the chain dimension. Both c1 and c2 must have the same number of iterations and the same key type.\n\nThe resulting chain's keys are the union of both input chains' keys. Any keys that only have data in one of the arguments will be assigned missing data in the other chain during concatenation.\n\nThe resulting chain's sampling times and last sampler states are obtained by concatenating those of the input chains.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.merge-Union{Tuple{T}, Tuple{FlexiChains.FlexiChain{T}, FlexiChains.FlexiChain{T}}} where T","page":"Public API","title":"Base.merge","text":"Base.merge(\n    c1::FlexiChain{TKey1},\n    c2::FlexiChain{TKey2}\n) where {TKey1,TKey2}\n\nMerge the contents of two FlexiChains. If there are keys that are present in both chains, the values from c2 will overwrite those from c1.\n\nIf the key types are different, the resulting FlexiChain will have a promoted key type, and a warning will be issued.\n\nThe two FlexiChains being merged must have the same dimensions.\n\nThe chain indices and metadata are taken from the second chain. Those in the first chain are silently ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subsetting-chains","page":"Public API","title":"Subsetting chains","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"You can do these with getindex too, but these functions are sometimes more convenient.","category":"page"},{"location":"api/#FlexiChains.subset_parameters","page":"Public API","title":"FlexiChains.subset_parameters","text":"subset_parameters(cs::ChainOrSummary)\n\nSubset a chain or summary, retaining only the Parameter keys.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.subset_extras","page":"Public API","title":"FlexiChains.subset_extras","text":"subset_extras(chain::FlexiChain)\n\nSubset a chain, retaining only the keys that are Extras (i.e. not parameters).\n\n\n\n\n\n","category":"function"},{"location":"api/#Extracting-per-iteration-samples","page":"Public API","title":"Extracting per-iteration samples","text":"","category":"section"},{"location":"api/#FlexiChains.values_at","page":"Public API","title":"FlexiChains.values_at","text":"FlexiChains.values_at(\n    chn::FlexiChain{TKey},\n    iter::Union{Int,DD.At},\n    chain::Union{Int,DD.At},\n    Tout::Type{T}=OrderedDict\n) where {TKey,T}\n\nExtract all values from the chain corresponding to a single MCMC iteration.\n\nThe desired iter and chain indices must be specified: they can either be an integer, or a DimensionalData.At selector. The meaning of these is exactly the same as when indexing: iter=5 means the fifth row of the chain, whereas iter=At(5) means the row corresponding to iteration number 5 in the MCMC process.\n\nTo get only the parameter keys, use FlexiChains.parameters_at.\n\nThe output type can be specified with the Tout keyword argument. Possible options are:\n\nTout <: AbstractDict: returns a dictionary mapping ParameterOrExtra{TKey} to their values. This is the most faithful representation of the data in the chain.\nTout = NamedTuple: attempts to convert every key name to a Symbol, which is used as the field name in the output NamedTuple.\n\nwarning: Using `NamedTuple` as `Tout`\nThis will throw an error if any key cannot be converted to a Symbol, or if there are duplicate key names after conversion. Furthermore, please be aware that this is a lossy conversion as it does not retain information about whether a key is a parameter or an extra.\n\nFor order-sensitive output types, such as OrderedDict, The keys are returned in the same order as they are stored in the FlexiChain. This also corresponds to the order returned by keys(chn).\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.parameters_at","page":"Public API","title":"FlexiChains.parameters_at","text":"FlexiChains.parameters_at(\n    chn::FlexiChain{TKey},\n    iter::Union{Int,DD.At},\n    chain::Union{Int,DD.At},\n    Tout::Type{T}=OrderedDict\n) where {TKey,T}\n\nExtract all parameter values from the chain corresponding to a single MCMC iteration, discarding non-parameter (i.e. Extra) keys.\n\nThe desired iter and chain indices must be specified: they can either be an integer, or a DimensionalData.At selector. The meaning of these is exactly the same as when indexing: iter=5 means the fifth row of the chain, whereas iter=At(5) means the row corresponding to iteration number 5 in the MCMC process.\n\nTo get all keys (not just parameters), use FlexiChains.values_at.\n\nThe output type can be specified with the Tout keyword argument. Possible options are:\n\nTout <: AbstractDict: returns a dictionary mapping TKey to their values\nTout = NamedTuple: attempts to convert every parameter name to a Symbol, which is used as the field name in the output NamedTuple.\n\nwarning: Using `NamedTuple` as `Tout`\nThis will throw an error if any key cannot be converted to a Symbol, or if there are duplicate key names after conversion. Furthermore, please be aware that this is a lossy conversion as it does not retain information about whether a key is a parameter or an extra.\n\nFor order-sensitive output types, such as OrderedDict, the parameters are returned in the same order as they are stored in the FlexiChain. This also corresponds to the order returned by FlexiChains.parameters(chn).\n\n\n\n\n\n","category":"function"},{"location":"api/#Splitting-up-VarNames","page":"Public API","title":"Splitting up VarNames","text":"","category":"section"},{"location":"api/#FlexiChains.split_varnames","page":"Public API","title":"FlexiChains.split_varnames","text":"FlexiChains.split_varnames(cs::ChainOrSummary{<:VarName})\n\nSplit up a chain, which in general may contain array- or other-valued parameters, into a chain containing only scalar-valued parameters. This is done by replacing the original VarName keys with appropriate leaves. For example, if x is a vector-valued parameter, then it is replaced by x[1], x[2], etc.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"TODO: Summaries, plotting.","category":"page"},{"location":"turing/#Usage-with-Turing.jl","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"This page provides a fairly high-level overview of how to use FlexiChains with Turing.jl.","category":"page"},{"location":"turing/#Sampling","page":"Usage with Turing.jl","title":"Sampling","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To obtain a FlexiChain from Turing.jl, you will need to specify a chain_type of FlexiChains.VNChain when performing MCMC sampling.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Let's use a non-trivial model so that we can illustrate some features of FlexiChains.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using Turing, FlexiChains\n\ny = [28, 8, -3, 7, -1, 1, 18, 12]\nsigma = [15, 10, 16, 11, 9, 11, 10, 18]\n@model function eight_schools(y, sigma)\n    mu ~ Normal(0, 5)\n    tau ~ truncated(Cauchy(0, 5); lower=0)\n    theta ~ MvNormal(fill(mu, length(y)), tau^2 * I)\n    for i in eachindex(y)\n        y[i] ~ Normal(theta[i], sigma[i])\n    end\n    return (mu=mu, tau=tau)\nend\nmodel = eight_schools(y, sigma)\nchain = sample(model, NUTS(), 5; chain_type=VNChain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Note\nWe only run 5 MCMC iterations here to keep the output in the following sections small.","category":"page"},{"location":"turing/#Accessing-data","page":"Usage with Turing.jl","title":"Accessing data","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"First, notice in the printout above that a FlexiChain stores 'parameters' and 'other keys' separately. Parameters correspond to random variables of the model you sampled from, whereas other keys are extra data associated with the samples drawn (for example, the log-joint probability of each sample). Each of these are accessed in a slightly different way.","category":"page"},{"location":"turing/#Parameters","page":"Usage with Turing.jl","title":"Parameters","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To access parameters, the most correct way is to use VarNames to index into the chain. VarName is a data structure defined in AbstractPPL.jl, and is what Turing.jl uses to represent the name of a random variable (appearing on the left-hand side of a tilde-statement).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"VarNames are most easily constructed by applying the @varname macro to the name of the variable that you want to access. For example, this directly gives us the value of mu in each iteration as a plain old vector of floats.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(mu)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: DimMatrix\nIndexing into a FlexiChain returns a DimensionalData.DimMatrix. This behaves exactly like a regular Matrix, but additionally carries extra information about its dimensions.This allows you to keep track of what each dimension means, and also allows for more advanced indexing operations, which are described in the 'indexing' page.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"For vector-valued parameters like theta, this works in exactly the same way, except that you get a DimMatrix of vectors.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(theta)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Note that the samples are stored not as a 3D array, but rather a matrix of vectors. This is probably the biggest difference between FlexiChains and MCMCChains. MCMCChains by default will break vector-valued parameters into multiple scalar-valued parameters called theta[1], theta[2], etc., whereas FlexiChains keeps them together as they were defined in the model.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you want to obtain only the first element of theta, you can index into it with the corresponding VarName:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(theta[1])]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In this way, you can 'break down', or access nested fields of, larger parameters. That is, if your model has x ~ dist, FlexiChains will let you access some field or index of x.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Heterogeneous data\nIf some samples of x have one element and others have two elements, attempting to access x[2] will return an array with missing values for the samples where x only has one element.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Sub-variables\nYou can access sub-variables of a model parameter, but not the other way around. If your model looks like@model function f()\n    x[1] ~ dist\n    return x[2] ~ dist\nendor alternatively@model function f()\n    x = Vector{Float64}(undef, 2)\n    return x .~ dist\nendyou cannot 'reconstruct' x from its component elements, because x does not exist as a single parameter in the model. (Or at least, you can't do it with FlexiChains. You can still call chain[@varname(x[1])] and chain[@varname(x[2])] and then perform hcat or similar to put them together yourself.)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"You can also use keyword arguments when indexing to specify which chains or iterations you are interested in. Note that when using square brackets to index, keyword arguments must be separated by commas, not semicolons!","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(mu), iter=2:4, chain=1]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The indexing behaviour of FlexiChains is described fully on the next page.","category":"page"},{"location":"turing/#Other-keys","page":"Usage with Turing.jl","title":"Other keys","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In general Turing.jl tries to package up some extra metadata into the chain that may be helpful. For example, the log-joint probability of each sample is stored with the key :logjoint. To access non-parameter information like this in an unambiguous fashion, you should use the Extra wrapper.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using FlexiChains: Extra\n\nchain[Extra(:logjoint)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"warning: Warning\nMCMCChains stores the log-joint probability as :lp. FlexiChains uses :logjoint instead, which is clearer. It is possible that MCMCChains may be changed to use :logjoint in the future, but for now this is another difference to be aware of.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If there is no ambiguity in the symbol :logjoint, then you can use a shortcut which is described in the next section.","category":"page"},{"location":"turing/#Indexing-by-Symbol:-a-shortcut","page":"Usage with Turing.jl","title":"Indexing by Symbol: a shortcut","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you are used to MCMCChains.jl, you may find this more cumbersome than before. So, FlexiChains provides some shortcuts for accessing data. You can index into a FlexiChain with a single Symbol, and as long as it is unambiguous, it will return the corresponding data.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[:mu] # parameter","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: What does unambiguous mean?\nIn this case, because the only parameter p for which Symbol(p) == :mu is @varname(mu), we can safely identify @varname(mu) as the parameter that we want.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: No sub-varnames\nYou cannot use chain[Symbol(\"theta[1]\")] as a replacement for chain[@varname(theta[1])].","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Likewise, we can omit wrapping :logjoint in Extra(...):","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[:logjoint] # other key","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If there is any ambiguity present (for example if there is also a parameter named @varname(logjoint)), FlexiChains will throw an error.","category":"page"},{"location":"turing/#Splitting-VarNames-up","page":"Usage with Turing.jl","title":"Splitting VarNames up","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The way that FlexiChains keeps vector-valued parameters together can make it more difficult to perform subsequent analyses, such as summarising or plotting. Therefore, to 'break up' parameters into their constituent sub-VarNames, you can use FlexiChains.split_varnames:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"split_varnames(chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Do note that this is a lossy conversion. There is no way to un-split the chain! Furthermore, while functions like predict will still work with a split chain, there will be substantial performance regressions. It is therefore strongly recommended that you only split a chain up only when necessary, and never earlier than that.","category":"page"},{"location":"turing/#Summary-statistics","page":"Usage with Turing.jl","title":"Summary statistics","text":"","category":"section"},{"location":"turing/#Overall-summaries","page":"Usage with Turing.jl","title":"Overall summaries","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"For a very quick summary of the chain, you can use StatsBase.summarystats (which FlexiChains reexports):","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using FlexiChains: summarystats\n\nsummarystats(chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"By default, summarystats will split VarNames up. This is done because summary statistics often only make sense for scalar-valued parameters, and users are unlikely to use a FlexiSummary to a performance-critical task. If you want to avoid this, you can set split_varnames=false:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"summarystats(chain; split_varnames=false)","category":"page"},{"location":"turing/#Individual-summaries","page":"Usage with Turing.jl","title":"Individual summaries","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"You can obtain, for example, the mean of each key in the chain using Statistics.mean. This returns a FlexiSummary object:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using Statistics: mean\n\nmn = mean(chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"You can index into a FlexiSummary in exactly the same ways as a FlexiChain.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"mn[@varname(mu)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Out of the box, FlexiChains provides:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Statistics.mean\nStatistics.median\nStatistics.std\nStatistics.var\nStatistics.quantile\nBase.minimum\nBase.maximum\nBase.sum\nBase.prod\nMCMCDiagnosticTools.ess\nMCMCDiagnosticTools.rhat\nMCMCDiagnosticTools.mcse","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"These functions can all be applied to a FlexiChain with their usual signatures (for example, quantile will require a second argument). Keyword arguments of the original functions are also supported, for example ess(chain; kind=:tail) returns the tail ESS.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Other summary functions\nIf you want to apply a summary function that isn't listed above, you can manually use FlexiChains.collapse. If it is something that is worth appearing in FlexiChains proper, please do open an issue!","category":"page"},{"location":"turing/#Collapsed-dimensions","page":"Usage with Turing.jl","title":"Collapsed dimensions","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"By default, applying summary functions will collapse the data in both the iteration and chain dimensions (the latter is only relevant if multiple chains are present).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To only collapse over one dimension you can use","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"mean(chain; dims=:iter)[@varname(mu)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"or dims=:chain (although that is probably less useful).","category":"page"},{"location":"turing/#Saving-and-resuming-MCMC-sampling-progress","page":"Usage with Turing.jl","title":"Saving and resuming MCMC sampling progress","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you want to sample a fewer number of iterations first and then resume it later, you can use the following:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chn1 = sample(model, NUTS(), 10; chain_type=VNChain, save_state=true)\nchn2 = sample(model, NUTS(), 10; chain_type=VNChain, resume_from=chn1)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The chains can be combined using vcat:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chn = vcat(chn1, chn2)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Multiple-chain sampling\nIn general, the resume_from argument only works automatically if both the original and resumed sampling use the same number of chains. That is, chn1 and chn2 must either both be invoked as sample(model, spl, N), or both invoked as sample(model, spl, MCMCThreads(), N, C) with the same C.If you need more flexibility than this, then the initial_state keyword argument is recommended instead. When performing single-chain sampling with sample(model, spl, N; initial_state=state), initial_state should be either nothing (to start a new chain) or the state to resume from. For multiple-chain sampling with sample(model, spl, MCMCThreads(), N, C), initial_state should be a vector of length C, where initial_state[i] is the state to resume the i-th chain from (or nothing to start a new chain).To obtain the saved final state of a chain, you can use FlexiChains.last_sampler_state. This always returns a vector of states with length equal to the number of chains. Note that this applies also if you only sampled a single chain, in which case the returned value is a vector of length 1: you will therefore have to use only() to extract the state itself.The above applies equally to MCMCSerial() and MCMCDistributed().","category":"page"},{"location":"turing/#Posterior-predictions-and-friends","page":"Usage with Turing.jl","title":"Posterior predictions and friends","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The functions predict, returned, logjoint, loglikelihood, and logprior all work 'as expected' using FlexiChains with exactly the same signatures that you are used to. Please consult the Turing.jl documentation for more details.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"returned(model, chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The pointwise_logdensity family of functions is not yet implemented.","category":"page"},{"location":"turing/#Plotting","page":"Usage with Turing.jl","title":"Plotting","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Right now FlexiChains does not (yet) provide any functionality for plotting, although these are planned for the future.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In the meantime, you can convert a FlexiChain to an MCMCChains.Chains object using the MCMCChains.Chains constructor.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using MCMCChains\nmcmc = MCMCChains.Chains(chain)","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"FlexiChains defines a few plot recipes which allows you to use the Plots.jl ecosystem to visualise chains. In particular, you will want to import StatsPlots.jl.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"note: Other backends\nIntegration with (at least) Makie.jl is planned, but not yet implemented.","category":"page"},{"location":"plotting/#Plot-types","page":"Plotting","title":"Plot types","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"What kind of plot you get in when using Plots.jl is controlled mainly by the seriestype keyword argument. For example, plot(..., seriestype=:histogram) will produce a histogram. In fact, calling histogram(...) simply redirects to plot(..., seriestype=:histogram).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The following series types are supported for FlexiChain objects.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"seriestype= Equivalent function Description\n:traceplot FlexiChains.traceplot() Trace plot of samples\n:histogram Plots.histogram() Histogram of samples\n:density Plots.density() Kernel density estimate of samples\n:mixeddensity FlexiChains.mixeddensity() Density plot or histogram, depending on whether the parameter is continuous or discrete\n:meanplot FlexiChains.meanplot() Running mean of samples\n:autocorplot FlexiChains.autocorplot() Autocorrelation of samples\n:traceplot_and_density Plots.plot() (with no seriestype argument) Trace plot and mixed density side-by-side","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"note: Feature parity with MCMCChains.jl\nThere are still substantially fewer options than in MCMCChains.jl. Other plot types will be added over time, but in the meantime if you need features from MCMCChains, you can convert a FlexiChain to an MCMCChains.Chains object using MCMCChains.Chains(chn).","category":"page"},{"location":"plotting/#Signature","page":"Plotting","title":"Signature","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The above plotting functions should be called with the following signature:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plotfunc(\n    chn[, param_or_params];\n    pool_chains::Bool=false,\n    split_varnames::Bool=(chn isa FlexiChain{<:VarName}),\n    kwargs...\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Positional arguments","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"chn is a FlexiChain object.\nparam_or_params is optional, and can be anything that is used to index into a chain. If not provided, all parameters in the chain will be plotted.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"If pool_chains=true, then samples from all chains are concatenated before plotting densities or histograms. Otherwise, each chain is plotted separately.\nsplit_varnames is only applicable if the chain key type is a VarName (as would be obtained from Turing). It controls whether vector-valued parameters are split into their individual components. For example, if z is a 2-dimensional parameter, then setting split_varnames=true will plot z[1] and z[2] separately.\nnote: Note\nPlots.jl will error when attempting to plot vector-valued parameters, so there is no real reason to disable split_varnames, unless you are developing new plot types.","category":"page"},{"location":"plotting/#Gallery","page":"Plotting","title":"Gallery","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Here, we demonstrate the plotting features with a typical chain sampled from a Turing model. However, the general principles are applicable to any FlexiChain object.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"We'll make a model with different types of parameters (continuous, discrete, and vector-valued).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using FlexiChains, StatsPlots, Turing\n\n@model function f()\n    x ~ Normal()\n    y ~ Poisson(3)\n    z ~ MvNormal(zeros(2), I)\nend\n\nchn = sample(\n    f(), MH(), MCMCThreads(), 1000, 3;\n    discard_initial=100, chain_type=VNChain, progress=false\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Notice that the chain has not split z up into z[1] and z[2]. However, when plotting, it will be automatically split up for you:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(chn)\nsavefig(\"plot1.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Trace and density plots of the sampled chain)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Notice that Extra keys, like the log probabilities, are not plotted by default. If you want to plot specific parameter(s), you can specify them as the second positional argument:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(chn, [@varname(x), :logjoint])\nsavefig(\"plot2.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Trace and density plots of x and the logjoint)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"In general, the second argument can be anything that you can index into a chain with. This means a symbol, a parameter, a FlexiChains.Extra, a sub-VarName, or a vector thereof.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"While the density plots above are useful for comparing whether the chains have mixed well, the overlapping histograms are harder to make sense of. You can combine the histograms by setting pool_chains=true. We'll also hide the legend to reduce clutter (keyword arguments like legend are simply passed through to Plots.jl):","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(chn; pool_chains=true, legend=false)\nsavefig(\"plot3.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Trace and pooled density plots of the sampled chain)","category":"page"},{"location":"plotting/#Docstrings","page":"Plotting","title":"Docstrings","text":"","category":"section"},{"location":"plotting/#FlexiChains.traceplot","page":"Plotting","title":"FlexiChains.traceplot","text":"FlexiChains.traceplot(\n    chn::FlexiChain{TKey}[, param_or_params];\n    split_varname=(TKey <: VarName),\n    kwargs...\n)\n\nCreate a trace plot of the specified parameter(s) in the given FlexiChain.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with traceplot(chn, :).\n\nIf the chain uses VarName keys, these will be split up into their constituent real-valued parameters, unless you pass split_varname=false. There is probably no good reason to disable the VarName splitting.\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#FlexiChains.meanplot","page":"Plotting","title":"FlexiChains.meanplot","text":"FlexiChains.meanplot(\n    chn::FlexiChain{TKey}[, param_or_params];\n    split_varname=(TKey <: VarName),\n    kwargs...\n)\n\nPlot the running mean of the specified parameter(s) in the given FlexiChain.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with meanplot(chn, :).\n\nIf the chain uses VarName keys, these will be split up into their constituent real-valued parameters, unless you pass split_varname=false. There is probably no good reason to disable the VarName splitting.\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#FlexiChains.autocorplot","page":"Plotting","title":"FlexiChains.autocorplot","text":"FlexiChains.autocorplot(\n    chn::FlexiChain{TKey}[, param_or_params];\n    lags=1:min(niters(chn)-1, round(Int,10*log10(niters(chn)))),\n    demean=true,\n    split_varname=(TKey <: VarName),\n    kwargs...\n)\n\nPlot the autocorrelation of the specified parameter(s) in the given FlexiChain.\n\nThe lags keyword argument can be used to specify which lags to plot. If nothing is passed (the default), this is set to the integers from 1 to min(niters-1, round(Int,10*log10(niters))) where niters is the number of iterations in the chain. This mimics the default behaviour of StatsBase.autocor.\n\nThe demean keyword argument specifies whether to subtract the mean of the parameter before computing the autocorrelation, and is passed to StatsBase.autocor.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with autocorplot(chn, :).\n\nIf the chain uses VarName keys, these will be split up into their constituent real-valued parameters, unless you pass split_varname=false. There is probably no good reason to disable the VarName splitting.\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#FlexiChains.mixeddensity","page":"Plotting","title":"FlexiChains.mixeddensity","text":"FlexiChains.mixeddensity(\n    chn::FlexiChain{TKey}[, param_or_params];\n    split_varname=(TKey <: VarName),\n    kwargs...\n)\n\nCreate either a density plot, or a histogram, of the specified parameter(s) in the given FlexiChain. Continuous-valued parameters are plotted using density plots, discrete-valued parameters with histograms.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with mixeddensity(chn, :).\n\nIf the chain uses VarName keys, these will be split up into their constituent real-valued parameters, unless you pass split_varname=false. There is probably no good reason to disable the VarName splitting.\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"indexing/#Indexing","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"A FlexiChain stores data in a  rich format: that means that instead of just storing a raw matrix of data, it also includes information about the iteration numbers and chain numbers. Additionally, FlexiSummary objects also sometimes store information about which summary functions were applied (especially when there are multiple of these).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This information is used when constructing the DimensionalData.DimArray outputs that you see when indexing into a FlexiChain or FlexiSummary object. But, on top of this, it also allows you to more surgically index into these objects using this information.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This page first begins with some illustrative examples, which might be the clearest way to demonstrate the indexing behaviour. If you prefer reading a fuller specification, the sections below that describe the exact behaviour in more detail.","category":"page"},{"location":"indexing/#Examples:-chains","page":"Indexing","title":"Examples: chains","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Let's first set up a chain:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"using FlexiChains, Turing\n@model function f()\n    x ~ MvNormal(zeros(2), I)\nend\nchn = sample(f(), MH(), MCMCThreads(), 5, 2; discard_initial=100, chain_type=VNChain, progress=false, verbose=false)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Notice how the iteration numbers here start from 101: that is because of the discard_initial argument.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# Picking out a single parameter; this returns a `DimMatrix`.\nchn[@varname(x)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# This picks out the first of the iterations (note: this has iteration number 101)\nchn[@varname(x), iter=1]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"warning: Keyword arguments to `getindex`\nNote that keyword arguments when indexing with square brackets must be separated from positional arguments by a comma. Using a semicolon will lead to an error.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# You can also select a specific chain\nchn[@varname(x), iter=1, chain=2]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# This picks out iteration number 101\nchn[@varname(x), iter=At(101)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# This picks out iteration numbers 101 through 103\nchn[@varname(x), iter=101..103]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# If you only want the first element of `x`:\nchn[@varname(x[1])]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# You can specify a vector of parameters\nchn[[@varname(x[1]), :logjoint]]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This last one returns a FlexiChain object, because multiple keys were specified. The data that we didn't care for, such as @varname(x[2]), are simply dropped.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Notice that this also gives us a way to 'flatten' a FlexiChain object such that all of its keys point to scalar values. We just need to find a full set of sub-VarNames:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"chn[[@varname(x[1]), @varname(x[2])]]","category":"page"},{"location":"indexing/#Examples:-summaries","page":"Indexing","title":"Examples: summaries","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm = summarystats(chn)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Notice two things: ","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This summary no longer has iter or chain dimensions, because the summary statistics have been calculated over all iterations and chains. However, it has a stat dimension, which we will need to use when accessing the data.\nThe variable x has been broken up for you into its components x[1] and x[2].","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm[@varname(x[1]), stat=At(:mean)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If you only apply a single summary function, such as mean, then the stat dimension will be automatically collapsed for you; you won't need to again specify At(:mean) when indexing.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm_mean = mean(chn)\nsm_mean[@varname(x[1])]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If you don't want to split the VarNames up, you can specify this as a keyword argument.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm_mean_nosplit = mean(chn; split_varnames=false)\nsm_mean_nosplit[@varname(x)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If you collapse only over iterations (for example), then you can specify the chain keyword argument (and likewise for iter if you collapse over chains).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm_iter = mean(chn; dims=:iter)\nsm_iter[@varname(x[1]), chain=2]","category":"page"},{"location":"indexing/#Positional-arguments","page":"Indexing","title":"Positional arguments","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"When indexing into a FlexiChain (or FlexiSummary) object, you can use one optional positional argument. This positional argument can either be an object pointing to a single key, in which case a DimMatrix is returned; or it can be an object pointing to multiple keys, in which case a FlexiChain (or FlexiSummary) is returned.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"To specify a single key, you can use:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"a parameter name (e.g. for a FlexiChain{T}, an object of type T);\na VarName or sub-VarName, for a FlexiChain{VarName} (i.e. VNChain);\na FlexiChains.Extra for non-parameter keys;\na Symbol, as long as it refers to an unambiguous key;\na FlexiChains.Parameter (this is mentioned for completeness; as a user you probably don't need to do this)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"On the other hand, you could specify multiple keys via:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"a Vector containing any combination of the above;\na colon :, which refers to all keys in the chain or summary.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If a positional argument is not specified, it defaults to :.","category":"page"},{"location":"indexing/#Keyword-arguments:-chains","page":"Indexing","title":"Keyword arguments: chains","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"In addition to the positional argument, you can also specify the iter and chain keyword arguments when indexing into the FlexiChain object. (FlexiSummary objects are covered right below this.) Both of these are optional, and exist to allow you to select data from specific iterations and/or chains.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"warning: Keyword arguments to getindex\nWhen indexing with square brackets, the keyword arguments must be separated from positional arguments by a comma, not a semicolon as is usual for other Julia functions. That is to say, you should use:chn[param, iter=iter, chain=chain]\n# this is also fine, albeit a bit wordy\ngetindex(chn, param; iter=iter, chain=chain)rather than# this will error\nchn[param; iter=iter, chain=chain]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"The allowed values for these keyword arguments almost exactly mimic the behaviour of DimensionalData.jl. Suppose that you sampled a chain with 100 iterations, but with a thinning factor of 2. FlexiChains will record this information, and its iteration numbers will be 1:2:199 (i.e. 1, 3, 5, ..., 199).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"For clarity, we will refer to the actual iteration numbers (1, 3, 5, ..., 199) as iteration numbers, and the entries in the chain (1st entry, 2nd entry, ..., 100th entry) as entries.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"You can then specify, for example:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"iter=... Description\n5 the fifth entry in the chain, i.e. iteration number 9\nAt(9) iteration number 9\nNot(5) all entries except the fifth one, i.e. all iteration numbers except 9\nNot(At(9)) all entries except iteration number 9\n6..30 all iteration numbers between 6 and 30, i.e. all but the first entry\n2:10 2nd through 10th entries, i.e. iteration numbers 6 through 30\n[At(9), At(30)] this will get the entries corresponding to iteration numbers 9 and 30\n: all entries (i.e. all iteration numbers)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"For convenience, FlexiChains re-exports the DimensionalData.jl selectors such as Not, At, and ...","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"The same applies to the chain keyword argument, except that here you are selecting which chains to include. This is slightly less interesting because chains are always numbered consecutively starting from 1. Consequently, i and At(i) have the same meaning. Nonetheless, you can still use all the same selectors as described above, e.g. Not(2) to drop the second chain.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"For more information about DimensionalData's selectors, please see their docs.","category":"page"},{"location":"indexing/#Keyword-arguments:-summaries","page":"Indexing","title":"Keyword arguments: summaries","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"note: Positional arguments\nThe positional argument when indexing into a FlexiSummary objects is exactly the same as for FlexiChain. Only keyword arguments behave differently.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"There are two differences between a FlexiChain and a FlexiSummary in terms of their indexing behaviour:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"FlexiSummary objects contain one additional dimension, called stat.\nFlexiSummary dimensions may be collapsed, meaning that they cannot be indexed into.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Consequently, there are three possible keyword arguments: iter, chain, and stat; but depending on which dimensions have been collapsed, you may not be able to use them.","category":"page"},{"location":"indexing/#iter-and-chain","page":"Indexing","title":"iter and chain","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"In general, if you apply a summary function like mean without specifying dimensions, then both iter and chain dimensions will be collapsed.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If you have performed the mean over a single dimension only, such as via summary = mean(chn; dims=:iter), then the iter dimension will be collapsed, but you can still index into the chain dimension using summary[key, chain=...].","category":"page"},{"location":"indexing/#stat","page":"Indexing","title":"stat","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"In general, the stat dimension is generally:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"not collapsed if multiple summary functions were applied, e.g. via summarystats(chn);\ncollapsed if a single summary function was applied, e.g. via mean(chn).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Unlike the iter and chain dimensions, the stat dimension's indices are Symbols instead of numbers. Thus, for example, if you have a summary that contains the mean and std of the chain, you could use:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"stat=... Description\n1 the first statistic, i.e. :mean\nAt(:mean) the :mean statistic\nNot(At(:mean)) everything but the :mean statistic","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"FlexiChains.jl provides an information-rich data structure for Markov chains.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"FlexiChains.jl is designed to be completely general, in that you can store any kind of data in a FlexiChain. However, its intended primary use is as a drop-in (but better) replacement for MCMCChains.jl in the Turing.jl ecosystem. Thus, there is some extra functionality available for chains that contain AbstractPPL.VarName parameters.","category":"page"},{"location":"integrations/#Integrations-with-other-packages","page":"Integrations with other packages","title":"Integrations with other packages","text":"","category":"section"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"FlexiChains is most obviously tied to the Turing.jl ecosystem, as described on the previous pages. However, it also contains some integrations with other packages.","category":"page"},{"location":"integrations/#PosteriorDB.jl","page":"Integrations with other packages","title":"PosteriorDB.jl","text":"","category":"section"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"Documentation for PosteriorDB.jl","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"If you have loaded a PosteriorDB.ReferencePosterior, you can transform it into a FlexiChain using FlexiChains.from_posteriordb_ref:","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"using PosteriorDB, FlexiChains\n\npdb = PosteriorDB.database()\npost = PosteriorDB.posterior(pdb, \"eight_schools-eight_schools_centered\")\nref = PosteriorDB.reference_posterior(post)\n\nchn = FlexiChains.from_posteriordb_ref(ref)","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"You can then use all the functionality of FlexiChains on chn:","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"summarystats(chn)","category":"page"},{"location":"integrations/#FlexiChains.from_posteriordb_ref","page":"Integrations with other packages","title":"FlexiChains.from_posteriordb_ref","text":"FlexiChains.from_posteriordb_ref(\n    ref::PosteriorDB.ReferencePosterior\n)::FlexiChain{String}\n\nLoad a PosteriorDB.ReferencePosterior into a FlexiChain. The keys are stored as strings, which matches the storage format in PosteriorDB.jl.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"danger: Danger\nThis page contains discussion of internal implementation details of FlexiChains. It is also not always completely up-to-date, due to the rapid development that is going on right now. You should not need to read this unless you are actively developing FlexiChains or a package that interacts with it.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"On this page we go into more detail about how FlexiChains is designed, and the ways to manipulate and extract data from a FlexiChain.","category":"page"},{"location":"internals/#Manually-constructing-a-FlexiChain","page":"Internals","title":"Manually constructing a FlexiChain","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"If you ever need to construct a FlexiChain from scratch, there are exactly two ways to do so. One is to pass an array of dictionaries (i.e., one dictionary per iteration); the other is to pass a dictionary of arrays (i.e., the values for each key are already grouped together).","category":"page"},{"location":"internals/#FlexiChains.FlexiChain-Union{Tuple{Any}, Tuple{TKey}} where TKey","page":"Internals","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey}(\n    niters::Int,\n    nchains::Int,\n    array_of_dicts::AbstractArray{<:AbstractDict,N};\n    iter_indices::AbstractVector{Int}=1:niters,\n    chain_indices::AbstractVector{Int}=1:nchains,\n    sampling_time::AbstractVector{<:Union{Real,Missing}}=fill(missing, nchains),\n    last_sampler_state::AbstractVector=fill(missing, nchains),\n) where {TKey,N}\n\nConstruct a FlexiChain from a vector or matrix of dictionaries. Each dictionary corresponds to one iteration.\n\nData\n\nEach dictionary must be a mapping from a ParameterOrExtra{<:TKey} (i.e., either a Parameter{<:TKey} or an Extra) to its value at that iteration.\n\nIf array_of_dicts is a vector (i.e., N = 1), then niter is the length of the vector and nchains is 1. If array_of_dicts is a matrix (i.e., N = 2), then (niter, nchains) = size(dicts).\n\nOther values of N will error.\n\nMetadata\n\niter_indices and chain_indices can be used to specify the iteration and chain indices, respectively. By default, these are 1:niters and 1:nchains, but can be any vector of integers of the appropriate length. sampling_time and last_sampler_state are used to store metadata about each chain. They should be given as vectors of length nchains (even if there is only one chain).\n\nExample usage\n\nd = fill(\n    Dict(Parameter(:x) => rand(), Extra(\"y\") => rand()), 200, 3\n)\nchn = FlexiChain{Symbol}(200, 3, d)\n\n\n\n\n\nFlexiChain{TKey}(\n    niters::Int,\n    nchains::Int,\n    dict_of_arrays::AbstractDict{<:Any,<:AbstractArray{<:Any,N}};\n    iter_indices::AbstractVector{Int}=1:niters,\n    chain_indices::AbstractVector{Int}=1:nchains,\n    sampling_time::AbstractVector{<:Union{Real,Missing}}=fill(missing, nchains),\n    last_sampler_state::AbstractVector=fill(missing, nchains),\n) where {TKey,N}\n\nConstruct a FlexiChain from a dictionary of arrays.\n\nData\n\nEach key in the dictionary must subtype ParameterOrExtra{<:TKey} (i.e., it is either a Parameter{<:TKey} or an Extra). The values of the dictionary must all be of the same size.\n\nIf the values are vectors (i.e., N = 1), then niters will be the length of the vector, and nchains will be 1. If the values are matrices (i.e., N = 2), then (niter, nchains) = size(array).\n\nOther values of N will error.\n\nMetadata\n\niter_indices and chain_indices can be used to specify the iteration and chain indices, respectively. By default, these are 1:niters and 1:nchains, but can be any vector of integers of the appropriate length. sampling_time and last_sampler_state are used to store metadata about each chain. They should be given as vectors of length nchains (even if there is only one chain).\n\nExample usage\n\nd = Dict(\n    Parameter(:x) => rand(200, 3),\n    Extra(\"y\") => rand(200, 3),\n)\nchn = FlexiChain{Symbol}(200, 3, d)\n\n\n\n\n\n","category":"method"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that, although the dictionaries themselves may have loose types, the key type of the FlexiChain must be specified (and the keys of the dictionaries will be checked against this).","category":"page"},{"location":"internals/#Summaries","page":"Internals","title":"Summaries","text":"","category":"section"},{"location":"internals/#A-basic-overview","page":"Internals","title":"A basic overview","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"In general a FlexiChain contains data in matrices of size (niters, nchains). Often it is useful to summarise this data along one or both dimensions.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"For ease of use, a number of pre-existing functions are extended to work with FlexiChains in this manner. For these functions, you can use f(chain; dims=:iter) to collapse over the iteration dimension only, or f(chain; dims=:chain) to collapse over the chain dimension only.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Keyword arguments are automatically forwarded to the underlying function.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"note: Errors\nSince FlexiChains is really general in its data types, functions like Statistics.mean may not work on all values that are present in the chain. For example, the mean of String values is not defined. In such cases, a warning is emitted and the key is dropped from the returned summary object.","category":"page"},{"location":"internals/#Statistics.mean-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Statistics.mean","text":"Statistics.mean(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the mean across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.mean.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Statistics.median-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Statistics.median","text":"Statistics.median(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the median across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.median.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Statistics.var-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Statistics.var","text":"Statistics.var(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the variance across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.var.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Statistics.std-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Statistics.std","text":"Statistics.std(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the standard deviation across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.std.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.minimum-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Base.minimum","text":"Base.minimum(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the minimum across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.minimum.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.maximum-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Base.maximum","text":"Base.maximum(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the maximum across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.maximum.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.sum-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Base.sum","text":"Base.sum(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the sum across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.sum.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.prod-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"Base.prod","text":"Base.prod(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the product across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.prod.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Statistics.quantile-Tuple{FlexiChains.FlexiChain, Any}","page":"Internals","title":"Statistics.quantile","text":"Statistics.quantile(\n    chain::FlexiChain{TKey},\n    p;\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the quantile across all iterations and chains for each key in the chain. If it cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe argument p specifies the quantile to compute, and is forwarded to Statistics.quantile, along with any other keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MCMCDiagnosticTools.ess-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"MCMCDiagnosticTools.ess","text":"MCMCDiagnosticTools.ess(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the effective sample size across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to MCMCDiagnosticTools.ess.\n\nFor a full list of keyword arguments, please see the documentation for MCMCDiagnosticTools.ess.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MCMCDiagnosticTools.rhat-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"MCMCDiagnosticTools.rhat","text":"MCMCDiagnosticTools.rhat(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the R-hat diagnostic across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to MCMCDiagnosticTools.rhat.\n\nFor a full list of keyword arguments, please see the documentation for MCMCDiagnosticTools.rhat.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MCMCDiagnosticTools.mcse-Tuple{FlexiChains.FlexiChain}","page":"Internals","title":"MCMCDiagnosticTools.mcse","text":"MCMCDiagnosticTools.mcse(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the Monte Carlo standard error across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to MCMCDiagnosticTools.mcse.\n\nFor a full list of keyword arguments, please see the documentation for MCMCDiagnosticTools.mcse.\n\n\n\n\n\n","category":"method"},{"location":"internals/","page":"Internals","title":"Internals","text":"To calculate all of mean, std, mcse, bulk ess, tail ess, and rhat at once:","category":"page"},{"location":"internals/#StatsBase.summarystats","page":"Internals","title":"StatsBase.summarystats","text":"StatsBase.summarystats(\n    chain::FlexiChain{TKey};\n    split_varnames::Bool=(TKey<:VarName)\n) where {TKey}\n\nCompute a standard set of summary statistics for each key in the chain. The statistics include:\n\nmean\nstandard deviation\nMonte Carlo standard error\nbulk effective sample size\ntail effective sample size\nR-hat diagnostic\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\n\n\n\n\n","category":"function"},{"location":"internals/#getindex","page":"Internals","title":"getindex","text":"","category":"section"},{"location":"internals/#Base.getindex-Union{Tuple{TKey}, Tuple{FlexiChains.FlexiSummary{TKey}, FlexiChains.ParameterOrExtra{TKey}}} where TKey","page":"Internals","title":"Base.getindex","text":"Base.getindex(\n    fs::FlexiSummary{TKey}, key::ParameterOrExtra{<:TKey};\n    [iter=Colon(),]\n    [chain=Colon(),]\n    [stat=Colon()]\n) where {TKey}\n\nUnambiguously access the data corresponding to the given key in the summary.\n\nYou will need to use this method if you have multiple keys that convert to the same Symbol, such as a Parameter(:x) and an Extra(:x).\n\nnote: Keyword arguments\nThe iter, chain, and stat keyword arguments further allow you to extract specific iterations, chains, or statistics from the data corresponding to the given key. Note that these keyword arguments can only be used if the corresponding dimension exists (for example, if the summary statistic has been calculated over all iterations, then the iter dimension will not exist and using the iter keyword argument will throw an error).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Multiple-functions-at-once","page":"Internals","title":"Multiple functions at once","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"TODO: we don't have a nice API for this. There is collapse but that's a bit clunky.","category":"page"},{"location":"internals/#Summaries-in-more-depth","page":"Internals","title":"Summaries in more depth","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"All of the above functions dispatch to a more general function, called collapse.","category":"page"},{"location":"internals/#FlexiChains.collapse","page":"Internals","title":"FlexiChains.collapse","text":"FlexiChains.collapse(\n    chain::FlexiChain,\n    funcs::AbstractVector;\n    dims::Symbol=:both,\n    warn::Bool=true,\n    drop_stat_dim::Bool=false,\n)\n\nLow-level function to collapse one or both dimensions of a FlexiChain by applying a list of summary functions.\n\nThe funcs argument must be a vector which contains either:\n\ntuples of the form (statistic_name::Symbol, func::Function); or\njust functions, in which case the statistic name is obtained from the function name.\n\nThe dims keyword argument specifies which dimensions to collapse. By default, dims is :both, which collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which  respectively collapse only the iteration or chain dimension.\n\nThe functions in funcs must map an (NIter × NChains) matrix to:\n\na single item if dims=:both;\na (1 × NChains) matrix if dims=:iter;\nan (NIter × 1) matrix if dims=:chain.\n\nThis means that the exact function used will differ depending on the value of dims. For example, suppose that chn is a FlexiChain. Then the following are all valid:\n\nusing FlexiChains: collapse\nusing Statistics: mean, std\n\ncollapse(chn, [mean, std]; dims=:both)\ncollapse(chn, [x -> mean(x; dims=1), x -> std(x; dims=1)]; dims=:iter)\ncollapse(chn, [x -> mean(x; dims=2), x -> std(x; dims=2)]; dims=:chain)\n\nNote that, in the latter two cases, the inferred statistic name will not be mean or std but rather some unintelligible name of an anonymous function. This is why it is recommended to use the (statistic_name::Symbol, func::Function) tuple form in these cases, such as in the following:\n\ncollapse(chn, [\n    (:mean, x -> mean(x; dims=1)),\n    (:std, x -> std(x; dims=1))\n]; dims=:iter)\n\nIf a statistic function errors when applied to a key, that key is skipped and a warning is issued. The warning can be suppressed by setting warn=false.\n\nIf the drop_stat_dim keyword argument is true and only one function is provided in funcs, then the resulting FlexiSummary will have the stat dimension dropped. This allows for easier indexing into the result when only one statistic is computed. It is an error to set drop_stat_dim=true when more than one function is provided.\n\nThe return type is a FlexiSummary.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"For example, you can pass the functions x -> mean(x; dims=1), x -> mean(x; dims=2), and mean.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The return type of collapse is FlexiSummary, which has very similar indexing behaviour to FlexiChain.","category":"page"},{"location":"internals/#FlexiChains.FlexiSummary","page":"Internals","title":"FlexiChains.FlexiSummary","text":"FlexiChains.FlexiSummary{\n    TKey,\n    TIIdx<:Union{DimensionalData.Lookup,Nothing},\n    TCIdx<:Union{DimensionalData.Lookup,Nothing},\n    TSIdx<:Union{DimensionalData.Categorical,Nothing},\n}\n\nA data structure containing summary statistics of a FlexiChain.\n\nConstruction\n\nCalling summary functions such as mean or std on a FlexiChain will return a FlexiSummary. For more flexibility, you can use FlexiChains.collapse to apply one or more summary functions to a FlexiChain.\n\nUsers should not need to construct FlexiSummary objects directly.\n\nIndexing\n\nA FlexiSummary{TKey} can be indexed into using exactly the same techniques as a FlexiChain{TKey}. That is to say:\n\nwith Parameter{TKey} or Extra to unambiguously get the summary statistics for that key\nwith TKey for automatic conversion to Parameter{TKey}\nwith Symbol to find unambiguous matches\nif TKey<:VarName, using VarName or sub-VarNames to additionally extract part of the data.\n\nThe returned value will be either a DimensionalData.DimArray (if there are one or more non-collapsed dimensions), or a single value (if all dimensions are collapsed).\n\nIf a DimArray is returned, the dimensions that you will see are: :iter (if the summary function was only applied over chains), :chain (same but for iterations), and :stat (typically seen when multiple summary functions were applied).\n\nExtended help\n\nInternal data layout\n\nA FlexiSummary, much like a FlexiChain, contains a mapping of keys to arrays of data. However, the dimensions of a FlexiSummary are substantially different. In particular:\n\nThe :iter and/or :chain dimensions may have been collapsed via the act of calculating a summary over iterations or chains.\nThere is an additional, third, dimension: the statistic dimension, represented by `:stat. This dimension records which statistic(s) have been calculated.\nThe :stat dimension may also have been collapsed. This can happen if only one statistic was computed and drop_stat_dim=true was used when calling FlexiChains.collapse. The purpose of this is to avoid making the user deal with a redundant singleton dimension when calling a function such as mean(chain).\n\nRegardless of which dimensions have been collapsed, the internal data of a FlexiSummary always contains all three dimensions (some of which may have size 1).\n\nInformation about which dimensions are collapsed is therefore not stored in the arrays. Instead, it is stored in the _iter_indices, _chain_indices, and _stat_indices fields of the FlexiSummary, as well as their types. If any of these are nothing, then that dimension has been collapsed.\n\nThis information is later used in the _get_raw_data and _raw_to_user_data functions.\n\n\n\n\n\n","category":"type"}]
}
