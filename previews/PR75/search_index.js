var documenterSearchIndex = {"docs":
[{"location":"whynot/#Why-not-FlexiChains?","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"","category":"section"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"Since I wrote one whole page saying why you should use FlexiChains, here are the counterarguments, or at least those I can think of.","category":"page"},{"location":"whynot/#Performance-and-type-stability","page":"Why not FlexiChains?","title":"Performance and type stability","text":"","category":"section"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"FlexiChains uses dictionaries as its internal storage, and it is simply not type stable to index into a dictionary (with abstract key / value types). Consequently, the vast majority of operations in FlexiChains are not type stable. They are quite potentially also slower than equivalent operations in MCMCChains.","category":"page"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"Personally, I consider this to be really unimportant, because chain manipulation and data access are hardly performance bottlenecks in a typical Bayesian workflow. If you find an instance where FlexiChains is unbearably slow, please do open an issue.","category":"page"},{"location":"whynot/#Feature-set","page":"Why not FlexiChains?","title":"Feature set","text":"","category":"section"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"MCMCChains has more plotting and statistics functions available. This is mainly because MCMCChains has been around for longer, and has had more contributors. But it should not be very difficult to make FlexiChains catch up. For example, adding a new statistic essentially entails copying some existing code and changing the function name.","category":"page"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"I would be very happy to accept PRs porting some of this functionality to FlexiChains!","category":"page"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"In the meantime, you can always convert your FlexiChain to an MCMCChains.Chains.","category":"page"},{"location":"whynot/#Interface-stability","page":"Why not FlexiChains?","title":"Interface stability","text":"","category":"section"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"FlexiChains is still quite young, development is happening quite rapidly, and thus its interface may not be fully stable. On the other hand MCMCChains is largely stable (although you may consider a lack of development to be a drawback).","category":"page"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"My aim is to release a version 1.0 as soon as possible. (In general, I strongly subscribe to the view that packages that are used by the public should release 1.0 as soon as possible: see this issue.) My preconditions for FlexiChains 1.0 are twofold:","category":"page"},{"location":"whynot/","page":"Why not FlexiChains?","title":"Why not FlexiChains?","text":"I am happy with the core design and APIs of the package. That is to say, I don't care about which statistic functions are implemented, but I do care that they return sensible data structures.\nThe package has been tested by a few people in the wild for a month or so, to catch any obvious gaps or drawbacks.","category":"page"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"The types and functions documented on this page form part of FlexiChains's public API.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"On Julia 1.11 and later, these are marked with the public keyword (or are extensions of other packages' APIs).","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"FlexiChains also guarantees that any changes to these APIs will be reflected with a breaking version bump.","category":"page"},{"location":"api/#The-FlexiChain-and-FlexiSummary-types","page":"Public API","title":"The FlexiChain and FlexiSummary types","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"The FlexiChain and FlexiSummary types are technically marked as public, but you should not handle them or their fields directly. For dispatch purposes, it is guaranteed that the first type parameter is always the key type; this should typically be all you need. Both types have extra type parameters, but they are considered internal and may change at any time.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"You can also use Base.keytype:","category":"page"},{"location":"api/#Base.keytype-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.keytype","text":"Base.keytype(cs::ChainOrSummary{TKey})\n\nReturns TKey.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Public API","title":"Public API","text":"If you ever need to construct a FlexiChain from scratch, there are exactly two ways to do so. One is to pass an array of dictionaries (i.e., one dictionary per iteration); the other is to pass a dictionary of arrays (i.e., the values for each key are already grouped together).","category":"page"},{"location":"api/#FlexiChains.FlexiChain-Union{Tuple{Any}, Tuple{TKey}} where TKey","page":"Public API","title":"FlexiChains.FlexiChain","text":"FlexiChain{TKey}(\n    niters::Int,\n    nchains::Int,\n    array_of_dicts::AbstractArray{<:AbstractDict,N};\n    iter_indices::AbstractVector{Int}=1:niters,\n    chain_indices::AbstractVector{Int}=1:nchains,\n    sampling_time::AbstractVector{<:Union{Real,Missing}}=fill(missing, nchains),\n    last_sampler_state::AbstractVector=fill(missing, nchains),\n) where {TKey,N}\n\nConstruct a FlexiChain from a vector or matrix of dictionaries. Each dictionary corresponds to one iteration.\n\nData\n\nEach dictionary must be a mapping from a ParameterOrExtra{<:TKey} (i.e., either a Parameter{<:TKey} or an Extra) to its value at that iteration.\n\nIf array_of_dicts is a vector (i.e., N = 1), then niter is the length of the vector and nchains is 1. If array_of_dicts is a matrix (i.e., N = 2), then (niter, nchains) = size(dicts).\n\nOther values of N will error.\n\nMetadata\n\niter_indices and chain_indices can be used to specify the iteration and chain indices, respectively. By default, these are 1:niters and 1:nchains, but can be any vector of integers of the appropriate length. sampling_time and last_sampler_state are used to store metadata about each chain. They should be given as vectors of length nchains (even if there is only one chain).\n\nExample usage\n\nd = fill(\n    Dict(Parameter(:x) => rand(), Extra(\"y\") => rand()), 200, 3\n)\nchn = FlexiChain{Symbol}(200, 3, d)\n\n\n\n\n\nFlexiChain{TKey}(\n    niters::Int,\n    nchains::Int,\n    dict_of_arrays::AbstractDict{<:Any,<:AbstractArray{<:Any,N}};\n    iter_indices::AbstractVector{Int}=1:niters,\n    chain_indices::AbstractVector{Int}=1:nchains,\n    sampling_time::AbstractVector{<:Union{Real,Missing}}=fill(missing, nchains),\n    last_sampler_state::AbstractVector=fill(missing, nchains),\n) where {TKey,N}\n\nConstruct a FlexiChain from a dictionary of arrays.\n\nData\n\nEach key in the dictionary must subtype ParameterOrExtra{<:TKey} (i.e., it is either a Parameter{<:TKey} or an Extra). The values of the dictionary must all be of the same size.\n\nIf the values are vectors (i.e., N = 1), then niters will be the length of the vector, and nchains will be 1. If the values are matrices (i.e., N = 2), then (niter, nchains) = size(array).\n\nOther values of N will error.\n\nMetadata\n\niter_indices and chain_indices can be used to specify the iteration and chain indices, respectively. By default, these are 1:niters and 1:nchains, but can be any vector of integers of the appropriate length. sampling_time and last_sampler_state are used to store metadata about each chain. They should be given as vectors of length nchains (even if there is only one chain).\n\nExample usage\n\nd = Dict(\n    Parameter(:x) => rand(200, 3),\n    Extra(\"y\") => rand(200, 3),\n)\nchn = FlexiChain{Symbol}(200, 3, d)\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Public API","title":"Public API","text":"Note that, although the dictionaries themselves may have loose types, the key type of the FlexiChain must be specified (and the keys of the dictionaries will be checked against this).","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"FlexiSummary objects should always be constructed by summarising a FlexiChain. If for some reason you need to construct one from scratch, please refer to the source code (and do let me know, so that I can make this part of the public API).","category":"page"},{"location":"api/#Equality","page":"Public API","title":"Equality","text":"","category":"section"},{"location":"api/#Base.:==-Tuple{FlexiChains.FlexiChain, FlexiChains.FlexiChain}","page":"Public API","title":"Base.:==","text":"Base.:(==)(c1::FlexiChain{TKey1}, c2::FlexiChain{TKey2}) where {TKey1,TKey2}\nBase.:(==)(c1::FlexiSummary{TKey1}, c2::FlexiSummary{TKey2}) where {TKey1,TKey2}\n\nEquality operator for FlexiChains and FlexiSummarys. Two chains (or summaries) are equal if they have the same key type, the same size, the same data for each key, and the same metadata (which includes dimensional indices, sampling time, and sampler states).\n\nnote: Note\nBecause missing == missing returns missing, and NaN == NaN returns false, this function will not return true if there are any missing or NaN values in the chains, even if they appear in the same positions. To test for equality with such data, use isequal(c1, c2) instead.\n\ntip: Tip\nIf you want to only compare equality of the data, you can use FlexiChains.has_same_data(c1, c2; strict=true).\n\ndanger: Danger\nBecause (==) on OrderedCollections.OrderedDict does not check key order, two chains with the same keys but in different orders will also be considered equal. If you think this is a mistake, please see this issue.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isequal-Tuple{FlexiChains.FlexiChain, FlexiChains.FlexiChain}","page":"Public API","title":"Base.isequal","text":"Base.isequal(c1::FlexiChain{TKey1}, c2::FlexiChain{TKey2})::Bool where {TKey1,TKey2}\nBase.isequal(c1::FlexiSummary{TKey1}, c2::FlexiSummary{TKey2})::Bool where {TKey1,TKey2}\n\nEquality operator for FlexiChains that treats missing and NaN values as equal if they appear in the same positions.\n\ntip: Tip\nIf you want to only compare equality of the data, you can use FlexiChains.has_same_data(c1, c2; strict=false).\n\ndanger: Danger\nBecause (==) on OrderedCollections.OrderedDict does not check key order, two chains with the same keys but in different orders will also be considered equal. If you think this is a mistake, please see this issue.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.has_same_data-Tuple{FlexiChains.FlexiChain, FlexiChains.FlexiChain}","page":"Public API","title":"FlexiChains.has_same_data","text":"FlexiChains.has_same_data(\n    c1::FlexiChain{TKey1},\n    c2::FlexiChain{TKey2};\n    strict=false\n) where {TKey1,TKey2}\n\nCheck if two FlexiChains have the same data, ignoring metadata such as sampling time, iteration indices, and chain indices.\n\nIf strict=true, then Base.:(==) is used to compare the data, which propagates missing values and treats NaN values as unequal. If strict=false (the default), then Base.isequal is used, which treats missing and NaN values as equal to themselves.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sizes","page":"Public API","title":"Sizes","text":"","category":"section"},{"location":"api/#Base.size-Tuple{FlexiChains.FlexiChain}","page":"Public API","title":"Base.size","text":"Base.size(chain::FlexiChain[, dim::Int])\n\nReturns (niters, nchains), or niters or nchains if dim=1 or dim=2 is specified.\n\nnote: MCMCChains difference\nMCMCChains returns a 3-tuple of (niters, nkeys, nchains) where nkeys is the total number of parameters. FlexiChains does not do this because the keys are not considered an axis of their own. If you want the total number of keys in a FlexiChain, you can use length(keys(chain)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{FlexiChains.FlexiSummary}","page":"Public API","title":"Base.size","text":"Base.size(summary::FlexiSummary[, dim::Int])\n\nReturns (niters, nchains, nstats), or niters, nchains, or nstats if dim=1, dim=2, or dim=3 is specified. If any of the dimensions have been collapsed, the corresponding value will be 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.niters","page":"Public API","title":"FlexiChains.niters","text":"FlexiChains.niters(chain::FlexiChain)\n\nThe number of iterations in the FlexiChain. Equivalent to size(chain, 1).\n\n\n\n\n\nFlexiChains.niters(summary::FlexiSummary)\n\nThe number of iterations in the FlexiSummary. Equivalent to size(summary, 1). Returns 0 if the iteration dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.nchains","page":"Public API","title":"FlexiChains.nchains","text":"FlexiChains.nchains(chain::FlexiChain)\n\nThe number of chains in the FlexiChain. Equivalent to size(chain, 2).\n\n\n\n\n\nFlexiChains.nchains(summary::FlexiSummary)\n\nThe number of chains in the FlexiSummary. Equivalent to size(summary, 2). Returns 0 if the chain dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.nstats","page":"Public API","title":"FlexiChains.nstats","text":"FlexiChains.nstats(summary::FlexiSummary)\n\nThe number of statistics in the FlexiSummary. Equivalent to size(summary, 3). Returns 0 if the statistics dimension has been collapsed (this means that there is a single statistic, but its name is not stored or displayed to the user).\n\n\n\n\n\n","category":"function"},{"location":"api/#Indices","page":"Public API","title":"Indices","text":"","category":"section"},{"location":"api/#FlexiChains.iter_indices","page":"Public API","title":"FlexiChains.iter_indices","text":"iter_indices(chain::FlexiChain)::DimensionalData.Lookup\n\nThe indices of each MCMC iteration in the chain. This tries to reflect the actual iteration numbers from the sampler: for example, if you discard the first 100 iterations and sampled 100 iterations but with a thinning factor of 2, this will be 101:2:300.\n\nThe accuracy of this field is reliant on the sampler providing this information, though.\n\n\n\n\n\niter_indices(summary::FlexiSummary)::DimensionalData.Lookup\n\nThe iteration indices, which are either the same as in the original chain, or nothing if the iter dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.chain_indices","page":"Public API","title":"FlexiChains.chain_indices","text":"chain_indices(chain::FlexiChain)::DimensionalData.Lookup\n\nThe indices of each MCMC chain in the chain. This will pretty much always be 1:nchains(chain) (unless the chain has been subsetted, or chain indices have been manually specified).\n\n\n\n\n\nchain_indices(summary::FlexiSummary)::DimensionalData.Lookup\n\nThe chain indices, which are either the same as in the original chain, or nothing if the chain dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.stat_indices","page":"Public API","title":"FlexiChains.stat_indices","text":"stat_indices(summary::FlexiSummary)::DimensionalData.Lookup\n\nThe indices for each statistic in the summary. This may be nothing if the stat  dimension has been collapsed.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.renumber_iters","page":"Public API","title":"FlexiChains.renumber_iters","text":"renumber_iters(\n    chain::FlexiChain{TKey},\n    iter_indices::AbstractVector{<:Integer}=1:niters(chain)\n)::FlexiChain{TKey} where {TKey}\n\nReturn a copy of chain with the iteration indices replaced by iter_indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.renumber_chains","page":"Public API","title":"FlexiChains.renumber_chains","text":"renumber_chains(\n    chain::FlexiChain{TKey},\n    chain_indices::AbstractVector{<:Integer}=1:nchains(chain)\n)::FlexiChain{TKey} where {TKey}\n\nReturn a copy of chain with the chain indices replaced by chain_indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Key-types","page":"Public API","title":"Key types","text":"","category":"section"},{"location":"api/#FlexiChains.Parameter","page":"Public API","title":"FlexiChains.Parameter","text":"Parameter{T}(name::T)\n\nA named parameter in a FlexiChain. The name can be of any type, but all parameters in a FlexiChain must have the same type for their names.\n\nSpecifically, if you have a FlexiChain{TKey}, then all parameters must be of type Parameter{TKey}.\n\n\n\n\n\n","category":"type"},{"location":"api/#FlexiChains.Extra","page":"Public API","title":"FlexiChains.Extra","text":"Extra(name::Any)\n\nA key in a FlexiChain that is not a parameter. The name of the key itself can be of any type and is not constrained by the type of the FlexiChain.\n\n\n\n\n\n","category":"type"},{"location":"api/#FlexiChains.ParameterOrExtra","page":"Public API","title":"FlexiChains.ParameterOrExtra","text":"ParameterOrExtra{T}\n\nAlias for Union{Parameter{T},Extra}.\n\nAll keys in a FlexiChain{T} must satisfy k isa ParameterOrExtra{<:T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Accessing-key-value-pairs","page":"Public API","title":"Accessing key-value pairs","text":"","category":"section"},{"location":"api/#Base.keys-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.keys","text":"Base.keys(cs::ChainOrSummary)\n\nReturns the keys of the FlexiChain (or summary thereof).\n\nTo obtain only the parameters, use FlexiChains.parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Union{Tuple{TKey}, Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}}, TKey}} where TKey","page":"Public API","title":"Base.haskey","text":"Base.haskey(cs::ChainOrSummary{TKey}, key::TKey) where {TKey}\n\nReturns true if the FlexiChain or summary contains the given name as a parameter key.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Union{Tuple{TKey}, Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}}, Union{FlexiChains.Parameter{var\"#s7\"}, FlexiChains.Extra} where var\"#s7\"<:TKey}} where TKey","page":"Public API","title":"Base.haskey","text":"Base.haskey(cs::ChainOrSummary{TKey}, key::ParameterOrExtra{<:TKey}) where {TKey}\n\nReturns true if the FlexiChain or summary contains the given key.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.parameters-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"FlexiChains.parameters","text":"FlexiChains.parameters(cs::ChainOrSummary{TKey}) where {TKey}\n\nReturns a vector of parameter names in the FlexiChain or summary thereof.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlexiChains.extras-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"FlexiChains.extras","text":"FlexiChains.extras(cs::ChainOrSummary)\n\nReturns a vector of non-parameter names in the FlexiChain or summary thereof.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.values-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.values","text":"Base.values(cs::ChainOrSummary; parameters_only::Bool=false)\n\nReturns the values of the FlexiChain or FlexiSummary, i.e., the matrices obtained by indexing into the chain with each key.\n\nIf parameters_only is true, only the values corresponding to parameter keys are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.pairs-Tuple{Union{FlexiChains.FlexiChain{TKey}, FlexiChains.FlexiSummary{TKey}} where TKey}","page":"Public API","title":"Base.pairs","text":"Base.pairs(cs::ChainOrSummary)\n\nReturns an iterator over the key-value pairs of the FlexiChain or FlexiSummary.\n\nIf parameters_only is true, only the values corresponding to parameter keys are returned.\n\ntip: Tip\nNote that this function allows you to decompose a FlexiChain into a dict-of-arrays, e.g. with OrderedDict(pairs(chain; parameters_only=...)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Indexing-by-key","page":"Public API","title":"Indexing by key","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"For the public interface of getindex, please see the Indexing page.","category":"page"},{"location":"api/#Renaming-keys","page":"Public API","title":"Renaming keys","text":"","category":"section"},{"location":"api/#FlexiChains.map_keys","page":"Public API","title":"FlexiChains.map_keys","text":"FlexiChains.map_keys(f, cs::ChainOrSummary{T})::ChainOrSummary{S} where {T,S}\n\nRename the keys of a FlexiChain or FlexiSummary by applying the function f to each key.\n\nf must have the signature f(::ParameterOrExtra{<:T}) -> ParameterOrExtra{<:S}. It must return a unique key for each input key.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.map_parameters","page":"Public API","title":"FlexiChains.map_parameters","text":"FlexiChains.map_parameters(f, cs::ChainOrSummary{T})::ChainOrSummary{S} where {T,S}\n\nRename the parameters of a FlexiChain or FlexiSummary by applying the function f to each parameter name.\n\nf must have the signature f(::T) -> S. It must return a unique parameter for each input parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/#Accessing-metadata","page":"Public API","title":"Accessing metadata","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Chains additionally store some metadata:","category":"page"},{"location":"api/#FlexiChains.sampling_time","page":"Public API","title":"FlexiChains.sampling_time","text":"sampling_time(chain::FlexiChain):Vector\n\nReturn the time taken to sample each chain (in seconds). If the time was not recorded, this will be missing.\n\nNote that this always returns a vector with length equal to the number of chains.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.last_sampler_state","page":"Public API","title":"FlexiChains.last_sampler_state","text":"last_sampler_state(chain::FlexiChain)::Vector\n\nReturn the final state of the sampler used to generate the chain, if the save_state=true keyword argument was passed to sample. This can be used for resuming MCMC sampling.\n\nIf the state was not saved for a given chain, its entry in the vector will be missing.\n\nnote: Returns a vector\nThis function always returns a vector of sampler states, even if there is only one chain. Consequently, if you are resuming a single-chain MCMC run like sample(model, spl, N), you will need to extract the sole element of the returned vector before passing it as the initial_state keyword argument to sample(). Please see the ['using with Turing'](@ref Saving-and-resuming-MCMC-sampling-progress) page, or [the Turing.jl documentation page oninitial_state`](https://turinglang.org/docs/usage/sampling-options/#saving-and-resuming-sampling), for more explanation of this.\n\n\n\n\n\n","category":"function"},{"location":"api/#Combining-chains","page":"Public API","title":"Combining chains","text":"","category":"section"},{"location":"api/#Base.vcat-Union{Tuple{T}, Tuple{FlexiChains.FlexiChain{T}, FlexiChains.FlexiChain{T}}} where T","page":"Public API","title":"Base.vcat","text":"Base.vcat(cs...::FlexiChain{TKey}) where {TKey}\n\nConcatenate one or more FlexiChains along the iteration dimension. Both c1 and c2 must have the same number of chains and the same key type.\n\nThe resulting chain's keys are the union of both input chains' keys. Any keys that only have data in one of the arguments will be assigned missing data in the other chain during concatenation.\n\nThe resulting chain's sampling time is the sum of the input chains' sampling times, and the last sampler state is taken from the second chain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.hcat-Union{Tuple{T}, Tuple{FlexiChains.FlexiChain{T}, FlexiChains.FlexiChain{T}}} where T","page":"Public API","title":"Base.hcat","text":"Base.hcat(cs...::FlexiChain{TKey}) where {TKey}\n\nConcatenate one or more FlexiChains along the chain dimension. Both c1 and c2 must have the same number of iterations and the same key type.\n\nThe resulting chain's keys are the union of both input chains' keys. Any keys that only have data in one of the arguments will be assigned missing data in the other chain during concatenation.\n\nThe resulting chain's sampling times and last sampler states are obtained by concatenating those of the input chains.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.merge-Union{Tuple{T}, Tuple{FlexiChains.FlexiChain{T}, FlexiChains.FlexiChain{T}}} where T","page":"Public API","title":"Base.merge","text":"Base.merge(\n    c1::FlexiChain{TKey1},\n    c2::FlexiChain{TKey2}\n) where {TKey1,TKey2}\n\nMerge the contents of two FlexiChains. If there are keys that are present in both chains, the values from c2 will overwrite those from c1.\n\nIf the key types are different, the resulting FlexiChain will have a promoted key type, and a warning will be issued.\n\nThe two FlexiChains being merged must have the same dimensions.\n\nThe chain indices and metadata are taken from the second chain. Those in the first chain are silently ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subsetting-chains","page":"Public API","title":"Subsetting chains","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"You can do these with getindex too, but these functions are sometimes more convenient.","category":"page"},{"location":"api/#FlexiChains.subset_parameters","page":"Public API","title":"FlexiChains.subset_parameters","text":"subset_parameters(cs::ChainOrSummary)\n\nSubset a chain or summary, retaining only the Parameter keys.\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.subset_extras","page":"Public API","title":"FlexiChains.subset_extras","text":"subset_extras(chain::FlexiChain)\n\nSubset a chain, retaining only the keys that are Extras (i.e. not parameters).\n\n\n\n\n\n","category":"function"},{"location":"api/#Extracting-per-iteration-samples","page":"Public API","title":"Extracting per-iteration samples","text":"","category":"section"},{"location":"api/#FlexiChains.values_at","page":"Public API","title":"FlexiChains.values_at","text":"FlexiChains.values_at(\n    chn::FlexiChain{TKey},\n    iter,\n    chain,\n    Tout::Type{T}=OrderedDict\n) where {TKey,T}\n\nExtract all values from the chain corresponding to a particular set of MCMC iterations(s).\n\nThe iter and chain arguments can be anything used to index into the respective dimensions of a FlexiChain, such as an integer, a range, or a DimensionalData.jl selector.\n\nIn particular, you can convert the entire chain into a DimMatrix of the desired output type by passing : for both arguments.\n\nTo get only the parameter keys, use FlexiChains.parameters_at.\n\nThe output type can be specified with the Tout keyword argument. Possible options are:\n\nTout <: AbstractDict: returns a dictionary mapping ParameterOrExtra{TKey} to their values. This is the most faithful representation of the data in the chain.\nTout = NamedTuple, or Tout = ComponentArrays: attempts to convert every key name to a Symbol, which is used as the field name in the outputNamedTupleorComponentArray`.\n\nwarning: Using `NamedTuple` or `ComponentArray`\nThis will throw an error if any key cannot be converted to a Symbol, or if there are duplicate key names after conversion. If you have parameter names that convert to the same Symbol, you can either use OrderedDict, subset the chain before calling this function, or rename your parameters. Furthermore, please be aware that this is a lossy conversion as it does not retain information about whether a key is a parameter or an extra.\n\nFor order-sensitive output types, such as OrderedDict, the keys are returned in the same order as they are stored in the FlexiChain. This also corresponds to the order returned by keys(chn).\n\n\n\n\n\n","category":"function"},{"location":"api/#FlexiChains.parameters_at","page":"Public API","title":"FlexiChains.parameters_at","text":"FlexiChains.parameters_at(\n    chn::FlexiChain{TKey},\n    iter::Union{Int,DD.At},\n    chain::Union{Int,DD.At},\n    Tout::Type{T}=OrderedDict\n) where {TKey,T}\n\nExtract all parameter values from the chain corresponding to a particular set of MCMC iteration(s), discarding non-parameter (i.e. Extra) keys.\n\nThe iter and chain arguments can be anything used to index into the respective dimensions of a FlexiChain, such as an integer, a range, or a DimensionalData.jl selector.\n\nIn particular, you can convert the entire chain into a DimMatrix of the desired output type by passing : for both arguments.\n\nTo get all keys (not just parameters), use FlexiChains.values_at.\n\nThe output type can be specified with the Tout keyword argument. Possible options are:\n\nTout <: AbstractDict: returns a dictionary mapping TKey to their values\nTout = NamedTuple or Tout <: ComponentArray: attempts to convert every parameter name  to a Symbol, which is used as the field name in the output NamedTuple or  ComponentArray.\n\nwarning: Using `NamedTuple` or `ComponentArray`\nThis will throw an error if any key cannot be converted to a Symbol, or if there are duplicate key names after conversion. If you have parameter names that convert to the same Symbol, you can either use OrderedDict, subset the chain before calling this function, or rename your parameters. Furthermore, please be aware that this is a lossy conversion as it does not retain information about whether a key is a parameter or an extra.\n\nFor order-sensitive output types, such as OrderedDict, the parameters are returned in the same order as they are stored in the FlexiChain. This also corresponds to the order returned by FlexiChains.parameters(chn).\n\n\n\n\n\n","category":"function"},{"location":"api/#Splitting-up-VarNames","page":"Public API","title":"Splitting up VarNames","text":"","category":"section"},{"location":"api/#FlexiChains.split_varnames","page":"Public API","title":"FlexiChains.split_varnames","text":"FlexiChains.split_varnames(cs::ChainOrSummary{<:VarName})\n\nSplit up a chain, which in general may contain array- or other-valued parameters, into a chain containing only scalar-valued parameters. This is done by replacing the original VarName keys with appropriate leaves. For example, if x is a vector-valued parameter, then it is replaced by x[1], x[2], etc.\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-with-Turing.jl","page":"Public API","title":"Integration with Turing.jl","text":"","category":"section"},{"location":"api/#DynamicPPL.logprior","page":"Public API","title":"DynamicPPL.logprior","text":"DynamicPPL.logprior(model::DynamicPPL.Model, chain::FlexiChain{<:VarName})\n\nReturns a DimMatrix of the log-prior probabilities, re-evaluated using the parameters at each iteration of the chain.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.loglikelihood","page":"Public API","title":"StatsAPI.loglikelihood","text":"DynamicPPL.loglikelihood(model::DynamicPPL.Model, chain::FlexiChain{<:VarName})\n\nReturns a DimMatrix of the log-likelihoods, re-evaluated using the parameters at each iteration of the chain.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.logjoint","page":"Public API","title":"DynamicPPL.logjoint","text":"DynamicPPL.logjoint(model::DynamicPPL.Model, chain::FlexiChain{<:VarName})\n\nReturns a DimMatrix of the log-joint probabilities, re-evaluated using the parameters at each iteration of the chain.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.returned","page":"Public API","title":"DynamicPPL.returned","text":"DynamicPPL.returned(model::DynamicPPL.Model, chain::FlexiChain{<:VarName})\n\nReturns a DimMatrix of the model's return values, re-evaluated using the parameters in each iteration of the chain.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.predict","page":"Public API","title":"StatsAPI.predict","text":"DynamicPPL.predict(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model,\n    chain::FlexiChain{<:VarName};\n    include_all::Bool=true,\n)\n\nReturns a new FlexiChain containing predictions for variables in the model, conditioned on the parameters in each iteration of the input chain.\n\nThe returned FlexiChain by default will contain all the predicted variables, as well as the variables already present in the input chain. If you only want the predicted variables, set include_all=false.\n\nThe returned chain will also contain log-probabilities corresponding to the re-evaluation of the model. In particular, the log probability for the newly predicted variables are now considered as prior terms. However, note that the log-prior of the returned chain will also contain the log-prior terms of the parameters already present in the input chain. Thus, if you want to obtain the log-probability of the predicted variables only, you can subtract the two log-prior terms. The include_all keyword argument has no effect on the log-probability fields.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.pointwise_logdensities","page":"Public API","title":"DynamicPPL.pointwise_logdensities","text":"DynamicPPL.pointwise_logdensities(\n    model::Model,\n    chain::FlexiChain{T},\n    ::Val{whichlogprob}=Val(:both),\n)::FlexiChain{T} where {T<:VarName,whichlogprob}\n\nCalculate the log probability density associated with each variable in the model, for each iteration in the FlexiChain.\n\nThe whichlogprob argument controls which log probabilities are calculated and stored. It can take the values :prior, :likelihood, or :both (the default).\n\nReturns a new FlexiChain with the same structure as the input chain, mapping the variables to their log probabilities.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.pointwise_loglikelihoods","page":"Public API","title":"DynamicPPL.pointwise_loglikelihoods","text":"DynamicPPL.pointwise_loglikelihoods(\n    model::Model,\n    chain::FlexiChain{<:VarName},\n)::FlexiChain{VarName} where\n\nCalculate the log likelihood associated with each observed variable in the model, for each iteration in the FlexiChain.\n\nReturns a new FlexiChain with the same structure as the input chain, mapping the observed variables to their log probabilities.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.pointwise_prior_logdensities","page":"Public API","title":"DynamicPPL.pointwise_prior_logdensities","text":"DynamicPPL.pointwise_prior_logdensities(\n    model::Model,\n    chain::FlexiChain{<:VarName},\n)::FlexiChain{VarName} where\n\nCalculate the log likelihood associated with each observed variable in the model, for each iteration in the FlexiChain.\n\nReturns a new FlexiChain with the same structure as the input chain, mapping the observed variables to their log probabilities.\n\n\n\n\n\n","category":"function"},{"location":"api/#MCMCChains.Chains","page":"Public API","title":"MCMCChains.Chains","text":"MCMCChains.Chains(chain::FlexiChain{<:VarName})\n\nConvert a FlexiChain{<:VarName} to an MCMCChains.Chains object.\n\nArray-valued VarNames are split up into their individual real-valued elements, much like the output that you get directly from sampling with Turing + MCMCChains.\n\nnote: Splitting VarNames\nIf your only aim is to split VarNames, you can use FlexiChains.split_varnames instead. The conversion to MCMCChains is only useful if you specifically want to use functionality that is only available in MCMCChains.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.loadstate","page":"Public API","title":"DynamicPPL.loadstate","text":"DynamicPPL.loadstate(chain::FlexiChain{<:VarName})\n\nExtracts the last sampler state from a FlexiChain. This is the same function as  FlexiChains.last_sampler_state.\n\nnote: Returns a vector\nThis function always returns a vector of sampler states, even if there is only one chain. Consequently, if you are resuming a single-chain MCMC run like sample(model, spl, N), you will need to extract the sole element of the returned vector before passing it as the initial_state keyword argument to sample(). Please see the ['using with Turing'](@ref Saving-and-resuming-MCMC-sampling-progress) page, or [the Turing.jl documentation page oninitial_state`](https://turinglang.org/docs/usage/sampling-options/#saving-and-resuming-sampling), for more explanation of this.\n\n\n\n\n\n","category":"function"},{"location":"api/#Summaries","page":"Public API","title":"Summaries","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"The summaries interface is documented on the summarising page.","category":"page"},{"location":"api/#Plotting","page":"Public API","title":"Plotting","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"The plotting interface is documented on the plotting page.","category":"page"},{"location":"summarising/#Summarising","page":"Summarising","title":"Summarising","text":"","category":"section"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"In general a FlexiChain contains data in matrices of size (niters, nchains). Often it is useful to summarise this data along one or both dimensions.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"FlexiChains allows you to calculate one or more statistics for each variable stored in a FlexiChain. The result is a FlexiSummary object, which can be indexed into in a very similar way to FlexiChains: see the Indexing page for full details, or the examples on this page.","category":"page"},{"location":"summarising/#Unsupported-data-types","page":"Summarising","title":"Unsupported data types","text":"","category":"section"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"Before we launch into the available summary statistics, it is worth mentioning one point about data types. Since FlexiChains allows for storage of completely arbitrary data types, it can contain data for which the mean (or other statistic) is not defined. For example, the mean of String values is not defined. In such cases, the key will be silently dropped from the result, and a warning issued (you can suppress the warning by passing the warn=false keyword argument).","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"If multiple summary statistics are requested (e.g. with summarystats), the key is only dropped if all of them fail. If at least one statistic is successfully computed for a key, that key will be included in the result, with missing values for the statistics that failed.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"To give a flavour of how this works, here is an example:","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"using FlexiChains, Turing\n\n@model function f()\n    f ~ Normal()               # float\n    v ~ MvNormal(zeros(2), I)  # vector\n    s := \"a string\"            # string\nend\n\nchain = sample(f(), MH(), MCMCThreads(), 20, 3; chain_type=VNChain)","category":"page"},{"location":"summarising/#Overall-summary-statistics","page":"Summarising","title":"Overall summary statistics","text":"","category":"section"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"If you want a quick overview of what's in your chain, summarystats provides a handy selection of commonly used statistics:","category":"page"},{"location":"summarising/#StatsBase.summarystats-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"StatsBase.summarystats","text":"StatsBase.summarystats(\n    chain::FlexiChain{TKey};\n    split_varnames::Bool=(TKey<:VarName),\n    warn::Bool=false,\n) where {TKey}\n\nCompute a standard set of summary statistics for each key in the chain. The statistics include:\n\nmean (using Statistics.mean)\nstandard deviation (Statistics.std)\nMonte Carlo standard error (MCMCDiagnosticTools.mcse)\nbulk effective sample size (MCMCDiagnosticTools.ess)\ntail effective sample size\nR-hat diagnostic (MCMCDiagnosticTools.rhat)\n5th, 50th (median), and 95th percentiles (Statistics.quantile)\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nIf any of the statistics cannot be computed for a key, a missing value is returned. If none of the statistics can be computed for a key, that key will be dropped from the resulting FlexiSummary, and a warning issued. The warning can be suppressed by setting warn=false.\n\n\n\n\n\n","category":"method"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"st = summarystats(chain)","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"Note that in the result, the vector-valued v has been broken up into its individual elements v[1] and v[2]. This happens automatically for chains with VarName keys; you can disable this behaviour by passing split_varnames=false.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"You can index with a variable name (or names!) and the stat dimension:","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"st[@varname(v[1]), stat=At(:mean)]  # Mean of first element of vector v","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"note: At()\nNotice to access the mean you have to use stat=At(:mean) rather than just stat=:mean. This seems a bit verbose, but is actually perfectly consistent with DimensionalData.jl's behaviour: stat=1 means the first statistic, and stat=At(:f) means the statistic with the named index :f.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"For more details on indexing, please see the Indexing page.","category":"page"},{"location":"summarising/#Individual-statistics","page":"Summarising","title":"Individual statistics","text":"","category":"section"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"Sometimes you may only want to calculate a single statistic.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"The following functions are all overloaded to accept FlexiChain objects. In all cases, they can be called with dims=:both, dims=:iter, or dims=:chain to specify the dimension over which to compute the statistic; the default is dims=:both.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"All of these functions return a FlexiSummary where the :stat dimension has already been collapsed. That means that if you want to access the mean of a variable @varname(a) you don't need to further use the stat dimension:","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"m = mean(chain)\n# Not needed: mean_f = m[@varname(f), stat=At(:mean)]\n# Just do:\nmean_f = m[@varname(f)]","category":"page"},{"location":"summarising/#Statistics.mean-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Statistics.mean","text":"Statistics.mean(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the mean across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.mean; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Statistics.median-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Statistics.median","text":"Statistics.median(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the median across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.median; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Statistics.std-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Statistics.std","text":"Statistics.std(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the standard deviation across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.std; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Statistics.var-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Statistics.var","text":"Statistics.var(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the variance across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Statistics.var; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Statistics.quantile-Tuple{FlexiChains.FlexiChain, Any}","page":"Summarising","title":"Statistics.quantile","text":"Statistics.quantile(\n    chain::FlexiChain{TKey},\n    p;\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the quantile across all iterations and chains for each key in the chain. If it cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse.\n\n:iter: collapse the iteration dimension only\n:chain: collapse the chain dimension only\n:both: collapse both the iteration and chain dimensions (default)\n\nThe argument p specifies the quantile to compute, and is forwarded to Statistics.quantile, along with any other keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Base.minimum-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Base.minimum","text":"Base.minimum(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the minimum across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.minimum; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Base.maximum-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Base.maximum","text":"Base.maximum(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the maximum across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.maximum; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Base.sum-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Base.sum","text":"Base.sum(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the sum across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.sum; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#Base.prod-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"Base.prod","text":"Base.prod(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the product across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to Base.prod; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#MCMCDiagnosticTools.ess-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"MCMCDiagnosticTools.ess","text":"MCMCDiagnosticTools.ess(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the effective sample size across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to MCMCDiagnosticTools.ess; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#MCMCDiagnosticTools.rhat-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"MCMCDiagnosticTools.rhat","text":"MCMCDiagnosticTools.rhat(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the R-hat diagnostic across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to MCMCDiagnosticTools.rhat; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#MCMCDiagnosticTools.mcse-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"MCMCDiagnosticTools.mcse","text":"MCMCDiagnosticTools.mcse(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the Monte Carlo standard error across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to MCMCDiagnosticTools.mcse; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#StatsBase.mad-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"StatsBase.mad","text":"StatsBase.mad(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the median absolute deviation across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to StatsBase.mad; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#StatsBase.geomean-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"StatsBase.geomean","text":"StatsBase.geomean(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the geometric mean across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to StatsBase.geomean; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#StatsBase.harmmean-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"StatsBase.harmmean","text":"StatsBase.harmmean(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the harmonic mean across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to StatsBase.harmmean; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/#StatsBase.iqr-Tuple{FlexiChains.FlexiChain}","page":"Summarising","title":"StatsBase.iqr","text":"StatsBase.iqr(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the interquartile range across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to StatsBase.iqr; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"For highest density intervals and equal-tailed intervals, you will need to load PosteriorStats as these are defined in an extension.","category":"page"},{"location":"summarising/#Custom-statistics","page":"Summarising","title":"Custom statistics","text":"","category":"section"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"There are two scenarios where the above are not enough:","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"you want to calculate a specific set of statistics that is not the same as what summarystats does; or\nyou want to calculate a completely custom statistic, which is not implemented above.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"In both cases, you can directly use [FlexiChains.collapse] to achieve this. (But in the latter case, please do also consider opening an issue so that we can implement it!)","category":"page"},{"location":"summarising/#FlexiChains.collapse","page":"Summarising","title":"FlexiChains.collapse","text":"FlexiChains.collapse(\n    chain::FlexiChain,\n    funcs::AbstractVector;\n    dims::Symbol=:both,\n    warn::Bool=true,\n    drop_stat_dim::Bool=false,\n)\n\nLow-level function to collapse one or both dimensions of a FlexiChain by applying a list of summary functions.\n\nThe funcs argument must be a vector which contains either:\n\ntuples of the form (statistic_name::Symbol, func::Function); or\njust functions, in which case the statistic name is obtained from the function name.\n\nThe dims keyword argument specifies which dimensions to collapse. By default, dims is :both, which collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe functions in funcs must have the following behaviour:\n\nthey must map a vector to a single value;\ntheir output must not be dependent on the order of the inputs.\n\nFor example, both Statistics.mean and Statistics.std satisfy these properties:\n\nusing FlexiChains: collapse\nusing Statistics: mean, std\n\ncollapse(chn, [mean, std]; dims=:both)\n\nIf dims=:iter or dims=:chain are selected, then the functions are automatically applied to each column or row as appropriate. No adjustment to the functions is necessary:\n\ncollapse(chn, [mean, std]; dims=:iter)\ncollapse(chn, [mean, std]; dims=:chain)\n\nSometimes, for more complicated functions like quantile, you have to pass an anonymous function (such as x -> quantile(x, 0.05) or a closure (such as Base.Fix2(quantile, 0.05)). In this case, to get a sensible statistic name, instead of just passing the function you can pass a tuple of the form (statistic_name::Symbol, func::Function).\n\ncollapse(chn, [\n    mean,\n    std,\n    (:q5, x -> quantile(x, 0.05)),\n    (:q95, x -> quantile(x, 0.95)),\n])\n\nIf a statistic function errors when applied to a key, that key is skipped and a warning is issued. The warning can be suppressed by setting warn=false.\n\nIf the drop_stat_dim keyword argument is true and only one function is provided in funcs, then the resulting FlexiSummary will have the stat dimension dropped. This allows for easier indexing into the result when only one statistic is computed. It is an error to set drop_stat_dim=true when more than one function is provided.\n\n\n\n\n\n","category":"function"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"As an example, suppose you have a statistic that calculates the sum of the mean and standard deviation. (This is of course quite contrived: if you have a real example, again, please do open an issue!)","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"We start by defining our own function:","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"using Statistics\n\nfunction mean_std_sum(x::AbstractVector{<:Real})\n    return mean(x) + std(x)\nend","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"As noted in the docstring of FlexiChains.collapse, the function you provide must accept a vector argument and return a single value. Of course, it can also have other methods, but this is the one which collapse uses.","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"Now we can use collapse to apply this function to all variables in the chain. The second argument is a vector, which in this case will only contain our one function:","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"custom_stat = FlexiChains.collapse(chain, [mean_std_sum]; dims=:both)","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"There are two things worth mentioning, which we will note in passing here without demonstrating (since they are also covered in the docstring):","category":"page"},{"location":"summarising/","page":"Summarising","title":"Summarising","text":"If there is only one function provided, you can additionally pass drop_stat_dim=true to remove the :stat dimension from the result, much like what mean(chain) et al. do.\nThe name of the statistic is inferred from the function. Sometimes this doesn't work out nicely, for example if you pass an anonymous function. In this case you can provide a tuple of (:name, function) instead of just the function.","category":"page"},{"location":"turing/#Usage-with-Turing.jl","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"This page provides a fairly high-level overview of how to use FlexiChains with Turing.jl.","category":"page"},{"location":"turing/#Sampling","page":"Usage with Turing.jl","title":"Sampling","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To obtain a FlexiChain from Turing.jl, you will need to specify a chain_type of FlexiChains.VNChain when performing MCMC sampling.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Let's use a non-trivial model so that we can illustrate some features of FlexiChains.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using Turing, FlexiChains\n\ny = [28, 8, -3, 7, -1, 1, 18, 12]\nsigma = [15, 10, 16, 11, 9, 11, 10, 18]\n@model function eight_schools(y, sigma)\n    mu ~ Normal(0, 5)\n    tau ~ truncated(Cauchy(0, 5); lower=0)\n    theta ~ MvNormal(fill(mu, length(y)), tau^2 * I)\n    for i in eachindex(y)\n        y[i] ~ Normal(theta[i], sigma[i])\n    end\n    return (mu=mu, tau=tau)\nend\nmodel = eight_schools(y, sigma)\nchain = sample(model, NUTS(), 5; chain_type=VNChain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Note\nWe only run 5 MCMC iterations here to keep the output in the following sections small.","category":"page"},{"location":"turing/#Key-types","page":"Usage with Turing.jl","title":"Key types","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"First, notice in the printout above that a FlexiChain stores 'parameters' and 'extra keys' separately. Parameters correspond to random variables of the model you sampled from, whereas other keys are extra data associated with the samples drawn (for example, the log-joint probability of each sample).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In FlexiChains, these are wrapped in the FlexiChains.Parameter and FlexiChains.Extra types respectively. Thus, the parameter mu is really stored as Parameter(@varname(mu)), and the log-joint probability is Extra(:logjoint).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"For a FlexiChain{T}, all Parameter keys must wrap objects that subtype T. Extras on the other hand can wrap anything.","category":"page"},{"location":"turing/#Accessing-data","page":"Usage with Turing.jl","title":"Accessing data","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"FlexiChains provides multiple different ways to access the data for a given key.","category":"page"},{"location":"turing/#Parameters","page":"Usage with Turing.jl","title":"Parameters","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To access parameters, the recommended way is to use VarNames to index into the chain. VarName is a data structure defined in AbstractPPL.jl, and is what Turing.jl uses to represent the name of a random variable (appearing on the left-hand side of a tilde-statement).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"VarNames are most easily constructed by applying the @varname macro to the name of the variable that you want to access. For example, this directly gives us the value of mu in each iteration as a plain old vector of floats.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(mu)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: `Parameter`\nWhen looking up a parameter, you do not need to wrap the VarName in FlexiChains.Parameter(...): this will be automatically done for you.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: DimMatrix\nIndexing into a FlexiChain returns a DimensionalData.DimMatrix. This behaves exactly like a regular Matrix, but additionally carries extra information about its dimensions.This allows you to keep track of what each dimension means, and also allows for more advanced indexing operations, which are described in the 'indexing' page.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"For vector-valued parameters like theta, this works in exactly the same way, except that you get a DimMatrix of vectors.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(theta)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Note that the samples are stored not as a 3D array, but rather a matrix of vectors. This is probably the biggest difference between FlexiChains and MCMCChains. MCMCChains by default will break vector-valued parameters into multiple scalar-valued parameters called theta[1], theta[2], etc., whereas FlexiChains keeps them together as they were defined in the model.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you want to obtain only the first element of theta, you can index into it with the corresponding VarName:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(theta[1])]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In this way, you can 'break down', or access nested fields of, larger parameters. That is, if your model has x ~ dist, FlexiChains will let you access some field or index of x.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Heterogeneous data\nIf some samples of x have one element and others have two elements, attempting to access x[2] will return an array with missing values for the samples where x only has one element.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Sub-variables\nYou can access sub-variables of a model parameter, but not the other way around. If your model looks like@model function f()\n    x[1] ~ dist\n    return x[2] ~ dist\nendor alternatively@model function f()\n    x = Vector{Float64}(undef, 2)\n    return x .~ dist\nendyou cannot 'reconstruct' x from its component elements, because x does not exist as a single parameter in the model. (Or at least, you can't do it with FlexiChains. You can still call chain[@varname(x[1])] and chain[@varname(x[2])] and then perform hcat or similar to put them together yourself.)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"You can also use keyword arguments when indexing to specify which chains or iterations you are interested in. Note that when using square brackets to index, keyword arguments must be separated by commas, not semicolons!","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[@varname(mu), iter=2:4, chain=1]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The indexing behaviour of FlexiChains is described fully on the next page.","category":"page"},{"location":"turing/#Other-keys","page":"Usage with Turing.jl","title":"Other keys","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"In general Turing.jl tries to package up some extra metadata into the chain that may be helpful. For example, the log-joint probability of each sample is stored with the key :logjoint. To access non-parameter information like this in an unambiguous fashion, you should use the Extra wrapper.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using FlexiChains: Extra\n\nchain[Extra(:logjoint)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"warning: Warning\nMCMCChains stores the log-joint probability as :lp. FlexiChains uses :logjoint instead, which is clearer. It is possible that MCMCChains may be changed to use :logjoint in the future, but for now this is another difference to be aware of.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If there is no ambiguity in the symbol :logjoint, then you can use a shortcut which is described in the next section.","category":"page"},{"location":"turing/#Indexing-by-Symbol:-a-shortcut","page":"Usage with Turing.jl","title":"Indexing by Symbol: a shortcut","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you are used to MCMCChains.jl, you may find this more cumbersome than before. So, FlexiChains provides some shortcuts for accessing data. You can index into a FlexiChain with a single Symbol, and as long as it is unambiguous, it will return the corresponding data.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[:mu] # parameter","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: What does unambiguous mean?\nIn this case, because the only key k for which Symbol(k.name) == :mu is Parameter(@varname(mu)), we can safely identify Parameter(@varname(mu)) as the key that we want. If this chain also had an extra key called Extra(:mu), then this would be ambiguous, and FlexiChains would throw an error.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: No sub-varnames\nYou cannot use chain[Symbol(\"theta[1]\")] as a replacement for chain[@varname(theta[1])].","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Likewise, we can omit wrapping :logjoint in Extra(...):","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chain[:logjoint] # other key","category":"page"},{"location":"turing/#Splitting-VarNames-up","page":"Usage with Turing.jl","title":"Splitting VarNames up","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The way that FlexiChains keeps vector-valued parameters together can make it more difficult to perform subsequent analyses, such as summarising or plotting. Therefore, to 'break up' parameters into their constituent sub-VarNames, you can use FlexiChains.split_varnames:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"split_varnames(chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Do note that this is a lossy conversion. There is no way to un-split the chain! Furthermore, while functions like predict will still work with a split chain, there will be substantial performance regressions. It is therefore strongly recommended that you only split a chain up only when necessary, and never earlier than that.","category":"page"},{"location":"turing/#Summary-statistics","page":"Usage with Turing.jl","title":"Summary statistics","text":"","category":"section"},{"location":"turing/#Overall-summaries","page":"Usage with Turing.jl","title":"Overall summaries","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"For a very quick summary of the chain, you can use StatsBase.summarystats (which FlexiChains reexports):","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using FlexiChains: summarystats\n\nsummarystats(chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"By default, summarystats will split VarNames up. This is done because summary statistics often only make sense for scalar-valued parameters, and users are unlikely to use a FlexiSummary to a performance-critical task. If you want to avoid this, you can set split_varnames=false:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"summarystats(chain; split_varnames=false)","category":"page"},{"location":"turing/#Individual-summaries","page":"Usage with Turing.jl","title":"Individual summaries","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"You can obtain, for example, the mean of each key in the chain using Statistics.mean. This returns a FlexiSummary object:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using Statistics: mean\n\nmn = mean(chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"You can index into a FlexiSummary in exactly the same ways as a FlexiChain.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"mn[@varname(mu)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Out of the box, FlexiChains provides:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"Statistics.mean\nStatistics.median\nStatistics.std\nStatistics.var\nStatistics.quantile\nBase.minimum\nBase.maximum\nBase.sum\nBase.prod\nMCMCDiagnosticTools.ess\nMCMCDiagnosticTools.rhat\nMCMCDiagnosticTools.mcse","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"These functions can all be applied to a FlexiChain with their usual signatures (for example, quantile will require a second argument). Keyword arguments of the original functions are also supported, for example ess(chain; kind=:tail) returns the tail ESS.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: Other summary functions\nIf you want to apply a summary function that isn't listed above, you can manually use FlexiChains.collapse. If it is something that is worth appearing in FlexiChains proper, please do open an issue!","category":"page"},{"location":"turing/#Collapsed-dimensions","page":"Usage with Turing.jl","title":"Collapsed dimensions","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"By default, applying summary functions will collapse the data in both the iteration and chain dimensions (the latter is only relevant if multiple chains are present).","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"To only collapse over one dimension you can use","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"mean(chain; dims=:iter)[@varname(mu)]","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"or dims=:chain (although that is probably less useful).","category":"page"},{"location":"turing/#Saving-and-resuming-MCMC-sampling-progress","page":"Usage with Turing.jl","title":"Saving and resuming MCMC sampling progress","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"If you want to sample a fewer number of iterations first and then resume it later, you can use the following:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"chn1 = sample(model, NUTS(), 10;\n    chain_type=VNChain, save_state=true\n)\nchn2 = sample(model, NUTS(), 10;\n    chain_type=VNChain, initial_state=only(FlexiChains.last_sampler_state(chn1))\n)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The chains can be combined using vcat:","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"combined_chn = vcat(chn1, chn2)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"note: The `initial_state` argument\nWhen performing single-chain sampling with sample(model, spl, N; initial_state=state), initial_state should be either nothing (to start a new chain) or the state to resume from. For multiple-chain sampling with sample(model, spl, MCMCThreads(), N, C), initial_state should be a vector of length C, where initial_state[i] is the state to resume the i-th chain from (or nothing to start a new chain).To obtain the saved final state of a chain, you can use FlexiChains.last_sampler_state. This always returns a vector of states with length equal to the number of chains. Note that this applies also if you only sampled a single chain, in which case the returned value is a vector of length 1: you will therefore have to use only() to extract the state itself.The above applies equally to MCMCSerial() and MCMCDistributed().","category":"page"},{"location":"turing/#Posterior-predictions-and-friends","page":"Usage with Turing.jl","title":"Posterior predictions and friends","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"The functions predict, returned, logjoint, loglikelihood, and logprior all work 'as expected' using FlexiChains with exactly the same signatures that you are used to.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"returned(model, chain)","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"pointwise_logdensities, pointwise_loglikelihoods, and pointwise_prior_logdensities are also supported, and will return a new FlexiChain containing the log-probabilities for each variable.","category":"page"},{"location":"turing/#Plotting","page":"Usage with Turing.jl","title":"Plotting","text":"","category":"section"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"FlexiChains contains a few recipes for plotting with StatsPlots.jl; please see the Plotting page for full details.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"When plotting a VNChain, array-valued parameters will automatically be split up into their individual components. In this example we plot only tau and theta[1] to save space, but if you were to plot theta, you would get eight separate plots for each element of theta.","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"using StatsPlots\n\n# Or omit the second argument to plot all parameters.\nplot(chain, [@varname(tau), @varname(theta[1])])\nsavefig(\"plot_ex.svg\"); nothing # hide","category":"page"},{"location":"turing/","page":"Usage with Turing.jl","title":"Usage with Turing.jl","text":"(Image: Trace and density plots for mu, tau, and theta1)","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"FlexiChains defines a few plot recipes which allows you to use the Plots.jl ecosystem to visualise chains. In particular, you will want to import StatsPlots.jl.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"note: Other backends\nIntegration with (at least) Makie.jl is planned, but not yet implemented.","category":"page"},{"location":"plotting/#Plot-types","page":"Plotting","title":"Plot types","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"What kind of plot you get in when using Plots.jl is controlled mainly by the seriestype keyword argument. For example, plot(..., seriestype=:histogram) will produce a histogram. In fact, calling histogram(...) simply redirects to plot(..., seriestype=:histogram).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The following series types are supported for FlexiChain objects.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"seriestype= Equivalent function Description\n:traceplot FlexiChains.traceplot() Trace plot of samples\n:histogram Plots.histogram() Histogram of samples\n:density Plots.density() Kernel density estimate of samples\n:mixeddensity FlexiChains.mixeddensity() Density plot or histogram, depending on whether the parameter is continuous or discrete\n:meanplot FlexiChains.meanplot() Running mean of samples\n:autocorplot FlexiChains.autocorplot() Autocorrelation of samples\n:traceplot_and_density Plots.plot() (with no seriestype argument) Trace plot and mixed density side-by-side","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"warning: Identifier conflicts\nPlease note that the identifiers traceplot, meanplot, mixeddensity, and autocorplot are also exported by MCMCChains.jl and also currently re-exported by Turing.jl. The FlexiChains versions are marked as public but not exported. To make sure you are using the FlexiChains versions, you must prefix them with the module name: FlexiChains.traceplot(...). Otherwise, you may run into unexpected errors. ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"note: Feature parity with MCMCChains.jl\nThere are still substantially fewer options than in MCMCChains.jl. Other plot types will be added over time, but in the meantime if you need features from MCMCChains, you can convert a FlexiChain to an MCMCChains.Chains object using MCMCChains.Chains(chn).","category":"page"},{"location":"plotting/#Signature","page":"Plotting","title":"Signature","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The above plotting functions should be called with the following signature:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plotfunc(\n    chn[, param_or_params];\n    pool_chains::Bool=false,\n    split_varnames::Bool=(chn isa FlexiChain{<:VarName}),\n    kwargs...\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Positional arguments","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"chn is a FlexiChain object.\nparam_or_params is optional, and can be anything that is used to index into a chain. If not provided, all parameters in the chain will be plotted.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"If pool_chains=true, then samples from all chains are concatenated before plotting densities or histograms. Otherwise, each chain is plotted separately.\nsplit_varnames is only applicable if the chain key type is a VarName (as would be obtained from Turing). It controls whether vector-valued parameters are split into their individual components. For example, if z is a 2-dimensional parameter, then setting split_varnames=true will plot z[1] and z[2] separately.\nnote: Note\nPlots.jl will error when attempting to plot vector-valued parameters, so there is no real reason to disable split_varnames, unless you are developing new plot types.","category":"page"},{"location":"plotting/#Gallery","page":"Plotting","title":"Gallery","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Here, we demonstrate the plotting features with a typical chain sampled from a Turing model. However, the general principles are applicable to any FlexiChain object.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"We'll make a model with different types of parameters (continuous, discrete, and vector-valued).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using FlexiChains, StatsPlots, Turing\n\n@model function f()\n    x ~ Normal()\n    y ~ Poisson(3)\n    z ~ MvNormal(zeros(2), I)\nend\n\nchn = sample(\n    f(), MH(), MCMCThreads(), 1000, 3;\n    discard_initial=100, chain_type=VNChain, progress=false\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Notice that the chain has not split z up into z[1] and z[2]. However, when plotting, it will be automatically split up for you:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(chn)\nsavefig(\"plot1.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Trace and density plots of the sampled chain)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Notice that Extra keys, like the log probabilities, are not plotted by default. If you want to plot specific parameter(s), you can specify them as the second positional argument. In general, the second argument can be anything that you can index into a chain with. This means a symbol, a parameter, a FlexiChains.Extra, a sub-VarName, or a vector thereof:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(chn, [@varname(x), :logjoint])\nsavefig(\"plot2.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Trace and density plots of x and the logjoint)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"While the density plots above are useful for comparing whether the chains have mixed well, the overlapping histograms are harder to make sense of. You can combine the histograms by setting pool_chains=true. We'll also hide the legend to reduce clutter (keyword arguments like legend are simply passed through to Plots.jl):","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(chn; pool_chains=true, legend=false)\nsavefig(\"plot3.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Trace and pooled density plots of the sampled chain)","category":"page"},{"location":"plotting/#Docstrings","page":"Plotting","title":"Docstrings","text":"","category":"section"},{"location":"plotting/#FlexiChains.traceplot","page":"Plotting","title":"FlexiChains.traceplot","text":"FlexiChains.traceplot(\n    chn::FlexiChain{TKey}[, param_or_params];\n    kwargs...\n)\n\nCreate a trace plot of the specified parameter(s) in the given FlexiChain.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with traceplot(chn, :).\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"FlexiChains.traceplot(chn)\nsavefig(\"traceplot.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Trace plots of the sampled chain)","category":"page"},{"location":"plotting/#FlexiChains.meanplot","page":"Plotting","title":"FlexiChains.meanplot","text":"FlexiChains.meanplot(\n    chn::FlexiChain{TKey}[, param_or_params];\n    kwargs...\n)\n\nPlot the running mean of the specified parameter(s) in the given FlexiChain.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with meanplot(chn, :).\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"FlexiChains.meanplot(chn)\nsavefig(\"meanplot.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Running mean plots of the sampled chain)","category":"page"},{"location":"plotting/#FlexiChains.autocorplot","page":"Plotting","title":"FlexiChains.autocorplot","text":"FlexiChains.autocorplot(\n    chn::FlexiChain{TKey}[, param_or_params];\n    lags=1:min(niters(chn)-1, round(Int,10*log10(niters(chn)))),\n    demean=true,\n    kwargs...\n)\n\nPlot the autocorrelation of the specified parameter(s) in the given FlexiChain.\n\nThe lags keyword argument can be used to specify which lags to plot. If nothing is passed (the default), this is set to the integers from 1 to min(niters-1, round(Int,10*log10(niters))) where niters is the number of iterations in the chain. This mimics the default behaviour of StatsBase.autocor.\n\nThe demean keyword argument specifies whether to subtract the mean of the parameter before computing the autocorrelation, and is passed to StatsBase.autocor.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with autocorplot(chn, :).\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"FlexiChains.autocorplot(chn)\nsavefig(\"autocorplot.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Autocorrelation plots of the sampled chain)","category":"page"},{"location":"plotting/#FlexiChains.mixeddensity","page":"Plotting","title":"FlexiChains.mixeddensity","text":"FlexiChains.mixeddensity(\n    chn::FlexiChain{TKey}[, param_or_params];\n    kwargs...\n)\n\nCreate either a density plot, or a histogram, of the specified parameter(s) in the given FlexiChain. Continuous-valued parameters are plotted using density plots, discrete-valued parameters with histograms.\n\nIf no parameters are specified, this will plot all parameters in the chain. Note that non-parameter, i.e. Extra, keys are excluded by default. If you want to plot all keys, you can explicitly pass all keys with mixeddensity(chn, :).\n\nKeyword arguments are forwarded to Plots.jl's functions.\n\n\n\n\n\n","category":"function"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"FlexiChains.mixeddensity(chn)\nsavefig(\"mixeddensity.svg\"); nothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Mixed density plots of the sampled chain)","category":"page"},{"location":"indexing/#Indexing","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"A FlexiChain stores data in a  rich format: that means that instead of just storing a raw matrix of data, it also includes information about the iteration numbers and chain numbers.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Additionally, FlexiSummary objects (which you get when performing any kind of summarisation on a chain, e.g. with summarystats) also sometimes store information about which summary functions were applied (especially when there are multiple of these).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This information is used when constructing the DimensionalData.DimArray outputs that you see when indexing into a FlexiChain or FlexiSummary object. But, on top of this, it also allows you to more surgically index into these objects using this information.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This page first begins with some illustrative examples, which might be the clearest way to demonstrate the indexing behaviour. If you prefer reading a fuller specification, the sections below that describe the exact behaviour in more detail.","category":"page"},{"location":"indexing/#Examples:-chains","page":"Indexing","title":"Examples: chains","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Let's first set up a chain:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"using FlexiChains, Turing\n@model function f()\n    x ~ MvNormal(zeros(2), I)\nend\nchn = sample(f(), MH(), MCMCThreads(), 5, 2; discard_initial=100, chain_type=VNChain, progress=false, verbose=false)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Notice how the iteration numbers here start from 101: that is because of the discard_initial argument.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# Picking out a single parameter; this returns a `DimMatrix`.\nchn[@varname(x)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# This picks out the first of the iterations (note: this has iteration number 101)\nchn[@varname(x), iter=1]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"warning: Keyword arguments to `getindex`\nNote that keyword arguments when indexing with square brackets must be separated from positional arguments by a comma. Using a semicolon will lead to an error.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# You can also select a specific chain\nchn[@varname(x), iter=1, chain=2]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# This picks out iteration number 101\nchn[@varname(x), iter=At(101)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# This picks out iteration numbers 101 through 103\nchn[@varname(x), iter=101..103]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# If you only want the first element of `x`:\nchn[@varname(x[1])]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"# You can specify a vector of parameters\nchn[[@varname(x[1]), :logjoint]]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This last one returns a FlexiChain object, because multiple keys were specified. The data that we didn't care for, such as @varname(x[2]), are simply dropped.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Notice that this also gives us a way to 'flatten' a FlexiChain object such that all of its keys point to scalar values. We just need to find a full set of sub-VarNames, like the following. In practice you don't need to construct this set yourself: the split_varnames function will do this for you.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"chn[[@varname(x[1]), @varname(x[2])]]","category":"page"},{"location":"indexing/#Examples:-summaries","page":"Indexing","title":"Examples: summaries","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Calling any summary function such as mean, std, or summarystats on a FlexiChain object will return a FlexiSummary object.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm = summarystats(chn)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Notice two things: ","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"This summary no longer has iter or chain dimensions, because the summary statistics have been calculated over all iterations and chains. However, it has a stat dimension, which we will need to use when accessing the data.\nThe variable x has been broken up for you into its components x[1] and x[2].","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Indexing is very similar as for chains, but there is an additional stat dimension which lets you specify which summary statistic you want to access.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm[@varname(x[1]), stat=At(:mean)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"note: At()\nNotice that we need stat=At(:mean) rather than just stat=:mean. This seems a bit verbose, but is actually perfectly consistent with DimensionalData.jl's behaviour: stat=1 means the first statistic, and stat=At(:f) means the statistic with the named index :f.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If only a single summary function was applied, e.g. via mean(chn), then the stat dimension will be automatically collapsed for you; you won't need to again specify At(:mean) when indexing.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm_mean = mean(chn)\nsm_mean[@varname(x[1])]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If you don't want to split the VarNames up, you can specify this as a keyword argument.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm_mean_nosplit = mean(chn; split_varnames=false)\nsm_mean_nosplit[@varname(x)]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If you collapse only over iterations (for example), then you can specify the chain keyword argument (and likewise for iter if you collapse over chains).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"sm_iter = mean(chn; dims=:iter)\nsm_iter[@varname(x[1]), chain=2]","category":"page"},{"location":"indexing/#Positional-arguments","page":"Indexing","title":"Positional arguments","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"When indexing into a FlexiChain (or FlexiSummary) object, you can use one optional positional argument. This positional argument can either be an object pointing to a single key, in which case a DimMatrix is returned; or it can be an object pointing to multiple keys, in which case a FlexiChain (or FlexiSummary) is returned.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"To specify a single key, you can use:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"a parameter name (e.g. for a FlexiChain{T}, an object of type T);\na VarName or sub-VarName, for a FlexiChain{VarName} (i.e. VNChain);\na FlexiChains.Extra for non-parameter keys;\na Symbol, as long as it refers to an unambiguous key;\na FlexiChains.Parameter (this is mentioned for completeness; as a user you probably don't need to do this)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"On the other hand, you could specify multiple keys via:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"a Vector containing any combination of the above;\na colon :, which refers to all keys in the chain or summary.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If a positional argument is not specified, it defaults to :.","category":"page"},{"location":"indexing/#Keyword-arguments:-chains","page":"Indexing","title":"Keyword arguments: chains","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"In addition to the positional argument, you can also specify the iter and chain keyword arguments when indexing into the FlexiChain object. (FlexiSummary objects are covered right below this.) Both of these are optional, and exist to allow you to select data from specific iterations and/or chains.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"warning: Keyword arguments to getindex\nWhen indexing with square brackets, the keyword arguments must be separated from positional arguments by a comma, not a semicolon as is usual for other Julia functions. That is to say, you should use:chn[param, iter=iter, chain=chain]\n# this is also fine, albeit a bit wordy\ngetindex(chn, param; iter=iter, chain=chain)rather than# this will error\nchn[param; iter=iter, chain=chain]","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"The allowed values for these keyword arguments almost exactly mimic the behaviour of DimensionalData.jl. Suppose that you sampled a chain with 100 iterations, but with a thinning factor of 2. FlexiChains will record this information, and its iteration numbers will be 1:2:199 (i.e. 1, 3, 5, ..., 199).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"For clarity, we will refer to the actual iteration numbers (1, 3, 5, ..., 199) as iteration numbers, and the entries in the chain (1st entry, 2nd entry, ..., 100th entry) as entries.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"You can then specify, for example:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"iter=... Description\n5 the fifth entry in the chain, i.e. iteration number 9\nAt(9) iteration number 9\nNot(5) all entries except the fifth one, i.e. all iteration numbers except 9\nNot(At(9)) all entries except iteration number 9\n6..30 all iteration numbers between 6 and 30, i.e. all but the first entry\n2:10 2nd through 10th entries, i.e. iteration numbers 6 through 30\n[At(9), At(30)] this will get the entries corresponding to iteration numbers 9 and 30\n: all entries (i.e. all iteration numbers)","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"For convenience, FlexiChains re-exports the DimensionalData.jl selectors such as Not, At, and ...","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"The same applies to the chain keyword argument, except that here you are selecting which chains to include. This is slightly less interesting because chains are always numbered consecutively starting from 1. Consequently, i and At(i) have the same meaning. Nonetheless, you can still use all the same selectors as described above, e.g. Not(2) to drop the second chain.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"For more information about DimensionalData's selectors, please see their docs.","category":"page"},{"location":"indexing/#Keyword-arguments:-summaries","page":"Indexing","title":"Keyword arguments: summaries","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"note: Positional arguments\nThe positional argument when indexing into a FlexiSummary objects is exactly the same as for FlexiChain. Only keyword arguments behave differently.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"There are two differences between a FlexiChain and a FlexiSummary in terms of their indexing behaviour:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"FlexiSummary objects contain one additional dimension, called stat.\nFlexiSummary dimensions may be collapsed, meaning that they cannot be indexed into.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Consequently, there are three possible keyword arguments: iter, chain, and stat; but depending on which dimensions have been collapsed, you may not be able to use them.","category":"page"},{"location":"indexing/#iter-and-chain","page":"Indexing","title":"iter and chain","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"In general, if you apply a summary function like mean without specifying dimensions, then both iter and chain dimensions will be collapsed.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"If you have performed the mean over a single dimension only, such as via summary = mean(chn; dims=:iter), then the iter dimension will be collapsed, but you can still index into the chain dimension using summary[key, chain=...].","category":"page"},{"location":"indexing/#stat","page":"Indexing","title":"stat","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"In general, the stat dimension is generally:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"not collapsed if multiple summary functions were applied, e.g. via summarystats(chn);\ncollapsed if a single summary function was applied, e.g. via mean(chn).","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Unlike the iter and chain dimensions, the stat dimension's indices are Symbols instead of numbers. Thus, for example, if you have a summary that contains the mean and std of the chain, you could use:","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"stat=... Description\n1 the first statistic, i.e. :mean\nAt(:mean) the :mean statistic\nNot(At(:mean)) everything but the :mean statistic","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"FlexiChains.jl provides an information-rich data structure for Markov chains.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"FlexiChains.jl is designed to be completely general, in that you can store any kind of data in a FlexiChain. However, its intended primary use is as a drop-in (but better) replacement for MCMCChains.jl in the Turing.jl ecosystem. Thus, there is some extra functionality available for chains that contain AbstractPPL.VarName parameters.","category":"page"},{"location":"integrations/#Integrations-with-other-packages","page":"Integrations with other packages","title":"Integrations with other packages","text":"","category":"section"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"FlexiChains is most obviously tied to the Turing.jl ecosystem, as described on the previous pages. However, it also contains some integrations with other packages.","category":"page"},{"location":"integrations/#PosteriorDB.jl","page":"Integrations with other packages","title":"PosteriorDB.jl","text":"","category":"section"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"Documentation for PosteriorDB.jl","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"If you have loaded a PosteriorDB.ReferencePosterior, you can transform it into a FlexiChain using FlexiChains.from_posteriordb_ref:","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"using PosteriorDB, FlexiChains\n\npdb = PosteriorDB.database()\npost = PosteriorDB.posterior(pdb, \"eight_schools-eight_schools_centered\")\nref = PosteriorDB.reference_posterior(post)\n\nchn = FlexiChains.from_posteriordb_ref(ref)","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"You can then use all the functionality of FlexiChains on chn:","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"summarystats(chn)","category":"page"},{"location":"integrations/#FlexiChains.from_posteriordb_ref","page":"Integrations with other packages","title":"FlexiChains.from_posteriordb_ref","text":"FlexiChains.from_posteriordb_ref(\n    ref::PosteriorDB.ReferencePosterior\n)::FlexiChain{String}\n\nLoad a PosteriorDB.ReferencePosterior into a FlexiChain. The keys are stored as strings, which matches the storage format in PosteriorDB.jl.\n\n\n\n\n\n","category":"function"},{"location":"integrations/#PosteriorStats.jl","page":"Integrations with other packages","title":"PosteriorStats.jl","text":"","category":"section"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"Documentation for PosteriorStats.jl","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"PosteriorStats.jl provides the hdi and eti functions for computing highest density intervals and equal-tailed intervals, respectively. These are overloaded for FlexiChain objects in much the same way as Statistics.mean, Statistics.std, etc. (see the Summarising page for more information).","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"Note however that you will need to import PosteriorStats.jl explicitly to use these functions (as they are implemented in an extension rather than the main package).","category":"page"},{"location":"integrations/#PosteriorStats.hdi-Tuple{FlexiChains.FlexiChain}","page":"Integrations with other packages","title":"PosteriorStats.hdi","text":"PosteriorStats.hdi(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the highest density interval across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to PosteriorStats.hdi; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"integrations/#PosteriorStats.eti-Tuple{FlexiChains.FlexiChain}","page":"Integrations with other packages","title":"PosteriorStats.eti","text":"PosteriorStats.eti(\n    chain::FlexiChain{TKey};\n    dims::Symbol=:both,\n    warn::Bool=true,\n    split_varnames::Bool=(TKey<:VarName),\n    kwargs...\n) where {TKey}\n\nCalculate the equal-tailed interval across all iterations and chains for each key in the chain. If the statistic cannot be computed for a key, that key is skipped and a warning is issued (which can be suppressed by setting warn=false).\n\nThe dims keyword argument specifies which dimensions to collapse. The default value of :both collapses both the iteration and chain dimensions. Other valid values are :iter or :chain, which respectively collapse only the iteration or chain dimension.\n\nThe split_varnames keyword argument, if true, will first split up VarNames in the chain such that each VarName corresponds to a single scalar value. This is only supported for chains with TKey<:VarName.\n\nOther keyword arguments are forwarded to PosteriorStats.eti; please see its documentation for details of supported keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"integrations/#Serialization.jl","page":"Integrations with other packages","title":"Serialization.jl","text":"","category":"section"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"Calling this an 'integration' is a bit of a stretch, because it simply works out of the box (no extra code needed), but it had to be documented somewhere...","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"You can serialise and deserialise FlexiChain and FlexiSummary objects using the Serialization.jl standard library.","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"using FlexiChains, Turing, Serialization\n\n@model f() = x ~ Normal()\nchn = sample(f(), NUTS(), 100; chain_type=VNChain, progress=false)\nfname = \"mychain\"\nserialize(fname, chn)","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"chn2 = deserialize(fname)\nisequal(chn, chn2)","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"Note two things:","category":"page"},{"location":"integrations/","page":"Integrations with other packages","title":"Integrations with other packages","text":"If the serialisation and deserialisation steps are performed in different Julia sessions, you need to make sure that you have all necessary packages loaded in the second session. In particular, if you use save_state=true, then you should load Turing.jl before deserialising, because Turing provides the sampler state types.\nIf you are testing the integrity of (de)serialisation, you may find that isequal() on sampler state types may not return true even when the sampler states are the same. This is because Julia's default definition of equality for structs is based on object identity, not on field values. For example, the following returns false because [1] !== [1].\nstruct Foo{T}\n    t::T\nend\n\nFoo([1]) == Foo([1])","category":"page"},{"location":"why/#Why-FlexiChains?","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"If you are a Turing user (or developer!), you may well be asking why you should consider using FlexiChains.jl.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"In one sentence: FlexiChains is a more faithful representation of data. MCMCChains.jl places extremely strong restrictions on its data structure, which leads to an irrevocable loss of information.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Of course, on its own this doesn't mean much (unless you are a software engineering purist!). So this page will demonstrate a few concrete scenarios where FlexiChains has a practical advantage.","category":"page"},{"location":"why/#Documentation","page":"Why FlexiChains?","title":"Documentation","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"This package is much better documented. In my opinion. (To be fair, I did put a lot of work into it, and if I spent the same amount of time on MCMCChains, I suppose its docs would also look better.)","category":"page"},{"location":"why/#Heterogeneous-parameter-types","page":"Why FlexiChains?","title":"Heterogeneous parameter types","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"using Random, Turing, FlexiChains, MCMCChains\n\n@model function f()\n    x ~ Normal()\n    y ~ Poisson(3.0)\nend","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"When sampling from this model, one should expect that the samples of x are stored as floats, whereas the samples of y are stored as integers, because that is what these distributions produce.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Under the hood, MCMCChains stores the values of all parameters in a single array, which means that all samples get converted into the same type.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"mchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=MCMCChains.Chains)\nfchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=FlexiChains.VNChain)\n(eltype(mchain[:y]), eltype(fchain[:y]))","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"In general, this doesn't cause problems with functions like predict because Distributions.jl kindly allows you to call logpdf(::Poisson, x::Float64) and returns the correct value if isinteger(x). In fact, this is true of all discrete univariate distributions in Distributions.jl. But if you were to define your own discrete distribution, you would have to remember to implement this method, or else you would get an error when trying to use things like predict.","category":"page"},{"location":"why/#Missing-data","page":"Why FlexiChains?","title":"Missing data","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Okay, maybe the above is still quite abstract. (For us, it's not: we actually ran into a bug with Turing's test suite once because of this very issue.) But after all, if it works for everything in Distributions, surely we're fine?","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Consider the case where some data is missing:","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"using Random, Turing, FlexiChains, MCMCChains\n\n@model function f()\n    x ~ Normal()\n    if x > 0\n        y ~ Normal(x)\n    end\nend\n\nmchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=MCMCChains.Chains)\nfchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=FlexiChains.VNChain)","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"In some samples, y will be present and not in others. Because MCMCChains forces all parameters to be in the same array, this means that the entire array must have an element type of Union{Missing, Float64}. With MCMCChains this gets propagated to all parameters, even those that are never missing, such as x.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"(eltype(mchain[:x]), eltype(fchain[:x]))","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Okay, maybe you don't ever have such weird models. It turns out though that you can still run into this. In Turing's MCMC sampling, the first step is not an actual MCMC step, but rather just the initial parameters (either sampled or provided by the user). Thus, there are no 'sampler statistics' for the first step, and these are stored as missing in MCMCChains. That means that all the parameters become Union{Missing, Float64}!","category":"page"},{"location":"why/#Arbitrary-types","page":"Why FlexiChains?","title":"Arbitrary types","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Turing provides this very nice operator :=, which lets you store arbitrary values in the chain during an MCMC run.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"The problem with MCMCChains is, as ever, you can only store things that are Real or some array thereof. Even a simple string will fail:","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"using Random, Turing, FlexiChains, MCMCChains\n\n@model function hasstring()\n    x ~ Normal()\n    y := \"$x\"\nend\ntry #hide\nmchain = sample(Xoshiro(468), hasstring(), MH(), 50; chain_type=MCMCChains.Chains, progress=false)\ncatch e; showerror(stdout, e); end # hide","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"FlexiChains will let you store anything you like. String? No problem. ODE solver output? No problem.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"fchain = sample(Xoshiro(468), hasstring(), MH(), 50; chain_type=FlexiChains.VNChain)","category":"page"},{"location":"why/#Reconstructing-parameters","page":"Why FlexiChains?","title":"Reconstructing parameters","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Suppose you have some array-valued parameter.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"using Random, Turing, FlexiChains, MCMCChains\n\n@model lkj() = x ~ LKJCholesky(3, 2.0)\n\nmchain = sample(Xoshiro(468), lkj(), NUTS(), 50; chain_type=MCMCChains.Chains);\nfchain = sample(Xoshiro(468), lkj(), NUTS(), 50; chain_type=FlexiChains.VNChain);","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"With FlexiChains the Cholesky samples are kept together:","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"fchain[@varname(x)][iter=1, chain=1]","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Because MCMCChains stores all its data in a single array, it has to flatten this parameter, so good luck trying to reconstruct it.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"(mchain[Symbol(\"x.L[1, 1]\")][1, 1], mchain[Symbol(\"x.L[2, 1]\")][1, 1]) # ...","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Of course, if you really wanted to flatten a chain, FlexiChains lets you do that with FlexiChains.split_varnames.","category":"page"},{"location":"why/#VarNames-as-keys","page":"Why FlexiChains?","title":"VarNames as keys","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"Did you notice in that last line we had to write something like Symbol(\"x.L[1, 1]\")? And since it's a Symbol, we have to get the name exactly right, we couldn't do (for example) x.L[1,1] without the space after the comma?","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"That's because MCMCChains uses AxisArrays.jl under the hood, which allows you to index into the chain using Symbols — but only Symbols. FlexiChains retains the original VarNames used by Turing, which is a far richer type and allows you to use keys that actually carry meaning, rather than just being strings that have to match exactly.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"fchain[@varname(x.L[1,1])][iter=1, chain=1] # No space!","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"fchain[@varname(x.L[:, 1])][iter=1, chain=1] # Index into `x` any way you like","category":"page"},{"location":"why/#Performance-(on-important-things)","page":"Why FlexiChains?","title":"Performance (on important things)","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"In the following model, y is a single parameter that is a vector of length N. That means that when you use functions like returned or predict on a chain, MCMCChains has to somehow reconstruct the vector y from its components which are all stored separately.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"using Turing, FlexiChains, MCMCChains, Random\n\n@model function longvec(N)\n    m ~ Normal(0)\n    y ~ filldist(Normal(m), N)\nend","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"It turns out that if N is small, MCMCChains does just fine, and is in fact even faster than FlexiChains (because constructing a FlexiChain has more overhead).","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"using Chairmarks: @be\n\nfunction benchmark(N)\n    model = (longvec(N) | (y = rand(Xoshiro(468), Normal(2.0), N),))\n    mchain = sample(Xoshiro(468), model, NUTS(), 500; chain_type=MCMCChains.Chains);\n    fchain = sample(Xoshiro(468), model, NUTS(), 500; chain_type=FlexiChains.VNChain);\n    mt = @be predict(longvec(N), mchain)\n    ft = @be predict(longvec(N), fchain)\n    return (N=N, mcmcchains=median(mt).time, flexichains=median(ft).time)\nend\n\nbenchmark(2) # The results are in seconds","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"But MCMCChains scales really poorly with N.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"benchmark(1000)","category":"page"},{"location":"why/#Avoiding-name-clashes","page":"Why FlexiChains?","title":"Avoiding name clashes","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"All of Turing.jl's samplers include some 'sampler statistics' in the output chain. These are pretty useful things like the step size, whether a transition was accepted, the log-probabilities, and so on.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"But if you have a parameter that just happens to share a name with these, then MCMCChains will make it pretty hard for you to get one of them.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"using Random, Turing, FlexiChains, MCMCChains\n\n# Oops! This will clash with the actual log prior.\n@model pr() = logprior ~ Normal()\n\nmchain = sample(Xoshiro(468), pr(), MH(), 50; chain_type=MCMCChains.Chains);\ncollect(keys(mchain))","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"There are two columns labelled :logprior. Of course, one is your parameter, the other is the actual log prior probability. It's a mystery which one is which, and which you get when you do mchain[:logprior]! You could avoid this if you knew exactly which keys the sampler returns, but in general this isn't documented anywhere. (It should be, of course.)","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"FlexiChains avoids clashes by completely separating Parameter and Extra keys, meaning that you can use any name you like without worrying about a rogue sampler breaking your workflow.","category":"page"},{"location":"why/#DimensionalData.jl-indexing","page":"Why FlexiChains?","title":"DimensionalData.jl indexing","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"As you will have noticed, FlexiChains uses DimensionalData.jl to return information-rich matrices. That means that you can use all the selectors from DimensionalData.jl to extract exactly what you want. Don't want to use those? No problem; good old 1-based indices work fine too.","category":"page"},{"location":"why/#If-you're-a-Turing-developer...","page":"Why FlexiChains?","title":"If you're a Turing developer...","text":"","category":"section"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"I suppose I am somewhat qualified to comment on this... There are a number of places in TuringLang where the unfaithful data structure of MCMCChains leads to hacky workarounds. Most of them centre around the difficulty of reconstructing vectors x from its flattened components x[1], x[2], and so on.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"For example, AbstractPPLDistributionsExt exists solely for this reason. (None of us are particularly happy about this: see this PR.) The methods defined here allow you to check whether a dictionary like Dict(@varname(x[1]) => 1.0, @varname(x[2]) => 2.0) can be reconstructed into a vector-valued parameter x, given that x is drawn from MvNormal(zeros(2), I). This is precisely because we can only obtain the former dictionary from MCMCChains, but when evaluating a model we need the latter.","category":"page"},{"location":"why/","page":"Why FlexiChains?","title":"Why FlexiChains?","text":"On top of that, MCMCChains doesn't store the keys as VarNames: it stores them as Symbols. That means that any time we need to retrieve the original VarNames, we need to use a secret dictionary that is stored inside chain.info. This is automatically included when sampling using Turing, but it makes it somewhat frustrating to test MCMCChains-related functionality in isolation. In general, though, this is a very fragile solution and relies on Turing 'just happening' to do the right thing.","category":"page"}]
}
