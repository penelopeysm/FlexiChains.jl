<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Why FlexiChains? · FlexiChains.jl</title><meta name="title" content="Why FlexiChains? · FlexiChains.jl"/><meta property="og:title" content="Why FlexiChains? · FlexiChains.jl"/><meta property="twitter:title" content="Why FlexiChains? · FlexiChains.jl"/><meta name="description" content="Documentation for FlexiChains.jl."/><meta property="og:description" content="Documentation for FlexiChains.jl."/><meta property="twitter:description" content="Documentation for FlexiChains.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexiChains.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../turing/">Usage with Turing.jl</a></li><li><a class="tocitem" href="../summarising/">Summarising</a></li><li><a class="tocitem" href="../indexing/">Indexing</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../integrations/">Integrations with other packages</a></li><li><a class="tocitem" href="../api/">Public API</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li class="is-active"><a class="tocitem" href>Why FlexiChains?</a><ul class="internal"><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li><li><a class="tocitem" href="#Heterogeneous-parameter-types"><span>Heterogeneous parameter types</span></a></li><li><a class="tocitem" href="#Missing-data"><span>Missing data</span></a></li><li><a class="tocitem" href="#Arbitrary-types"><span>Arbitrary types</span></a></li><li><a class="tocitem" href="#Reconstructing-parameters"><span>Reconstructing parameters</span></a></li><li><a class="tocitem" href="#VarNames-as-keys"><span>VarNames as keys</span></a></li><li><a class="tocitem" href="#Performance-(on-important-things)"><span>Performance (on important things)</span></a></li><li><a class="tocitem" href="#Avoiding-name-clashes"><span>Avoiding name clashes</span></a></li><li><a class="tocitem" href="#DimensionalData.jl-indexing"><span>DimensionalData.jl indexing</span></a></li></ul></li><li><a class="tocitem" href="../whynot/">Why not FlexiChains?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Why FlexiChains?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Why FlexiChains?</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl/blob/main/docs/src/why.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Why-FlexiChains?"><a class="docs-heading-anchor" href="#Why-FlexiChains?">Why FlexiChains?</a><a id="Why-FlexiChains?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-FlexiChains?" title="Permalink"></a></h1><p>If you are a Turing user (or developer!), you may well be asking why you should consider using FlexiChains.jl.</p><p>In one sentence: <strong>FlexiChains is a more faithful representation of data.</strong> MCMCChains.jl places extremely strong restrictions on its data structure, which leads to an irrevocable loss of information.</p><p>Of course, on its own this doesn&#39;t mean much (unless you are a software engineering purist!). So this page will demonstrate a few concrete scenarios where FlexiChains has a practical advantage.</p><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><p>This package is much better documented. In my opinion. (To be fair, I did put a lot of work into it, and if I spent the same amount of time on MCMCChains, I suppose its docs would also look better.)</p><h2 id="Heterogeneous-parameter-types"><a class="docs-heading-anchor" href="#Heterogeneous-parameter-types">Heterogeneous parameter types</a><a id="Heterogeneous-parameter-types-1"></a><a class="docs-heading-anchor-permalink" href="#Heterogeneous-parameter-types" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model function f()
    x ~ Normal()
    y ~ Poisson(3.0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 2 methods)</code></pre><p>When sampling from this model, one should expect that the samples of <code>x</code> are stored as floats, whereas the samples of <code>y</code> are stored as integers, because that is what these distributions produce.</p><p>Under the hood, MCMCChains stores the values of all parameters in a single array, which means that all samples get converted into the same type.</p><pre><code class="language-julia hljs">mchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=MCMCChains.Chains)
fchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=FlexiChains.VNChain)
(eltype(mchain[:y]), eltype(fchain[:y]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Float64, Int64)</code></pre><p>In general, this doesn&#39;t cause problems with functions like <code>predict</code> because Distributions.jl kindly allows you to call <code>logpdf(::Poisson, x::Float64)</code> and returns the correct value if <code>isinteger(x)</code>. In fact, this is true of all discrete univariate distributions in Distributions.jl. But if you were to define your own discrete distribution, you would have to remember to implement this method, or else you would get an error when trying to use things like <code>predict</code>.</p><h2 id="Missing-data"><a class="docs-heading-anchor" href="#Missing-data">Missing data</a><a id="Missing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data" title="Permalink"></a></h2><p>Okay, maybe the above is still quite abstract. (For us, it&#39;s not: we actually ran into a bug with Turing&#39;s test suite once because of this very issue.) But after all, if it works for everything in Distributions, surely we&#39;re fine?</p><p>Consider the case where some data is missing:</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model function f()
    x ~ Normal()
    if x &gt; 0
        y ~ Normal(x)
    end
end

mchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=MCMCChains.Chains)
fchain = sample(Xoshiro(468), f(), MH(), 50; chain_type=FlexiChains.VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain (50 iterations, 1 chain)</span>
<span class="sgr38_5" style="color:#ff875f">↓ iter=1:50</span> | <span class="sgr38_5" style="color:#0087d7">→ chain=1:1</span>

<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>x, y
<span class="sgr1">Extra keys       </span>:logprior, :loglikelihood, :logjoint
</code></pre><p>In some samples, <code>y</code> will be present and not in others. Because MCMCChains forces all parameters to be in the same array, this means that the entire array must have an element type of <code>Union{Missing, Float64}</code>. With MCMCChains this gets propagated to all parameters, even those that are never missing, such as <code>x</code>.</p><pre><code class="language-julia hljs">(eltype(mchain[:x]), eltype(fchain[:x]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Union{Missing, Float64}, Float64)</code></pre><p>Okay, maybe you don&#39;t ever have such weird models. It turns out though that you can still run into this. In Turing&#39;s MCMC sampling, the first step is not an actual MCMC step, but rather just the initial parameters (either sampled or provided by the user). Thus, there are no &#39;sampler statistics&#39; for the first step, and these are stored as <code>missing</code> in MCMCChains. That means that all the parameters become <code>Union{Missing, Float64}</code>!</p><h2 id="Arbitrary-types"><a class="docs-heading-anchor" href="#Arbitrary-types">Arbitrary types</a><a id="Arbitrary-types-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrary-types" title="Permalink"></a></h2><p><a href="https://turinglang.org/docs/usage/tracking-extra-quantities/">Turing provides this very nice operator <code>:=</code></a>, which lets you store arbitrary values in the chain during an MCMC run.</p><p>The problem with MCMCChains is, as ever, you can only store things that are <code>Real</code> or some array thereof. Even a simple string will fail:</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model function hasstring()
    x ~ Normal()
    y := &quot;$x&quot;
end
mchain = sample(Xoshiro(468), hasstring(), MH(), 50; chain_type=MCMCChains.Chains, progress=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MethodError: no method matching varname_and_value_leaves_inner(::VarName{:y, typeof(identity)}, ::String)
The function `varname_and_value_leaves_inner` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  varname_and_value_leaves_inner(::VarName, !Matched::Real)
   @ DynamicPPL ~/.julia/packages/DynamicPPL/R1CV0/src/utils.jl:1025
  varname_and_value_leaves_inner(::VarName, !Matched::LinearAlgebra.LowerTriangular)
   @ DynamicPPL ~/.julia/packages/DynamicPPL/R1CV0/src/utils.jl:1064
  varname_and_value_leaves_inner(::VarName, !Matched::LinearAlgebra.UpperTriangular)
   @ DynamicPPL ~/.julia/packages/DynamicPPL/R1CV0/src/utils.jl:1071
  ...</code></pre><p>FlexiChains will let you store anything you like. String? No problem. ODE solver output? No problem.</p><pre><code class="language-julia hljs">fchain = sample(Xoshiro(468), hasstring(), MH(), 50; chain_type=FlexiChains.VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain (50 iterations, 1 chain)</span>
<span class="sgr38_5" style="color:#ff875f">↓ iter=1:50</span> | <span class="sgr38_5" style="color:#0087d7">→ chain=1:1</span>

<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>x, y
<span class="sgr1">Extra keys       </span>:logprior, :loglikelihood, :logjoint
</code></pre><h2 id="Reconstructing-parameters"><a class="docs-heading-anchor" href="#Reconstructing-parameters">Reconstructing parameters</a><a id="Reconstructing-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-parameters" title="Permalink"></a></h2><p>Suppose you have some array-valued parameter.</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

@model lkj() = x ~ LKJCholesky(3, 2.0)

mchain = sample(Xoshiro(468), lkj(), NUTS(), 50; chain_type=MCMCChains.Chains);
fchain = sample(Xoshiro(468), lkj(), NUTS(), 50; chain_type=FlexiChains.VNChain);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain (50 iterations, 1 chain)</span>
<span class="sgr38_5" style="color:#ff875f">↓ iter=26:75</span> | <span class="sgr38_5" style="color:#0087d7">→ chain=1:1</span>

<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>x
<span class="sgr1">Extra keys       </span>:n_steps, :is_accept, :acceptance_rate, :log_density, :hamiltonian_energy, :hamiltonian_energy_error, :max_hamiltonian_energy_error, :tree_depth, :numerical_error, :step_size, :nom_step_size, :logprior, :loglikelihood, :logjoint
</code></pre><p>With FlexiChains the Cholesky samples are kept together:</p><pre><code class="language-julia hljs">fchain[@varname(x)][iter=1, chain=1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearAlgebra.Cholesky{Float64, Matrix{Float64}}
L factor:
3×3 LinearAlgebra.LowerTriangular{Float64, Matrix{Float64}}:
  1.0         ⋅         ⋅ 
 -0.103897   0.994588   ⋅ 
  0.601826  -0.116714  0.790053</code></pre><p>Because MCMCChains stores <em>all</em> its data in a single array, it has to flatten this parameter, so good luck trying to reconstruct it.</p><pre><code class="language-julia hljs">(mchain[Symbol(&quot;x.L[1, 1]&quot;)][1, 1], mchain[Symbol(&quot;x.L[2, 1]&quot;)][1, 1]) # ...</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.0, -0.10389677326190137)</code></pre><p>Of course, if you really wanted to flatten a chain, FlexiChains lets you do that with <a href="../api/#FlexiChains.split_varnames"><code>FlexiChains.split_varnames</code></a>.</p><h2 id="VarNames-as-keys"><a class="docs-heading-anchor" href="#VarNames-as-keys">VarNames as keys</a><a id="VarNames-as-keys-1"></a><a class="docs-heading-anchor-permalink" href="#VarNames-as-keys" title="Permalink"></a></h2><p>Did you notice in that last line we had to write something like <code>Symbol(&quot;x.L[1, 1]&quot;)</code>? And since it&#39;s a <code>Symbol</code>, we <em>have</em> to get the name exactly right, we couldn&#39;t do (for example) <code>x.L[1,1]</code> without the space after the comma?</p><p>That&#39;s because MCMCChains uses AxisArrays.jl under the hood, which allows you to index into the chain using <code>Symbol</code>s — but <em>only</em> <code>Symbol</code>s. FlexiChains retains the original <code>VarName</code>s used by Turing, which is a far richer type and allows you to use keys that actually carry meaning, rather than just being strings that <em>have</em> to match exactly.</p><pre><code class="language-julia hljs">fchain[@varname(x.L[1,1])][iter=1, chain=1] # No space!</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><pre><code class="language-julia hljs">fchain[@varname(x.L[:, 1])][iter=1, chain=1] # Index into `x` any way you like</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  1.0
 -0.10389677326190137
  0.6018255364661864</code></pre><h2 id="Performance-(on-important-things)"><a class="docs-heading-anchor" href="#Performance-(on-important-things)">Performance (on important things)</a><a id="Performance-(on-important-things)-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-(on-important-things)" title="Permalink"></a></h2><p>In the following model, <code>y</code> is a single parameter that is a vector of length <code>N</code>. That means that when you use functions like <code>returned</code> or <code>predict</code> on a chain, MCMCChains has to <em>somehow</em> reconstruct the vector <code>y</code> from its components which are all stored separately.</p><pre><code class="language-julia hljs">using Turing, FlexiChains, MCMCChains, Random

@model function longvec(N)
    m ~ Normal(0)
    y ~ filldist(Normal(m), N)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">longvec (generic function with 2 methods)</code></pre><p>It turns out that if <code>N</code> is small, MCMCChains does just fine, and is in fact even faster than FlexiChains (because constructing a FlexiChain has more overhead).</p><pre><code class="language-julia hljs">using Chairmarks: @be

function benchmark(N)
    model = (longvec(N) | (y = rand(Xoshiro(468), Normal(2.0), N),))
    mchain = sample(Xoshiro(468), model, NUTS(), 500; chain_type=MCMCChains.Chains);
    fchain = sample(Xoshiro(468), model, NUTS(), 500; chain_type=FlexiChains.VNChain);
    mt = @be predict(longvec(N), mchain)
    ft = @be predict(longvec(N), fchain)
    return (N=N, mcmcchains=median(mt).time, flexichains=median(ft).time)
end

benchmark(2) # The results are in seconds</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(N = 2, mcmcchains = 0.014217504500000002, flexichains = 0.019381214)</code></pre><p>But MCMCChains scales really poorly with <code>N</code>.</p><pre><code class="language-julia hljs">benchmark(1000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(N = 1000, mcmcchains = 1.5887914760000001, flexichains = 0.2660831455)</code></pre><h2 id="Avoiding-name-clashes"><a class="docs-heading-anchor" href="#Avoiding-name-clashes">Avoiding name clashes</a><a id="Avoiding-name-clashes-1"></a><a class="docs-heading-anchor-permalink" href="#Avoiding-name-clashes" title="Permalink"></a></h2><p>All of Turing.jl&#39;s samplers include some &#39;sampler statistics&#39; in the output chain. These are pretty useful things like the step size, whether a transition was accepted, the log-probabilities, and so on.</p><p>But if you have a parameter that <em>just happens</em> to share a name with these, then MCMCChains will make it pretty hard for you to get one of them.</p><pre><code class="language-julia hljs">using Random, Turing, FlexiChains, MCMCChains

# Oops! This will clash with the actual log prior.
@model pr() = logprior ~ Normal()

mchain = sample(Xoshiro(468), pr(), MH(), 50; chain_type=MCMCChains.Chains);
collect(keys(mchain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Symbol}:
 :logprior
 :lp
 :logprior
 :loglikelihood</code></pre><p>There are two columns labelled <code>:logprior</code>. Of course, one is your parameter, the other is the actual log prior probability. It&#39;s a mystery which one is which, and which you get when you do <code>mchain[:logprior]</code>! You could avoid this if you knew exactly which keys the sampler returns, but in general this isn&#39;t documented anywhere. (It <em>should</em> be, of course.)</p><p>FlexiChains avoids clashes by completely separating <code>Parameter</code> and <code>Extra</code> keys, meaning that you can use any name you like without worrying about a rogue sampler breaking your workflow.</p><h2 id="DimensionalData.jl-indexing"><a class="docs-heading-anchor" href="#DimensionalData.jl-indexing">DimensionalData.jl indexing</a><a id="DimensionalData.jl-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#DimensionalData.jl-indexing" title="Permalink"></a></h2><p>As you will have noticed, FlexiChains uses DimensionalData.jl to return information-rich matrices. That means that you can <a href="../indexing/">use all the selectors from DimensionalData.jl</a> to extract exactly what you want. Don&#39;t want to use those? No problem; good old 1-based indices work fine too.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« Internals</a><a class="docs-footer-nextpage" href="../whynot/">Why not FlexiChains? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 20 October 2025 00:08">Monday 20 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
