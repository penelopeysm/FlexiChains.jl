<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Why a new package? · FlexiChains.jl</title><meta name="title" content="Why a new package? · FlexiChains.jl"/><meta property="og:title" content="Why a new package? · FlexiChains.jl"/><meta property="twitter:title" content="Why a new package? · FlexiChains.jl"/><meta name="description" content="Documentation for FlexiChains.jl."/><meta property="og:description" content="Documentation for FlexiChains.jl."/><meta property="twitter:description" content="Documentation for FlexiChains.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexiChains.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../turing/">Usage with Turing.jl</a></li><li><a class="tocitem" href="../indexing/">Indexing in FlexiChains.jl</a></li><li><a class="tocitem" href="../integrations/">Integrations with other packages</a></li><li><a class="tocitem" href="../details/">FlexiChains in more detail</a></li><li class="is-active"><a class="tocitem" href>Why a new package?</a><ul class="internal"><li><a class="tocitem" href="#The-fundamental-difference"><span>The fundamental difference</span></a></li><li><a class="tocitem" href="#Indexing-keys"><span>Indexing keys</span></a></li><li><a class="tocitem" href="#Accessing-vector-valued-parameters"><span>Accessing vector-valued parameters</span></a></li><li><a class="tocitem" href="#Accessing-parameters-with-even-more-special-types"><span>Accessing parameters with even more special types</span></a></li><li><a class="tocitem" href="#Accessing-individual-elements"><span>Accessing individual elements</span></a></li><li><a class="tocitem" href="#Other-types-of-data"><span>Other types of data</span></a></li><li><a class="tocitem" href="#No-need-to-avoid-reserved-names"><span>No need to avoid reserved names</span></a></li><li><a class="tocitem" href="#For-DynamicPPL-developers"><span>For DynamicPPL developers</span></a></li><li><a class="tocitem" href="#Design-goals"><span>Design goals</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Why a new package?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Why a new package?</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/penelopeysm/FlexiChains.jl/blob/main/docs/src/whynew.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Why-a-new-package?"><a class="docs-heading-anchor" href="#Why-a-new-package?">Why a new package?</a><a id="Why-a-new-package?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-a-new-package?" title="Permalink"></a></h1><p>FlexiChains.jl has been designed from the ground up to address existing limitations of <a href="https://github.com/TuringLang/MCMCChains.jl">MCMCChains.jl</a>.</p><h2 id="The-fundamental-difference"><a class="docs-heading-anchor" href="#The-fundamental-difference">The fundamental difference</a><a id="The-fundamental-difference-1"></a><a class="docs-heading-anchor-permalink" href="#The-fundamental-difference" title="Permalink"></a></h2><p>Under the hood, MCMCChains.jl uses <a href="https://github.com/JuliaArrays/AxisArrays.jl/"><code>AxisArrays.AxisArray</code></a> as its data structure. Specifically, this allows it to store data in a compact 3-dimensional matrix, and index into the matrix using <code>Symbol</code>s.</p><p>The downside of this is that it enforces a key type of <code>Symbol</code> and a value type of <code>Tval&lt;:Real</code>. This means that, for example, if you have a model with vector-valued parameters (like <code>x</code> above), the vectors will be split up into their individual elements before being stored in the chain.</p><p>This is <em>the</em> core of how MCMCChains and FlexiChains differ, and all of the behaviour shown below stems from this.</p><p>To illustrate this, let&#39;s sample from a Turing model and store the results in both <code>MCMCChains.Chains</code> and <code>FlexiChains.VNChain</code>.</p><pre><code class="language-julia hljs">using Turing
using MCMCChains: Chains
using FlexiChains: VNChain, VarName, @varname
using Random: Xoshiro
using PDMats: PDMats

Turing.setprogress!(false)

@model function f(x)
    sigma ~ truncated(Normal(0, 1); lower=0)
    chol ~ LKJCholesky(3, 1.0)
    corr := PDMats.PDMat(chol)
    mu ~ MvNormal(zeros(3), sigma^2 * I)
    return x ~ MvNormal(mu, corr)
end

model = f(randn(Xoshiro(468), 3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DynamicPPL.Model{typeof(Main.f), (:x,), (), (), Tuple{Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}(Main.f, (x = [0.07200886749732076, -0.0740437565595174, 0.6327762377562545],), NamedTuple(), DynamicPPL.DefaultContext())</code></pre><p>The default chain type for Turing&#39;s <code>sample</code> is still <code>MCMCChains.Chains</code>; we just specify it here for clarity.</p><pre><code class="language-julia hljs">mcmc = sample(Xoshiro(468), model, NUTS(), 100; chain_type=Chains)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (100×33×1 Array{Float64, 3}):

Iterations        = 51:1:150
Number of chains  = 1
Samples per chain = 100
Wall duration     = 5.44 seconds
Compute duration  = 5.44 seconds
parameters        = sigma, chol.L[1, 1], chol.L[2, 1], chol.L[3, 1], chol.L[2, 2], chol.L[3, 2], chol.L[3, 3], corr[1, 1], corr[2, 1], corr[3, 1], corr[1, 2], corr[2, 2], corr[3, 2], corr[1, 3], corr[2, 3], corr[3, 3], mu[1], mu[2], mu[3]
internals         = n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size, lp, logprior, loglikelihood

Use `describe(chains)` for summary statistics and quantiles.
</code></pre><p>Because FlexiChains does not enforce a key type, you are technically required to specify the key type of the chain as a type parameter. You could, for example, write <code>FlexiChains.FlexiChain{DynamicPPL.VarName}</code>. But since this is really the main use case of FlexiChains, we provide a convenient alias for this, <code>FlexiChains.VNChain</code>.</p><pre><code class="language-julia hljs">flexi = sample(Xoshiro(468), model, NUTS(), 100; chain_type=VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain | 100 iterations (<span class="sgr38_5" style="color:#ff875f">51:150</span>) | 1 chain (<span class="sgr38_5" style="color:#0087d7">1:1</span>)</span>
<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>sigma, chol, corr, mu
<span class="sgr1">Extra keys       </span>:n_steps, :is_accept, :acceptance_rate, :log_density, :hamiltonian_energy, :hamiltonian_energy_error, :max_hamiltonian_energy_error, :tree_depth, :numerical_error, :step_size, :nom_step_size, :logprior, :loglikelihood, :logjoint
</code></pre><p>Here, we expect the following parameters to be present in the chain:</p><ul><li><code>sigma</code> is a scalar;</li><li><code>chol</code> is a Cholesky factor which contains a 3×3 lower triangular matrix;</li><li><code>corr</code> is a 3×3 correlation matrix, which is a positive-definite matrix;</li><li><code>mu</code> is a length-3 vector.</li></ul><p>Let&#39;s test first that both chains contain the same values for <code>sigma</code>. (Some fiddling is required because <code>mcmc[:sigma]</code> returns an AxisArray with a 100×1 matrix, while <code>flexi[:sigma]</code> returns a 100-element vector.)</p><pre><code class="language-julia hljs">vec(mcmc[:sigma].data) == flexi[@varname(sigma)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><h2 id="Indexing-keys"><a class="docs-heading-anchor" href="#Indexing-keys">Indexing keys</a><a id="Indexing-keys-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-keys" title="Permalink"></a></h2><p>There is already one difference here: when indexing into MCMCChains you need to use a <code>Symbol</code> or <code>String</code>, whereas with FlexiChains you can use the original <code>VarName</code>.</p><p>If you think this is too verbose, fret not! FlexiChains also lets you use <code>Symbol</code>s (mainly for compatibility with MCMCChains):</p><pre><code class="language-julia hljs">flexi[:sigma] == flexi[@varname(sigma)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The rest of this page uses <code>VarName</code>s, but you can mentally replace them with <code>Symbol</code>s if you prefer.</p><h2 id="Accessing-vector-valued-parameters"><a class="docs-heading-anchor" href="#Accessing-vector-valued-parameters">Accessing vector-valued parameters</a><a id="Accessing-vector-valued-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-vector-valued-parameters" title="Permalink"></a></h2><p>Suppose you want to access the value of <code>mu</code> in the first iteration.</p><p>With FlexiChains, you can do this directly as:</p><pre><code class="language-julia hljs">flexi[:mu][1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -1.1392389884438665
  0.6792483949630452
  1.2879582040592625</code></pre><p>With MCMCChains, because <code>mu</code> has been split up into its constituent elements, you need to do:</p><pre><code class="language-julia hljs">[mu[1] for mu in (mcmc[&quot;mu[1]&quot;], mcmc[&quot;mu[2]&quot;], mcmc[&quot;mu[3]&quot;])]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -1.1392389884438665
  0.6792483949630452
  1.2879582040592625</code></pre><h2 id="Accessing-parameters-with-even-more-special-types"><a class="docs-heading-anchor" href="#Accessing-parameters-with-even-more-special-types">Accessing parameters with even more special types</a><a id="Accessing-parameters-with-even-more-special-types-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-parameters-with-even-more-special-types" title="Permalink"></a></h2><p>Now suppose you want to extract the sampled values of <code>chol</code> and <code>corr</code>, and check that</p><pre><code class="language-julia hljs"># This code block isn&#39;t executed because we haven&#39;t defined `chols` and `corrs`
for (chol, corr) in zip(chols, corrs)
    chol == cholesky(corr) || error(&quot;oops&quot;)
end</code></pre><p>The question is of course how one can obtain the vectors <code>chols</code> and <code>corrs</code> from the chain. With FlexiChains, you can do this directly as:</p><pre><code class="language-julia hljs">chols = flexi[:chol]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">100</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{LinearAlgebra.Cholesky{Float64, Matrix{Float64}}, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├─────────────────────────────────────────────────────────────── dims ┤</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">51:150</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└─────────────────────────────────────────────────────────────────────┘</span>
   <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>  …  <span class="sgr38_5" style="color:#0087d7">1</span>
  <span class="sgr38_5" style="color:#ff875f">51</span>        Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.586077 0.810255 0.0; -0.746929 0.150506 0.647645], &#39;L&#39;, 0)
  <span class="sgr38_5" style="color:#ff875f">52</span>        Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.341107 0.940024 0.0; 0.899763 -0.0254936 0.435634], &#39;L&#39;, 0)
  <span class="sgr38_5" style="color:#ff875f">53</span>        Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.22866 0.973506 0.0; 0.936834 0.0889171 0.338282], &#39;L&#39;, 0)
  <span class="sgr38_5" style="color:#ff875f">54</span>        Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.117313 0.993095 0.0; 0.736787 0.419986 0.529866], &#39;L&#39;, 0)
   ⋮    ⋱  
 <span class="sgr38_5" style="color:#ff875f">147</span>        Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.173611 0.984814 0.0; 0.0503377 0.951562 0.303309], &#39;L&#39;, 0)
 <span class="sgr38_5" style="color:#ff875f">148</span>        Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.272492 0.962158 0.0; -0.0205614 0.957758 0.286839], &#39;L&#39;, 0)
 <span class="sgr38_5" style="color:#ff875f">149</span>        Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.00809677 0.999967 0.0; 0.0743796 0.939578 0.334157], &#39;L&#39;, 0)
 <span class="sgr38_5" style="color:#ff875f">150</span>    …   Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.126754 0.991934 0.0; 0.311903 -0.858355 0.407363], &#39;L&#39;, 0)</code></pre><p>and likewise for <code>:corr</code>.</p><p>On the other hand, with MCMCChains, reconstructing the <code>chol</code>s becomes a non-trivial task:</p><pre><code class="language-julia hljs">using LinearAlgebra

chols = map(1:length(mcmc)) do i
    c = Cholesky(LowerTriangular(zeros(3, 3)))
    for j in 1:3
        for k in 1:j
            c.L[j, k] = mcmc[&quot;chol.L[$j, $k]&quot;][i]
        end
    end
    c
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{LinearAlgebra.Cholesky{Float64, Matrix{Float64}}}:
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.5860773802277239 0.8102550859978652 0.0; -0.7469292336209454 0.15050640644285113 0.6476453825837767], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.3411071258703411 0.9400244298317334 0.0; 0.899762588721382 -0.025493645646176823 0.43563443156971], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.22865990191989105 0.9735063683684796 0.0; 0.9368344447278419 0.0889171494171421 0.3382823727465055], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.11731305365601366 0.9930949840986516 0.0; 0.7367865675072002 0.4199856781570316 0.5298656283284812], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.8661421642325011 0.499797710417564 0.0; -0.08147249049165844 0.8028537309327372 0.5905828646519222], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.7915956125133766 0.6110453225821896 0.0; -0.4617221388497685 0.2591504883018077 0.8483240482910582], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.19479524452401334 0.9808439288239642 0.0; -0.8214944231493493 0.01938123156008847 0.5698870770580187], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.46584740396209223 0.8848650723255943 0.0; 0.445285472299019 0.5379868888035035 0.7157450353547458], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.6641294713640047 0.7476175795590736 0.0; -0.7896252944833059 0.4199276462449585 0.44738424897544327], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.3833011260982241 0.923623433403372 0.0; -0.1266515184207426 0.5759602234158419 0.8076070913039914], &#39;L&#39;, 0)
 ⋮
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.08639592966251515 0.9962608811640401 0.0; 0.32932901280539045 0.3275829827034401 0.8855686256681323], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.12648982732417258 0.9919679045127926 0.0; 0.07881614347853526 0.3763779004171679 0.9231076273137035], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.5978097432296396 0.8016380173742461 0.0; -0.2280244289498786 -0.8806979313897991 0.41518190404666067], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.5584473109651807 0.8295399935360311 0.0; 0.1472789482229396 0.8811635418605102 0.44928801887673964], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; -0.6584074906771923 0.7526616611865938 0.0; 0.1887887650182063 0.9428797599951199 0.2744750633380849], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.17361060170392226 0.9848143779291619 0.0; 0.05033768353928505 0.951561602517254 0.3033094694049201], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.2724921476529185 0.9621580064976334 0.0; -0.020561393008983273 0.9577581834878659 0.28683878935658863], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.008096769808300541 0.9999672206220919 0.0; 0.07437960390895013 0.9395779043904521 0.334157202681005], &#39;L&#39;, 0)
 LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([1.0 0.0 0.0; 0.12675395595070182 0.9919341886692118 0.0; 0.3119025410577572 -0.8583545752949742 0.4073625264453011], &#39;L&#39;, 0)</code></pre><p>and similarly for the <code>corr</code>s (which we won&#39;t demonstrate here).</p><p>In general the point is that in any situation where you want to work with the actual types of the parameters, rather than their individual elements, FlexiChains makes this much easier.</p><h2 id="Accessing-individual-elements"><a class="docs-heading-anchor" href="#Accessing-individual-elements">Accessing individual elements</a><a id="Accessing-individual-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-individual-elements" title="Permalink"></a></h2><p>Sometimes maybe you really want to access just <code>mu[2]</code> without any reference to <code>mu[1]</code> or <code>mu[3]</code>.</p><p>Because FlexiChains stores the entire vector <code>mu</code>, you will then need to index into it:</p><pre><code class="language-julia hljs">[mu_sample[2] for mu_sample in flexi[:mu]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">100</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├────────────────────────────┴─────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">51:150</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└──────────────────────────────────────────────────────────────┘</span>
   <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>   <span class="sgr38_5" style="color:#0087d7">1</span>
  <span class="sgr38_5" style="color:#ff875f">51</span>     0.679248
  <span class="sgr38_5" style="color:#ff875f">52</span>     0.947131
  <span class="sgr38_5" style="color:#ff875f">53</span>     0.770937
  <span class="sgr38_5" style="color:#ff875f">54</span>     0.024145
   ⋮    
 <span class="sgr38_5" style="color:#ff875f">147</span>     0.0548423
 <span class="sgr38_5" style="color:#ff875f">148</span>    -0.0333075
 <span class="sgr38_5" style="color:#ff875f">149</span>    -0.00576508
 <span class="sgr38_5" style="color:#ff875f">150</span>     0.517724</code></pre><p>In MCMCChains you can of course do</p><pre><code class="language-julia hljs">mcmc[&quot;mu[2]&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional AxisArray{Float64,2,...} with axes:
    :iter, 51:1:150
    :chain, 1:1
And data, a 100×1 Matrix{Float64}:
  0.6792483949630452
  0.9471309892040305
  0.7709365001498734
  0.024144991486672096
  0.8070227034555837
  0.81476651791777
  0.772690704376834
  0.2247063484683028
  0.8917472456946623
 -0.5507707403145068
  ⋮
 -0.025973820984346058
 -0.2355141671376212
 -0.0684978801556822
 -0.06842562253633273
 -0.18841999609713203
  0.054842332762082516
 -0.033307514975308664
 -0.005765077736916341
  0.5177235899285357</code></pre><p>Note, though, that MCMCChains requires you to pass a <em>string</em> <code>&quot;2&quot;</code> to get the second variable. Of course, if you have an integer <code>2</code> this is quite easily done with interpolation, but I would argue from a readability perspective it&#39;s much clearer to index with an integer <code>2</code> rather than a string.</p><h2 id="Other-types-of-data"><a class="docs-heading-anchor" href="#Other-types-of-data">Other types of data</a><a id="Other-types-of-data-1"></a><a class="docs-heading-anchor-permalink" href="#Other-types-of-data" title="Permalink"></a></h2><p>Let&#39;s say we define a weird new discrete distribution which samples from the two structs <code>Duck()</code> and <code>Goose()</code>.</p><p>(Why would you want to do this? Well, why <em>shouldn&#39;t</em> you be able to do it? Turing&#39;s docs <a href="https://turinglang.org/docs/usage/custom-distribution/">tell you how to define your own distributions</a>, but it doesn&#39;t say that you have to use numbers. The point is that FlexiChains doesn&#39;t <em>force</em> you to stick only to distributions over numbers.)</p><pre><code class="language-julia hljs">using Distributions, Random

abstract type Bird end
struct Duck &lt;: Bird end
struct Goose &lt;: Bird end

struct BirdDist &lt;: Distributions.DiscreteUnivariateDistribution end
Distributions.rand(rng::Random.AbstractRNG, ::BirdDist) = rand(rng) &lt; 0.3 ? Duck() : Goose()
Distributions.logpdf(::BirdDist, x::Duck) = log(0.3)
Distributions.logpdf(::BirdDist, x::Goose) = log(0.7)

@model function f()
    return x ~ BirdDist()
end

# A bit more boilerplate is needed here to actually make it work with Turing.
using Bijectors, DynamicPPL
DynamicPPL.tovec(b::Bird) = [b]
Bijectors.logabsdetjac(::typeof(identity), ::Bird) = 0.0

# mcmc = sample(f(), MH(), 100; chain_type=VNChain)</code></pre><p>TODO: Fix the example above, it fails with typed VarInfo because typed VarInfo expects Real things to put into Metadata. SimpleVarInfo would work. See https://github.com/TuringLang/DynamicPPL.jl/pull/1003</p><p>Well, that worked quite nicely with FlexiChains.</p><p>MCMCChains on the other hand would completely error here because it requires all its values to be <code>Real</code>. (To be precise, it requires all its values to be <em>convertable</em> to <code>Real</code>. So a distribution over <code>Char</code> works, even though <code>Char &lt;: Real</code> is false, because <code>Char</code>s can be converted to <code>Real</code>.)</p><h2 id="No-need-to-avoid-reserved-names"><a class="docs-heading-anchor" href="#No-need-to-avoid-reserved-names">No need to avoid reserved names</a><a id="No-need-to-avoid-reserved-names-1"></a><a class="docs-heading-anchor-permalink" href="#No-need-to-avoid-reserved-names" title="Permalink"></a></h2><p>When sampling from a Turing model with MCMCChains as the output format, some metadata (non-parameter keys) such as <code>lp</code> are added to the chain. If your model contains a variable called <code>lp</code>, sampling will still work but <a href="https://github.com/TuringLang/MCMCChains.jl/issues/469">odd things will happen</a>. For example, it will look as if your chain does not actually have any variables:</p><pre><code class="language-julia hljs">@model function lp_model()
    return lp ~ Normal()
end

mchain = sample(Xoshiro(468), lp_model(), NUTS(), 100; chain_type=Chains)
describe(mchain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Info: Found initial step size
└   ϵ = 3.2
Chains MCMC chain (100×15×1 Array{Float64, 3}):

Iterations        = 51:1:150
Number of chains  = 1
Samples per chain = 100
Wall duration     = 2.49 seconds
Compute duration  = 2.49 seconds
parameters        =
internals         = n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size, lp, logprior, loglikelihood

Summary Statistics
  parameters   mean   std      mcse   ess_bulk   ess_tail      rhat   ess_per_sec
      Symbol    Any   Any   Float64    Float64    Float64   Float64       Float64


Quantiles
  parameters   2.5%   25.0%   50.0%   75.0%   97.5%
      Symbol    Any     Any     Any     Any     Any</code></pre><p>When you index into <code>mchain[:lp]</code>, how do you know whether it refers to the <code>lp</code> variable in your model or the <code>lp</code> metadata key?</p><pre><code class="language-julia hljs">any(mchain[:lp] .&gt; 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Well, since there are some positive values, it has to be the parameter, because the metadata <code>lp = logpdf(Normal(), value_of_lp_parameter)</code> is always negative. But you didn&#39;t know that when you tried to index into it, you had to reverse engineer it.</p><p>Besides, if you actually want the log-density, it&#39;s now gone. Tough luck. (You can get it back with <code>logjoint(lp_model(), mchain)</code> if you want.)</p><p>HMC samplers further include extra metadata such as <code>hamiltonian_energy</code>, and in general <strong>any sampler</strong> can include any kind of extra metadata it wants. As a user, you have no way of knowing what these names are, and you have to avoid using them in your model, which is quite unfair.</p><p>FlexiChains circumvents this entirely since it stores these separately as <code>Parameter(@varname(lp))</code> and <code>Extra(:lp)</code>. To be precise, the log joint is stored as <code>Extra(:logjoint)</code>, so the point is that even if you had a parameter named <code>@varname(logjoint)</code> this woud still be fine.</p><pre><code class="language-julia hljs">@model function lj_model()
    return logjoint ~ Normal()
end

fchain = sample(Xoshiro(468), lj_model(), NUTS(), 100; chain_type=VNChain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FlexiChain | 100 iterations (<span class="sgr38_5" style="color:#ff875f">51:150</span>) | 1 chain (<span class="sgr38_5" style="color:#0087d7">1:1</span>)</span>
<span class="sgr1">Parameter type   </span>VarName
<span class="sgr1">Parameters       </span>logjoint
<span class="sgr1">Extra keys       </span>:n_steps, :is_accept, :acceptance_rate, :log_density, :hamiltonian_energy, :hamiltonian_energy_error, :max_hamiltonian_energy_error, :tree_depth, :numerical_error, :step_size, :nom_step_size, :logprior, :loglikelihood, :logjoint
</code></pre><p>You will of course run into ambiguities if you simply attempt to index the chain with <code>[:logjoint]</code>, because both the <code>Parameter(@varname(logjoint))</code> and the <code>Extra(:logjoint)</code> exist.</p><pre><code class="language-julia hljs">fchain[:logjoint]
# This code block isn&#39;t run because it would throw the following error:
# ArgumentError: multiple keys correspond to symbol :logjoint.</code></pre><p>but you can still access the value using the original value of the <code>Parameter</code>:</p><pre><code class="language-julia hljs">fchain[@varname(logjoint)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">100</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├────────────────────────────┴─────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">51:150</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└──────────────────────────────────────────────────────────────┘</span>
   <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>   <span class="sgr38_5" style="color:#0087d7">1</span>
  <span class="sgr38_5" style="color:#ff875f">51</span>    -0.363205
  <span class="sgr38_5" style="color:#ff875f">52</span>     0.323576
  <span class="sgr38_5" style="color:#ff875f">53</span>    -0.405424
  <span class="sgr38_5" style="color:#ff875f">54</span>     0.385871
   ⋮    
 <span class="sgr38_5" style="color:#ff875f">147</span>    -0.756388
 <span class="sgr38_5" style="color:#ff875f">148</span>    -1.00764
 <span class="sgr38_5" style="color:#ff875f">149</span>    -1.00764
 <span class="sgr38_5" style="color:#ff875f">150</span>    -0.313984</code></pre><p>and the corresponding metadata:</p><p>(TODO: fix interface)</p><pre><code class="language-julia hljs">using FlexiChains: Extra
fchain[Extra(:logjoint)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">┌ </span><span class="sgr38_5" style="color:#ff875f">100</span>×<span class="sgr38_5" style="color:#0087d7">1</span> DimArray{Float64, 2}<span class="sgr90"> ┐</span>
<span class="sgr90">├────────────────────────────┴─────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ iter</span> Sampled{Int64} <span class="sgr38_5" style="color:#ff875f">51:150</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ chain</span> Sampled{Int64} <span class="sgr38_5" style="color:#0087d7">1:1</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">└──────────────────────────────────────────────────────────────┘</span>
   <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>   <span class="sgr38_5" style="color:#0087d7">1</span>
  <span class="sgr38_5" style="color:#ff875f">51</span>    -0.984897
  <span class="sgr38_5" style="color:#ff875f">52</span>    -0.971289
  <span class="sgr38_5" style="color:#ff875f">53</span>    -1.00112
  <span class="sgr38_5" style="color:#ff875f">54</span>    -0.993387
   ⋮    
 <span class="sgr38_5" style="color:#ff875f">147</span>    -1.205
 <span class="sgr38_5" style="color:#ff875f">148</span>    -1.42661
 <span class="sgr38_5" style="color:#ff875f">149</span>    -1.42661
 <span class="sgr38_5" style="color:#ff875f">150</span>    -0.968232</code></pre><p>and indeed we can check that these do align:</p><pre><code class="language-julia hljs">logpdf.(Normal(), fchain[@varname(logjoint)]) ≈ fchain[Extra(:logjoint)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>TODO pretty-printing / summary stats</p><h2 id="For-DynamicPPL-developers"><a class="docs-heading-anchor" href="#For-DynamicPPL-developers">For DynamicPPL developers</a><a id="For-DynamicPPL-developers-1"></a><a class="docs-heading-anchor-permalink" href="#For-DynamicPPL-developers" title="Permalink"></a></h2><p>TODO Write about how this makes life a lot easier for things like <code>predict</code>.</p><h2 id="Design-goals"><a class="docs-heading-anchor" href="#Design-goals">Design goals</a><a id="Design-goals-1"></a><a class="docs-heading-anchor-permalink" href="#Design-goals" title="Permalink"></a></h2><p>My main design goals for FlexiChains.jl were twofold:</p><ol><li><p>To provide a rich data structure that can more faithfully represent the outputs from sampling with Turing.jl.</p><p>The restriction of MCMCChains.jl to <code>Symbol</code> keys and <code>Real</code> values means that round-trip conversion is a lossy operation. Consider, e.g., the <code>predict(::Model, ::MCMCChains.Chains)</code> function, which is used to sample from the posterior predictive distribution. This requires one to extract the values from the chain and insert them back into the model (or technically the <code>VarInfo</code>).</p><p>However, in general one cannot reconstruct a vector <code>x</code> from its constituent elements <code>x[1]</code>, <code>x[2]</code>, ... as we do not know the appropriate length of the vector! The current implementation of this function in DynamicPPL.jl thus has to, essentially, insert all the elements it can find and hope for the best.</p><p>Essentially, MCMCChains&#39; data structure forces packages like Turing.jl and DynamicPPL.jl to include workarounds to deal with the limitations of the chains package.</p></li><li><p>To create a robust and readable codebase.</p><p>Much Julia code is written with the intention of efficiency or versatility, often sacrificing clarity in the process. This is usually acceptable when creating simple scripts. However, I believe that library code should be held to a (much) higher standard.</p><p>In particular, I consider the overuse of multiple dispatch to be a major source of confusion in Julia code. Types cannot be fully inferred at compile time (and even when they can, it requires packages such as JET.jl, which do not (yet) have convenient language server integrations). This means that when reading code, one cannot easily determine which method is being called.</p><p>A prime example is the <code>Chains</code> constructor in MCMCChains.jl. <code>methods(Chains)</code> returns 11 methods, and each time you see a call to <code>Chains(...)</code> you need to figure out which of these 11 it is. In writing FlexiChains I have made a conscious choice to create only two inner constructors for <code>FlexiChain</code>.</p></li></ol><p>In particular, notice that <em>performance</em> is not one of my considerations. In my opinion, performance is only a minor concern for FlexiChains.jl, because the main bottleneck in Bayesian inference is the sampling, not how fast one can construct or index into a chain.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../details/">« FlexiChains in more detail</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 6 October 2025 23:47">Monday 6 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
